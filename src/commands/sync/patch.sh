#!/bin/bash

# sync_patch_command.sh - Apply a previously generated patch file
#
# This command applies a patch file created by 'monk sync diff --output' to a
# destination endpoint. The patch contains a list of operations (insert, update,
# delete) that will be executed using the bulk API for efficiency.
#
# Usage Examples:
#   monk sync patch changes.patch tenant-b:users
#   monk sync patch migration.patch server2:tenant-b:users --dry-run
#   monk sync patch changes.patch tenant-b:users --reverse
#
# Patch File Format:
#   JSON file containing metadata and list of operations.
#   Generated by: monk sync diff source dest --output patch.json
#
# Endpoint Format:
#   tenant:schema              - Uses current server
#   server:tenant:schema       - Uses specific server
#
# Options:
#   --dry-run                  - Show what would be done without applying
#   --reverse                  - Apply patch in reverse (undo changes)

# Check dependencies
check_dependencies

# Get arguments from bashly
patch_file="${args[patch_file]}"
dest_endpoint="${args[destination]}"
dry_run="${args[--dry-run]}"
reverse="${args[--reverse]}"

# Validate patch file exists
if [ ! -f "$patch_file" ]; then
    print_error "Patch file does not exist: $patch_file"
    exit 1
fi

# Check if jq is available
if ! command -v jq >/dev/null 2>&1; then
    print_error "jq is required for patch operations"
    exit 1
fi

# Read and validate patch file
print_info "Reading patch file: $patch_file"
patch_json=$(cat "$patch_file")

if ! echo "$patch_json" | jq -e '.operations' >/dev/null 2>&1; then
    print_error "Invalid patch file format: missing 'operations' field"
    exit 1
fi

# Extract metadata
patch_source=$(echo "$patch_json" | jq -r '.metadata.source // "unknown"')
patch_dest=$(echo "$patch_json" | jq -r '.metadata.destination // "unknown"')
patch_created=$(echo "$patch_json" | jq -r '.metadata.created_at // "unknown"')

print_info "Patch created: $patch_created"
print_info "Original source: $patch_source"
print_info "Original destination: $patch_dest"

# Parse destination endpoint
print_info "Parsing destination endpoint: $dest_endpoint"
endpoint_info=$(parse_sync_endpoint "$dest_endpoint")

if [ $? -ne 0 ]; then
    print_error "Failed to parse destination endpoint"
    exit 1
fi

# Validate it's a remote endpoint
endpoint_type=$(echo "$endpoint_info" | jq -r '.type')

if [ "$endpoint_type" != "remote" ]; then
    print_error "Destination must be a remote endpoint (tenant:schema or server:tenant:schema)"
    exit 1
fi

# Extract endpoint details
server=$(echo "$endpoint_info" | jq -r '.server')
tenant=$(echo "$endpoint_info" | jq -r '.tenant')
schema=$(echo "$endpoint_info" | jq -r '.schema')

print_info "Target: $server:$tenant:$schema"

# Validate schema
validate_schema "$schema"

# Extract operations
operations=$(echo "$patch_json" | jq '.operations')

# Get operation counts
total_ops=$(echo "$operations" | jq 'length')
insert_count=$(echo "$operations" | jq '[.[] | select(.op == "insert")] | length')
update_count=$(echo "$operations" | jq '[.[] | select(.op == "update")] | length')
delete_count=$(echo "$operations" | jq '[.[] | select(.op == "delete")] | length')
unchanged_count=$(echo "$operations" | jq '[.[] | select(.op == "unchanged")] | length')

print_info "Patch contains $total_ops operations:"
print_info "  Insert: $insert_count"
print_info "  Update: $update_count"
print_info "  Delete: $delete_count"
print_info "  Unchanged: $unchanged_count (will skip)"

# Filter out unchanged operations
active_ops=$((insert_count + update_count + delete_count))

if [ "$active_ops" -eq 0 ]; then
    print_success "No operations to apply - patch is empty"
    exit 0
fi

# Reverse mode: swap operations
if [ "$reverse" = "true" ]; then
    print_info "REVERSE MODE: Reversing patch operations"
    operations=$(echo "$operations" | jq '
        map(
            if .op == "insert" then
                {op: "delete", id: .id, record: .record}
            elif .op == "delete" then
                {op: "insert", id: .id, record: .record}
            elif .op == "update" then
                {op: "update", id: .id, old: .new, new: .old}
            else
                .
            end
        )
    ')
fi

# Show summary
echo ""
echo "Patch Summary"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
if [ "$reverse" = "true" ]; then
    echo "Mode: REVERSE (undo)"
else
    echo "Mode: FORWARD (apply)"
fi
echo "Target: $server:$tenant:$schema"
echo "Operations to apply: $active_ops"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

# Dry run mode
if [ "$dry_run" = "true" ]; then
    print_info "DRY RUN: Would apply $active_ops operations"
    
    # Show sample operations
    echo "$operations" | jq -r '
        .[] | select(.op != "unchanged") | 
        "\(.op | ascii_upcase): \(.id)"
    ' | head -10
    
    if [ "$active_ops" -gt 10 ]; then
        echo "... and $((active_ops - 10)) more operations"
    fi
    
    print_success "Dry run completed (no changes made)"
    exit 0
fi

# Convert patch operations to bulk API format
print_info "Converting patch to bulk operations..."
bulk_operations=$(echo "$operations" | jq -c --arg schema "$schema" '
    [
        .[] | 
        select(.op != "unchanged") |
        if .op == "insert" then
            {
                operation: "create-one",
                schema: $schema,
                data: .record
            }
        elif .op == "update" then
            {
                operation: "update-one",
                schema: $schema,
                id: .id,
                data: .new
            }
        elif .op == "delete" then
            {
                operation: "delete-one",
                schema: $schema,
                id: .id
            }
        else
            empty
        end
    ]
')

# Validate bulk operations
bulk_count=$(echo "$bulk_operations" | jq 'length')

if [ "$bulk_count" -eq 0 ]; then
    print_success "No operations to apply"
    exit 0
fi

print_info "Prepared $bulk_count bulk operations"

# Save current context
prev_server=$(get_current_server_name)
prev_tenant=$(get_current_tenant_name)

# Switch to destination context
if [ "$server" != "$prev_server" ]; then
    switch_server "$server" >/dev/null 2>&1 || {
        print_error "Failed to switch to server: $server"
        exit 1
    }
fi

if [ "$tenant" != "$prev_tenant" ]; then
    switch_tenant "$tenant" >/dev/null 2>&1 || {
        print_error "Failed to switch to tenant: $tenant"
        # Restore previous server
        [ -n "$prev_server" ] && switch_server "$prev_server" >/dev/null 2>&1
        exit 1
    }
fi

# Apply patch using bulk API with new format
print_info "Applying patch via bulk API..."
wrapped_payload=$(echo "$bulk_operations" | jq '{operations: .}')
response=$(make_request_json "POST" "/api/bulk" "$wrapped_payload")

# Restore previous context
[ -n "$prev_tenant" ] && switch_tenant "$prev_tenant" >/dev/null 2>&1
[ -n "$prev_server" ] && switch_server "$prev_server" >/dev/null 2>&1

# Check response - new API format returns {"success": true, "data": [...]}
if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
    data=$(echo "$response" | jq '.data')
    
    # Count successes and errors from data array
    total=$(echo "$data" | jq 'length')
    # In new format, each operation result is in the data array
    
    print_success "Patch applied: $total operations completed"
    echo "$data" | jq '.'
else
    print_error "Patch application failed"
    echo "$response" | jq '.'
    exit 1
fi
