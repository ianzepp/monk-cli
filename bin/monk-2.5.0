#!/usr/bin/env bash
# This script was generated by bashly 1.3.1 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
monk_usage() {
  printf "monk - Monk CLI - Command-line interface for PaaS Backend API\n\n"

  printf "%s\n" "Usage:"
  printf "  monk [OPTIONS] COMMAND\n"
  printf "  monk [COMMAND] --help | -h\n"
  printf "  monk --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Initialize configuration directory with required files\n" "init  "
  printf "  %s   Remote server management\n" "server"
  printf "  %s   Tenant registry management\n" "tenant"
  printf "  %s   Authentication and token management\n" "auth  "
  printf "  %s   Data operations on dynamic schemas\n" "data  "
  printf "  %s   Schema and metadata management\n" "meta  "
  printf "  %s   Bulk operations for batch processing across multiple schemas\n" "bulk  "
  printf "  %s   Filesystem-like operations for API data exploration via FTP middleware\n" "fs    "
  printf "  %s   Advanced search with enterprise Filter DSL via JSON input\n" "find  "
  printf "  %s   Administrative operations for tenant management (localhost development only)\n" "root  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Global Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--text"
    printf "    Output in human-readable text format\n"
    echo

    # :flag.usage
    printf "  %s\n" "--json"
    printf "    Output in JSON format\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "CLI_VERBOSE"
    printf "    Enable verbose output for all commands\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "MONK_CLI_CONFIG_DIR"
    printf "    Custom directory for CLI configuration files (default: ~/.config/monk/cli)\n"
    echo

  fi
}

# :command.usage
monk_init_usage() {
  printf "monk init - Initialize configuration directory with required files\n\n"

  printf "%s\n" "Usage:"
  printf "  monk init [PATH] [OPTIONS]\n"
  printf "  monk init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force"
    printf "    Force reinitialization by overwriting existing config files (preserves\n    env.json)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    Custom path for configuration directory (default: ~/.config/monk/cli)\n"
    echo

  fi
}

# :command.usage
monk_server_usage() {
  printf "monk server - Remote server management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server COMMAND\n"
  printf "  monk server [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Register remote server\n" "add     "
  printf "  %s   List all servers with health status\n" "list    "
  printf "  %s   Show currently selected server\n" "current "
  printf "  %s   Switch to server (persistent selection) or show current server\n" "use     "
  printf "  %s   Remove server from registry\n" "delete  "
  printf "  %s   Health check specific server (defaults to current server)\n" "ping    "
  printf "  %s   Health check all registered servers\n" "ping-all"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_add_usage() {
  printf "monk server add - Register remote server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server add NAME ENDPOINT [OPTIONS]\n"
  printf "  monk server add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--description DESCRIPTION"
    printf "    Optional server description\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ENDPOINT"
    printf "    Server endpoint (host:port)\n"
    echo

  fi
}

# :command.usage
monk_server_list_usage() {
  printf "monk server list - List all servers with health status\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server list\n"
  printf "  monk server list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_current_usage() {
  printf "monk server current - Show currently selected server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server current\n"
  printf "  monk server current --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_use_usage() {
  printf "monk server use - Switch to server (persistent selection) or show current server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server use [NAME]\n"
  printf "  monk server use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to switch to (omit to show current server)\n"
    echo

  fi
}

# :command.usage
monk_server_delete_usage() {
  printf "monk server delete - Remove server from registry\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server delete NAME\n"
  printf "  monk server delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to delete\n"
    echo

  fi
}

# :command.usage
monk_server_ping_usage() {
  printf "monk server ping - Health check specific server (defaults to current server)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server ping [NAME]\n"
  printf "  monk server ping --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to ping (optional, defaults to current server)\n"
    echo

  fi
}

# :command.usage
monk_server_ping_all_usage() {
  printf "monk server ping-all - Health check all registered servers\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server ping-all\n"
  printf "  monk server ping-all --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_usage() {
  printf "monk tenant - Tenant registry management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant COMMAND\n"
  printf "  monk tenant [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Register new tenant\n" "add   "
  printf "  %s   List all registered tenants\n" "list  "
  printf "  %s   Remove tenant from registry\n" "delete"
  printf "  %s   Switch to tenant (persistent selection)\n" "use   "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_add_usage() {
  printf "monk tenant add - Register new tenant\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant add NAME DISPLAY_NAME [OPTIONS]\n"
  printf "  monk tenant add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--description DESCRIPTION"
    printf "    Optional tenant description\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant identifier name\n"
    echo

    # :argument.usage
    printf "  %s\n" "DISPLAY_NAME"
    printf "    Human-readable tenant name\n"
    echo

  fi
}

# :command.usage
monk_tenant_list_usage() {
  printf "monk tenant list - List all registered tenants\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant list [OPTIONS]\n"
  printf "  monk tenant list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--server SERVER"
    printf "    Target server (defaults to current server)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_delete_usage() {
  printf "monk tenant delete - Remove tenant from registry\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant delete NAME\n"
  printf "  monk tenant delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name to delete\n"
    echo

  fi
}

# :command.usage
monk_tenant_use_usage() {
  printf "monk tenant use - Switch to tenant (persistent selection)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant use NAME\n"
  printf "  monk tenant use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name to switch to\n"
    echo

  fi
}

# :command.usage
monk_auth_usage() {
  printf "monk auth - Authentication and token management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth COMMAND\n"
  printf "  monk auth [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Authenticate with tenant and username\n" "login  "
  printf "  %s   Clear stored JWT token\n" "logout "
  printf "  %s   Show authentication status\n" "status "
  printf "  %s   Display current JWT token\n" "token  "
  printf "  %s   Decode and display JWT token contents\n" "info   "
  printf "  %s   Authenticated API health check\n" "ping   "
  printf "  %s   Import JWT token from external auth flow\n" "import "
  printf "  %s   Show JWT token expiration time\n" "expires"
  printf "  %s   Check if JWT token is expired (exit code 0=valid, 1=expired)\n" "expired"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_login_usage() {
  printf "monk auth login - Authenticate with tenant and username\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth login TENANT USERNAME\n"
  printf "  monk auth login --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TENANT"
    printf "    Tenant name for authentication\n"
    echo

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    Username for authentication\n"
    echo

  fi
}

# :command.usage
monk_auth_logout_usage() {
  printf "monk auth logout - Clear stored JWT token\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth logout\n"
  printf "  monk auth logout --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_status_usage() {
  printf "monk auth status - Show authentication status\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth status\n"
  printf "  monk auth status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_token_usage() {
  printf "monk auth token - Display current JWT token\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth token\n"
  printf "  monk auth token --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_info_usage() {
  printf "monk auth info - Decode and display JWT token contents\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth info\n"
  printf "  monk auth info --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_ping_usage() {
  printf "monk auth ping - Authenticated API health check\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth ping [OPTIONS]\n"
  printf "  monk auth ping --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Verbose server information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--jwt-token, -j TOKEN"
    printf "    Include JWT token in request\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_import_usage() {
  printf "monk auth import - Import JWT token from external auth flow\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth import TENANT USERNAME [OPTIONS]\n"
  printf "  monk auth import --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--token, -t TOKEN"
    printf "    JWT token to import (or provide via stdin)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TENANT"
    printf "    Tenant name for this JWT token\n"
    echo

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    Username for this JWT token\n"
    echo

  fi
}

# :command.usage
monk_auth_expires_usage() {
  printf "monk auth expires - Show JWT token expiration time\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth expires\n"
  printf "  monk auth expires --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_expired_usage() {
  printf "monk auth expired - Check if JWT token is expired (exit code 0=valid, 1=expired)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth expired\n"
  printf "  monk auth expired --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_data_usage() {
  printf "monk data - Data operations on dynamic schemas\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data COMMAND\n"
  printf "  monk data [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Select record(s) with flexible query support\n" "select"
  printf "  %s   Create record from stdin\n" "create"
  printf "  %s   Update record(s) from stdin\n" "update"
  printf "  %s   Delete record(s)\n" "delete"
  printf "  %s   Export records to JSON files\n" "export"
  printf "  %s   Import JSON files as records\n" "import"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_data_select_usage() {
  printf "monk data select - Select record(s) with flexible query support\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data select SCHEMA [ID] [OPTIONS]\n"
  printf "  monk data select --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--filter JSON"
    printf "    JSON filter for query parameters (limit, offset, order)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to retrieve (optional)\n"
    echo

  fi
}

# :command.usage
monk_data_create_usage() {
  printf "monk data create - Create record from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data create SCHEMA\n"
  printf "  monk data create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to create record in\n"
    echo

  fi
}

# :command.usage
monk_data_update_usage() {
  printf "monk data update - Update record(s) from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data update SCHEMA [ID]\n"
  printf "  monk data update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to update (optional if ID in JSON)\n"
    echo

  fi
}

# :command.usage
monk_data_delete_usage() {
  printf "monk data delete - Delete record(s)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data delete SCHEMA [ID]\n"
  printf "  monk data delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to delete (optional if ID in JSON or using stdin)\n"
    echo

  fi
}

# :command.usage
monk_data_export_usage() {
  printf "monk data export - Export records to JSON files\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data export SCHEMA DIR\n"
  printf "  monk data export --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to export\n"
    echo

    # :argument.usage
    printf "  %s\n" "DIR"
    printf "    Directory to export to\n"
    echo

  fi
}

# :command.usage
monk_data_import_usage() {
  printf "monk data import - Import JSON files as records\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data import SCHEMA DIR\n"
  printf "  monk data import --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to import into\n"
    echo

    # :argument.usage
    printf "  %s\n" "DIR"
    printf "    Directory to import from\n"
    echo

  fi
}

# :command.usage
monk_meta_usage() {
  printf "monk meta - Schema and metadata management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta COMMAND\n"
  printf "  monk meta [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Select specific schema\n" "select"
  printf "  %s   Create schema from stdin (YAML/JSON)\n" "create"
  printf "  %s   Update schema from stdin\n" "update"
  printf "  %s   Delete schema\n" "delete"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_meta_select_usage() {
  printf "monk meta select - Select specific schema\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta select TYPE NAME\n"
  printf "  monk meta select --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to select\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Schema name to retrieve\n"
    echo

  fi
}

# :command.usage
monk_meta_create_usage() {
  printf "monk meta create - Create schema from stdin (YAML/JSON)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta create TYPE\n"
  printf "  monk meta create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to create\n"
    echo

  fi
}

# :command.usage
monk_meta_update_usage() {
  printf "monk meta update - Update schema from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta update TYPE NAME\n"
  printf "  monk meta update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to update\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Schema name to update\n"
    echo

  fi
}

# :command.usage
monk_meta_delete_usage() {
  printf "monk meta delete - Delete schema\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta delete TYPE NAME\n"
  printf "  monk meta delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to delete\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Schema name to delete\n"
    echo

  fi
}

# :command.usage
monk_bulk_usage() {
  printf "monk bulk - Bulk operations for batch processing across multiple schemas\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk COMMAND\n"
  printf "  monk bulk [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Execute bulk operations immediately (synchronous)\n" "raw   "
  printf "  %s   Submit bulk operations for async processing (future feature)\n" "submit"
  printf "  %s   Check status of async bulk operation (future feature)\n" "status"
  printf "  %s   Download results of completed bulk operation (future feature)\n" "result"
  printf "  %s   Cancel pending bulk operation (future feature)\n" "cancel"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_bulk_raw_usage() {
  printf "monk bulk raw - Execute bulk operations immediately (synchronous)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk raw\n"
  printf "  monk bulk raw --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_bulk_submit_usage() {
  printf "monk bulk submit - Submit bulk operations for async processing (future feature)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk submit\n"
  printf "  monk bulk submit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_bulk_status_usage() {
  printf "monk bulk status - Check status of async bulk operation (future feature)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk status OPERATION_ID\n"
  printf "  monk bulk status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "OPERATION_ID"
    printf "    Bulk operation ID from submit command\n"
    echo

  fi
}

# :command.usage
monk_bulk_result_usage() {
  printf "monk bulk result - Download results of completed bulk operation (future feature)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk result OPERATION_ID\n"
  printf "  monk bulk result --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "OPERATION_ID"
    printf "    Bulk operation ID from submit command\n"
    echo

  fi
}

# :command.usage
monk_bulk_cancel_usage() {
  printf "monk bulk cancel - Cancel pending bulk operation (future feature)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk cancel OPERATION_ID\n"
  printf "  monk bulk cancel --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "OPERATION_ID"
    printf "    Bulk operation ID to cancel\n"
    echo

  fi
}

# :command.usage
monk_fs_usage() {
  printf "monk fs - Filesystem-like operations for API data exploration via FTP middleware\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs COMMAND\n"
  printf "  monk fs [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List directory contents with wildcard support\n" "ls  "
  printf "  %s   Display file content or record data\n" "cat "
  printf "  %s   Remove files, records, or fields\n" "rm  "
  printf "  %s   Display detailed file/directory status and schema information\n" "stat"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_fs_ls_usage() {
  printf "monk fs ls - List directory contents with wildcard support\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs ls PATH [OPTIONS]\n"
  printf "  monk fs ls --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--long, -l"
    printf "    Use long listing format with detailed information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    FTP path (e.g., /data/users/, /tenant/tenant-a/data/users/)\n"
    echo

  fi
}

# :command.usage
monk_fs_cat_usage() {
  printf "monk fs cat - Display file content or record data\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs cat PATH [OPTIONS]\n"
  printf "  monk fs cat --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    FTP path to file or record (e.g., /data/users/user-123.json,\n    /tenant/tenant-a/data/users/user-123.json)\n"
    echo

  fi
}

# :command.usage
monk_fs_rm_usage() {
  printf "monk fs rm - Remove files, records, or fields\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs rm PATH [OPTIONS]\n"
  printf "  monk fs rm --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Force permanent deletion (default is soft delete)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    FTP path to delete (e.g., /data/users/user-123,\n    /tenant/tenant-a/data/users/user-123)\n"
    echo

  fi
}

# :command.usage
monk_fs_stat_usage() {
  printf "monk fs stat - Display detailed file/directory status and schema information\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs stat PATH [OPTIONS]\n"
  printf "  monk fs stat --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    FTP path for status information (e.g., /data/users/,\n    /tenant/tenant-a/meta/schema/)\n"
    echo

  fi
}

# :command.usage
monk_find_usage() {
  printf "monk find - Advanced search with enterprise Filter DSL via JSON input\n\n"

  printf "%s\n" "Usage:"
  printf "  monk find SCHEMA [OPTIONS]\n"
  printf "  monk find --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--head, -H"
    printf "    Return only first record from results\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tail, -T"
    printf "    Return only last record from results\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema to search\n"
    echo

  fi
}

# :command.usage
monk_root_usage() {
  printf "monk root - Administrative operations for tenant management (localhost development only)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root COMMAND\n"
  printf "  monk root [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Tenant management operations\n" "tenant"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_usage() {
  printf "monk root tenant - Tenant management operations\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root tenant COMMAND\n"
  printf "  monk root tenant [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all tenants\n" "list   "
  printf "  %s   Create new tenant\n" "create "
  printf "  %s   Show tenant details\n" "show   "
  printf "  %s   Soft delete tenant (set trashed_at)\n" "trash  "
  printf "  %s   Restore soft deleted tenant\n" "restore"
  printf "  %s   Hard delete tenant (permanent)\n" "delete "
  printf "  %s   Check tenant database health\n" "health "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_list_usage() {
  printf "monk root tenant list - List all tenants\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk root tenant list [OPTIONS]\n"
  printf "  monk root tenant list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--include-trashed"
    printf "    Include soft-deleted tenants\n"
    echo

    # :flag.usage
    printf "  %s\n" "--include-deleted"
    printf "    Include hard-deleted tenants\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_create_usage() {
  printf "monk root tenant create - Create new tenant\n\n"
  printf "Alias: add\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk root tenant create NAME [OPTIONS]\n"
  printf "  monk root tenant create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--host HOSTNAME"
    printf "    Database host (default: localhost)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force"
    printf "    Force creation even if exists\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_show_usage() {
  printf "monk root tenant show - Show tenant details\n\n"
  printf "Alias: info\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk root tenant show NAME\n"
  printf "  monk root tenant show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_trash_usage() {
  printf "monk root tenant trash - Soft delete tenant (set trashed_at)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root tenant trash NAME\n"
  printf "  monk root tenant trash --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_restore_usage() {
  printf "monk root tenant restore - Restore soft deleted tenant\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root tenant restore NAME\n"
  printf "  monk root tenant restore --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_delete_usage() {
  printf "monk root tenant delete - Hard delete tenant (permanent)\n\n"
  printf "Alias: purge\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk root tenant delete NAME [OPTIONS]\n"
  printf "  monk root tenant delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force"
    printf "    Skip confirmation\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_health_usage() {
  printf "monk root tenant health - Check tenant database health\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root tenant health NAME\n"
  printf "  monk root tenant health --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/common.sh
#!/bin/bash

# Common functions for bashly CLI commands
# Clean rewrite to eliminate syntax errors and improve maintainability

# Clean separation of concerns:
# - server.json: Infrastructure endpoints

# - auth.json: Authentication sessions per server+tenant
# - env.json: Current working context (server+tenant selection)

# CLI configuration files

CLI_CONFIG_DIR="${MONK_CLI_CONFIG_DIR:-${HOME}/.config/monk/cli}"
SERVER_CONFIG="${CLI_CONFIG_DIR}/server.json"
TENANT_CONFIG="${CLI_CONFIG_DIR}/tenant.json"
AUTH_CONFIG="${CLI_CONFIG_DIR}/auth.json"
ENV_CONFIG="${CLI_CONFIG_DIR}/env.json"

# Legacy config file (for migration)
LEGACY_SERVERS_CONFIG="${HOME}/.config/monk/servers.json"

# Default configuration
DEFAULT_BASE_URL="http://localhost:3000"
DEFAULT_LIMIT=50
DEFAULT_FORMAT="raw"

# Colors for output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output - all go to stderr to avoid interfering with data pipes
print_error() {
    echo -e "${RED}✗ $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}" >&2
}

print_info() {
    # Only print if CLI_VERBOSE is true
    if [ "$CLI_VERBOSE" = "true" ]; then
        echo -e "${YELLOW}ℹ $1${NC}" >&2
    fi
}

print_info_always() {
    # Always print info messages (ignores CLI_VERBOSE)
    echo -e "${YELLOW}ℹ $1${NC}" >&2
}

print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}" >&2
}

# Initialize CLI config directory and files
init_cli_configs() {
    # Ensure CLI config directory exists
    mkdir -p "$CLI_CONFIG_DIR"

    # Initialize individual config files
    init_server_config
    init_tenant_config
    init_auth_config

    init_env_config
}

# Initialize server config if it doesn't exist
init_server_config() {
    if [ ! -f "$SERVER_CONFIG" ]; then
        mkdir -p "$(dirname "$SERVER_CONFIG")"
        cat > "$SERVER_CONFIG" << 'EOF'
{
  "servers": {}
}
EOF
    fi
}

# Initialize tenant config if it doesn't exist
init_tenant_config() {
    if [ ! -f "$TENANT_CONFIG" ]; then
        mkdir -p "$(dirname "$TENANT_CONFIG")"
        cat > "$TENANT_CONFIG" << 'EOF'
{
  "tenants": {}
}
EOF
    fi
}

# Initialize auth config if it doesn't exist

init_auth_config() {
    if [ ! -f "$AUTH_CONFIG" ]; then
        mkdir -p "$(dirname "$AUTH_CONFIG")"
        cat > "$AUTH_CONFIG" << 'EOF'
{
  "sessions": {}
}
EOF
    fi
}

# Initialize env config if it doesn't exist
init_env_config() {
    if [ ! -f "$ENV_CONFIG" ]; then
        mkdir -p "$(dirname "$ENV_CONFIG")"
        cat > "$ENV_CONFIG" << 'EOF'
{
  "current_server": null,
  "current_tenant": null,
  "current_user": null,
  "recents": []
}
EOF
    fi
}

# Migrate from legacy servers.json to new CLI config structure
migrate_legacy_config() {
    # Only migrate if legacy file exists and new structure doesn't
    if [[ -f "$LEGACY_SERVERS_CONFIG" && ! -f "$SERVER_CONFIG" ]]; then
        print_info "Migrating legacy configuration to new CLI structure..."

        # Ensure new config directory exists
        mkdir -p "$CLI_CONFIG_DIR"

        # Extract server info and current server from legacy config
        local servers_data current_server
        servers_data=$(jq '.servers' "$LEGACY_SERVERS_CONFIG" 2>/dev/null)
        current_server=$(jq -r '.current_server // empty' "$LEGACY_SERVERS_CONFIG" 2>/dev/null)

        # Create new server.json (infrastructure only)
        echo "{\"servers\": $servers_data}" > "$SERVER_CONFIG"

        # Create env.json with current server selection
        cat > "$ENV_CONFIG" << EOF
{
  "current_server": "$current_server",
  "current_tenant": null,
  "current_user": null,
  "recents": []
}
EOF

        # Create empty auth.json (tokens will be re-established)
        cat > "$AUTH_CONFIG" << 'EOF'
{
  "sessions": {}
}
EOF

        print_success "Configuration migrated to ~/.config/monk/cli/"
        print_warning "JWT tokens were not migrated - please re-authenticate with 'monk auth login'"
    fi
}

# Get base URL from server config - fail if not configured
get_base_url() {
    migrate_legacy_config

    # Check if jq is available
    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for server configuration" >&2
        echo "Install jq to use server configuration" >&2
        exit 1
    fi

    # Check if config file exists
    if [[ ! -f "$SERVER_CONFIG" ]]; then
        echo "Error: No server configuration found" >&2
        echo "Use 'monk server add <name> <hostname:port>' to add a server" >&2
        exit 1
    fi

    # Get current server from env config
    init_env_config
    local current_server
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

    if [[ -z "$current_server" || "$current_server" == "null" ]]; then
        echo "Error: No current server selected" >&2
        echo "Use 'monk server use <name>' to select a server" >&2
        exit 1
    fi

    # Get server info from server config
    local server_info
    server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)

    if [[ "$server_info" == "null" ]]; then
        echo "Error: Current server '$current_server' not found in configuration" >&2
        echo "Use 'monk server list' to see available servers" >&2
        exit 1
    fi

    # Extract connection details
    local hostname=$(echo "$server_info" | jq -r '.hostname')
    local port=$(echo "$server_info" | jq -r '.port')
    local protocol=$(echo "$server_info" | jq -r '.protocol')

    # Validate required fields
    if [[ "$hostname" == "null" || "$port" == "null" || "$protocol" == "null" ]]; then
        echo "Error: Invalid server configuration for '$current_server'" >&2
        echo "Server configuration is missing required fields (hostname, port, protocol)" >&2
        exit 1
    fi

    echo "$protocol://$hostname:$port"
}

# Get stored JWT token for current server+tenant context
get_jwt_token() {
    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for JWT token management" >&2
        return 1
    fi

    # Get current context
    local current_server current_tenant
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        # No current server selected
        return 1
    fi

    if [ -z "$current_tenant" ] || [ "$current_tenant" = "null" ]; then
        # No current tenant selected
        return 1
    fi

    # Get session-specific token using server:tenant key
    local session_key="${current_server}:${current_tenant}"
    local token
    token=$(jq -r ".sessions.\"$session_key\".jwt_token // empty" "$AUTH_CONFIG" 2>/dev/null)

    if [ -n "$token" ] && [ "$token" != "null" ]; then
        echo "$token"
    else
        return 1
    fi
}

# Store JWT token for current server+tenant context
store_token() {
    local token="$1"
    local tenant="$2"
    local user="$3"

    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for JWT token management" >&2
        return 1
    fi

    # Get current server from env config
    local current_server
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        echo "Error: No current server selected. Use 'monk server use <name>' first" >&2
        return 1
    fi

    # Update env config with current tenant and user
    local temp_file=$(mktemp)
    jq --arg tenant "$tenant" \
       --arg user "$user" \
       '.current_tenant = $tenant | .current_user = $user' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

    # Store token in auth config using server:tenant key
    local session_key="${current_server}:${tenant}"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    temp_file=$(mktemp)
    jq --arg session_key "$session_key" \
       --arg token "$token" \
       --arg tenant "$tenant" \
       --arg user "$user" \
       --arg server "$current_server" \
       --arg timestamp "$timestamp" \
       '.sessions[$session_key] = {
           "jwt_token": $token,
           "tenant": $tenant,
           "user": $user,

           "server": $server,
           "created_at": $timestamp
       }' "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"

    # Set secure permissions on auth file
    chmod 600 "$AUTH_CONFIG"
}

# Remove stored JWT token for current server+tenant context
remove_stored_token() {
    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for JWT token management" >&2
        return 1
    fi

    # Get current context
    local current_server current_tenant
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        echo "Error: No current server selected" >&2
        return 1
    fi

    if [ -z "$current_tenant" ] || [ "$current_tenant" = "null" ]; then
        # Clear all tenant info from env
        local temp_file=$(mktemp)
        jq '.current_tenant = null | .current_user = null' \
           "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
        return 0
    fi

    # Remove session from auth config
    local session_key="${current_server}:${current_tenant}"
    local temp_file=$(mktemp)
    jq --arg session_key "$session_key" \
       'del(.sessions[$session_key])' \
       "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"

    # Clear current tenant from env config
    temp_file=$(mktemp)
    jq '.current_tenant = null | .current_user = null' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
}

# Make HTTP request with JSON content-type - programmatic by default
make_request_json() {
    local method="$1"
    local url="$2"
    local data="$3"
    local base_url=$(get_base_url)
    local full_url="${base_url}${url}"

    print_info "Making $method request to: $full_url"

    local curl_args=(-s -X "$method" -H "Content-Type: application/json")

    # Add JWT token if available (unless it's an auth request)
    if [[ "$url" != "/auth/"* ]]; then
        local jwt_token
        jwt_token=$(get_jwt_token)
        if [ -n "$jwt_token" ]; then
            curl_args+=(-H "Authorization: Bearer $jwt_token")
            print_info "Using stored JWT token"
        fi
    fi

    if [ -n "$data" ]; then
        curl_args+=(-d "$data")
    fi

    local response
    local http_code

    # Make request and capture both response and HTTP status code
    response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Handle HTTP errors
    case "$http_code" in
        200|201)
            print_success "Success ($http_code)"
            # Return response without formatting - let caller handle it
            echo "$response"
            return 0
            ;;
        400|404|500)
            print_error "HTTP Error ($http_code)"
            echo "$response" >&2
            exit 1
            ;;
        *)
            print_error "HTTP $http_code"
            echo "$response" >&2
            exit 1
            ;;
    esac
}

# Handle response based on CLI flags - optimized for testing
handle_response_json() {
    local response="$1"
    local operation_type="$2"  # "list", "create", "select", etc.

    # Exit code only mode - no output, just exit status
    if [ "$CLI_EXIT_CODE_ONLY" = "true" ]; then
        if echo "$response" | grep -q '"success":true'; then
            exit 0
        else
            exit 1
        fi
    fi

    # Count mode for list operations
    if [ "$CLI_COUNT_MODE" = "true" ] && [ "$operation_type" = "list" ]; then
        if [ "$JSON_PARSER" = "jq" ]; then
            echo "$response" | jq '.data | length' 2>/dev/null || echo "0"
        elif [ "$JSON_PARSER" = "jshon" ]; then
            echo "$response" | jshon -e data -l 2>/dev/null || echo "0"
        else
            echo "$response"
        fi
        return
    fi

    # Field extraction mode
    if [ -n "$CLI_FORMAT" ]; then
        if [ "$JSON_PARSER" = "jq" ]; then
            # Handle both single objects and arrays
            if echo "$response" | jq -e '.data | type == "array"' >/dev/null 2>&1; then
                # Array case - extract field from each item
                echo "$response" | jq -r ".data[].${CLI_FORMAT}" 2>/dev/null || {
                    print_error "Failed to extract field: $CLI_FORMAT"
                    exit 1
                }
            else
                # Single object case - extract field directly
                echo "$response" | jq -r ".data.${CLI_FORMAT}" 2>/dev/null || {
                    print_error "Failed to extract field: $CLI_FORMAT"
                    exit 1
                }
            fi
        elif [ "$JSON_PARSER" = "jshon" ]; then
            echo "$response" | jshon -e data -e "$CLI_FORMAT" -u 2>/dev/null || {
                print_error "Failed to extract field: $CLI_FORMAT"
                exit 1
            }
        else
            print_error "jq or jshon required for field extraction"
            exit 1
        fi
        return
    fi

    # Default: auto-extract 'data' property and output as compact JSON
    if [ "$JSON_PARSER" = "jq" ]; then
        # Check if response has success:true and extract data
        if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
            if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
                # Success response - extract data as compact JSON
                echo "$response" | jq -c '.data'
            else
                # Error response - show full response for debugging as compact JSON
                echo "$response" | jq -c '.'
            fi
        else
            # Not a standard API response - show raw as compact JSON
            echo "$response" | jq -c '.'
        fi
    elif [ "$JSON_PARSER" = "jshon" ]; then
        # Check if response has success:true and extract data
        if echo "$response" | jshon -e success -u 2>/dev/null | grep -q "true"; then
            echo "$response" | jshon -e data 2>/dev/null || echo "$response"
        else
            echo "$response"
        fi
    else
        # No JSON parser - raw output
        echo "$response"
    fi
}

# Validate required arguments
require_args() {
    local required_count="$1"
    local actual_count="$2"
    local usage="$3"

    if [ "$actual_count" -lt "$required_count" ]; then
        print_error "Missing required arguments"
        print_info "Usage: $usage"
        exit 1
    fi
}

# Check dependencies - keep it simple
check_dependencies() {
    if ! command -v curl &> /dev/null; then
        print_error "curl is required but not installed."
        exit 1
    fi

    # Check for JSON parser for extraction operations (prefer jq over jshon)
    if command -v jq &> /dev/null; then
        export JSON_PARSER="jq"
    elif command -v jshon &> /dev/null; then
        export JSON_PARSER="jshon"
    else
        export JSON_PARSER="none"
    fi
}

# Legacy function - kept for compatibility
init_servers_config() {
    # Redirect to new CLI config initialization
    init_cli_configs
}

# Parse hostname:port into components
parse_endpoint() {
    local endpoint="$1"
    local hostname=""
    local port=""
    local protocol=""

    # Handle protocol prefixes
    if echo "$endpoint" | grep -q "^https://"; then
        protocol="https"
        endpoint=$(echo "$endpoint" | sed 's|^https://||')
    elif echo "$endpoint" | grep -q "^http://"; then
        protocol="http"
        endpoint=$(echo "$endpoint" | sed 's|^http://||')
    fi

    # Parse hostname:port
    if echo "$endpoint" | grep -q ":"; then
        hostname=$(echo "$endpoint" | cut -d':' -f1)
        port=$(echo "$endpoint" | cut -d':' -f2)
    else
        hostname="$endpoint"
        port="80"
    fi

    # Auto-detect protocol if not specified
    if [ -z "$protocol" ]; then
        if [ "$port" = "443" ]; then
            protocol="https"
        else
            protocol="http"
        fi
    fi

    echo "$protocol|$hostname|$port"
}

# Health check a server URL
ping_server_url() {
    local base_url="$1"
    local timeout="${2:-5}"

    # Try to ping the /ping endpoint with a short timeout
    if curl -s --max-time "$timeout" --fail "$base_url/ping" >/dev/null 2>&1; then
        return 0
    elif curl -s --max-time "$timeout" --fail "$base_url/" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Initialize tenant database schema
init_tenant_schema() {
    local tenant_name="$1"
    local db_user="${2:-$(whoami)}"

    # Find the schema file relative to the CLI root
    local schema_file=""

    # Try different possible locations for the schema file
    if [ -f "../sql/init-tenant.sql" ]; then
        schema_file="../sql/init-tenant.sql"
    elif [ -f "../../sql/init-tenant.sql" ]; then
        schema_file="../../sql/init-tenant.sql"
    elif [ -f "sql/init-tenant.sql" ]; then
        schema_file="sql/init-tenant.sql"
    else
        print_error "Schema file not found: init-tenant.sql"
        return 1
    fi

    print_info "Initializing tenant database schema..."
    if psql -U "$db_user" -d "$tenant_name" -f "$schema_file" >/dev/null 2>&1; then
        print_success "Tenant database schema initialized"
        return 0
    else
        print_error "Failed to initialize tenant database schema"
        return 1
    fi
}

# Make HTTP request with YAML content-type for meta API
make_request_yaml() {
    local method="$1"
    local url="$2"
    local data="$3"
    local base_url=$(get_base_url)
    local full_url="${base_url}${url}"

    print_info "Making $method request to: $full_url with YAML content-type"

    local curl_args=(-s -X "$method" -H "Content-Type: text/yaml")

    # Add JWT token if available (unless it's an auth request)
    if [[ "$url" != "/auth/"* ]]; then
        local jwt_token
        jwt_token=$(get_jwt_token)
        if [ -n "$jwt_token" ]; then
            curl_args+=(-H "Authorization: Bearer $jwt_token")
            print_info "Using stored JWT token"
        fi
    fi

    if [ -n "$data" ]; then
        curl_args+=(-d "$data")
    fi

    local response
    local http_code

    # Make request and capture both response and HTTP status code
    response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Handle HTTP errors
    case "$http_code" in
        200|201|204)
            print_success "Success ($http_code)"
            # Return response directly (YAML format)
            echo "$response"
            return 0
            ;;
        400|404|500)
            print_error "HTTP Error ($http_code)"
            echo "$response" >&2
            exit 1
            ;;
        *)
            print_error "HTTP $http_code"
            echo "$response" >&2
            exit 1
            ;;
    esac
}

# Handle YAML response - much simpler than JSON
handle_response_yaml() {
    local response="$1"
    local operation_type="$2"  # "create", "select", "update", "delete"

    # Exit code only mode - check if response is not empty for success
    if [ "$CLI_EXIT_CODE_ONLY" = "true" ]; then
        if [ -n "$response" ] || [ "$operation_type" = "delete" ]; then
            exit 0
        else
            exit 1
        fi
    fi

    # For YAML responses, just output directly
    echo "$response"
}

# Detect if input is array or object
detect_input_type() {
    local input="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        if echo "$input" | jq -e 'type == "array"' >/dev/null 2>&1; then
            echo "array"
        else
            echo "object"
        fi
    else
        # Fallback detection - check first non-whitespace character
        first_char=$(echo "$input" | sed 's/^[[:space:]]*//' | cut -c1)
        if [ "$first_char" = "[" ]; then
            echo "array"
        else
            echo "object"
        fi
    fi
}

# Extract ID from object
extract_id_from_object() {
    local input="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        echo "$input" | jq -r '.id // empty'
    elif [ "$JSON_PARSER" = "jshon" ]; then
        echo "$input" | jshon -e id -u 2>/dev/null || echo ""
    else
        # Fallback extraction
        echo "$input" | grep -o '"id"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | head -1
    fi
}

# Remove ID from object (for update operations)
remove_id_from_object() {
    local input="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        echo "$input" | jq 'del(.id)'
    elif [ "$JSON_PARSER" = "jshon" ]; then
        echo "$input" | jshon -d id 2>/dev/null || echo "$input"
    else
        # Fallback - remove id field (basic regex)
        echo "$input" | sed 's/"id"[[:space:]]*:[[:space:]]*"[^"]*"[[:space:]]*,\?//g' | sed 's/,[[:space:]]*}/}/g'
    fi
}

# Read and validate JSON input from stdin
read_and_validate_json_input() {
    local operation="$1"
    local schema="$2"

    # Read JSON data from stdin
    local json_data
    json_data=$(cat)

    if [ -z "$json_data" ]; then
        print_error "No JSON data provided on stdin"
        exit 1
    fi

    print_info "${operation^} $schema record(s) with data:"
    if [ "$CLI_VERBOSE" = "true" ]; then
        echo "$json_data" | sed 's/^/  /' >&2
    fi

    echo "$json_data"
}

# Process data operations with flexible input handling
process_data_operation() {
    local operation="$1"      # create/update/delete
    local http_method="$2"    # POST/PUT/DELETE
    local schema="$3"
    local id="$4"            # optional
    local json_data="$5"
    local confirmation="${6:-false}"  # require confirmation for destructive ops

    # Special case: DELETE with ID but no JSON data
    if [ "$operation" = "delete" ] && [ -n "$id" ] && [ -z "$json_data" ]; then
        if [ "$confirmation" = "true" ] && [ "$CLI_VERBOSE" = "true" ]; then
            print_warning "Are you sure you want to delete $schema record: $id? (y/N)"
            read -r user_confirmation

            if ! echo "$user_confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
                print_info "Operation cancelled"
                exit 0
            fi
        fi

        response=$(make_request_json "$http_method" "/api/data/$schema/$id" "")
        handle_response_json "$response" "$operation"
        return
    fi

    # All other cases require JSON data
    if [ -z "$json_data" ]; then
        print_error "No JSON data provided"
        exit 1
    fi

    # Detect input type and handle accordingly
    input_type=$(detect_input_type "$json_data")

    if [ -n "$id" ]; then
        # ID provided as parameter - use object endpoint
        print_info "Using provided ID: $id"

        # For object endpoint, remove ID from payload if present (API doesn't expect it)
        local clean_data
        if [ "$operation" = "update" ]; then
            clean_data=$(remove_id_from_object "$json_data")
        else
            clean_data="$json_data"
        fi

        response=$(make_request_json "$http_method" "/api/data/$schema/$id" "$clean_data")
        handle_response_json "$response" "$operation"

    elif [ "$input_type" = "array" ]; then
        # Array input → Bulk operation via array endpoint
        print_info "Processing array input for bulk $operation"
        response=$(make_request_json "$http_method" "/api/data/$schema" "$json_data")
        handle_response_json "$response" "$operation"

    elif [ "$operation" = "create" ]; then
        # CREATE: Object input → Array API → Object output (unwrap)
        print_info "Processing single object input"
        array_data="[$json_data]"
        response=$(make_request_json "$http_method" "/api/data/$schema" "$array_data")

        # Extract single object from array response to match input format
        if [ "$JSON_PARSER" = "jq" ]; then
            single_response=$(echo "$response" | jq '{"success": .success, "data": .data[0], "error": .error, "error_code": .error_code}' 2>/dev/null || echo "$response")
            handle_response_json "$single_response" "$operation"
        else
            handle_response_json "$response" "$operation"
        fi

    else
        # UPDATE/DELETE: Object input, no ID param → Extract ID from object, use object endpoint
        extracted_id=$(extract_id_from_object "$json_data")

        if [ -z "$extracted_id" ] || [ "$extracted_id" = "null" ]; then
            print_error "No ID provided as parameter and no 'id' field found in JSON object"
            print_info "Usage: monk data $operation $schema <id> OR provide JSON with 'id' field"
            exit 1
        fi

        print_info "Extracted ID from object: $extracted_id"

        # Confirmation for extracted ID delete operations
        if [ "$operation" = "delete" ] && [ "$confirmation" = "true" ] && [ "$CLI_VERBOSE" = "true" ]; then
            print_warning "Are you sure you want to delete $schema record: $extracted_id? (y/N)"
            read -r user_confirmation

            if ! echo "$user_confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
                print_info "Operation cancelled"
                exit 0
            fi
        fi

        # Remove ID from payload for object endpoint (UPDATE only)
        local clean_data
        if [ "$operation" = "update" ]; then
            clean_data=$(remove_id_from_object "$json_data")
        else
            clean_data=""  # DELETE doesn't need payload
        fi

        response=$(make_request_json "$http_method" "/api/data/$schema/$extracted_id" "$clean_data")
        handle_response_json "$response" "$operation"
    fi
}

# Check if JSON has complex where clause (indicating need for find command)
has_complex_query() {
    local json_data="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        # Check if 'where' field exists
        echo "$json_data" | jq -e '.where' >/dev/null 2>&1
    elif [ "$JSON_PARSER" = "jshon" ]; then
        echo "$json_data" | jshon -e where >/dev/null 2>&1
    else
        # Fallback: basic grep for "where" key
        echo "$json_data" | grep -q '"where"[[:space:]]*:'
    fi
}

# Build query string from JSON parameters (excluding 'where')
build_query_string() {
    local json_data="$1"
    local query_params=""

    if [ "$JSON_PARSER" = "jq" ]; then
        # Extract all keys except 'where' and build query string
        local keys
        keys=$(echo "$json_data" | jq -r 'del(.where) | to_entries[] | "\(.key)=\(.value)"' 2>/dev/null)

        if [ -n "$keys" ]; then
            # URL encode and join with &
            query_params=$(echo "$keys" | sed 's/ /+/g' | tr '\n' '&' | sed 's/&$//')
        fi
    elif [ "$JSON_PARSER" = "jshon" ]; then
        # Basic jshon parsing (limited functionality)
        local limit offset order
        limit=$(echo "$json_data" | jshon -e limit -u 2>/dev/null || echo "")
        offset=$(echo "$json_data" | jshon -e offset -u 2>/dev/null || echo "")
        order=$(echo "$json_data" | jshon -e order -u 2>/dev/null || echo "")

        local params=""
        [ -n "$limit" ] && params="${params}limit=${limit}&"
        [ -n "$offset" ] && params="${params}offset=${offset}&"
        [ -n "$order" ] && params="${params}order=$(echo "$order" | sed 's/ /+/g')&"

        query_params="${params%&}"  # Remove trailing &
    else
        # Fallback: basic regex extraction for common parameters
        local limit offset order
        limit=$(echo "$json_data" | grep -o '"limit"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*//')
        offset=$(echo "$json_data" | grep -o '"offset"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*//')
        order=$(echo "$json_data" | grep -o '"order"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*:[[:space:]]*"\([^"]*\)".*/\1/' | sed 's/ /+/g')

        local params=""
        [ -n "$limit" ] && params="${params}limit=${limit}&"
        [ -n "$offset" ] && params="${params}offset=${offset}&"
        [ -n "$order" ] && params="${params}order=${order}&"

        query_params="${params%&}"  # Remove trailing &
    fi

    if [ -n "$query_params" ]; then
        echo "?${query_params}"
    fi
}

# Redirect to find command with JSON input
redirect_to_find() {
    local schema="$1"
    local json_data="$2"

    print_info "Complex query detected, redirecting to 'monk find $schema'"

    # Execute find command with the JSON data
    echo "$json_data" | "${BASH_SOURCE[0]%/*}/find_command.sh" "$schema"
}

# Build FTP request payload with path and options
build_ftp_payload() {
    local path="$1"
    local options="$2"

    if [ -n "$options" ]; then
        jq -n --arg path "$path" --argjson options "$options" \
           '{"path": $path, "ftp_options": $options}'
    else
        jq -n --arg path "$path" '{"path": $path}'
    fi
}

# Process FTP response and extract specific field
process_ftp_response() {
    local response="$1"
    local extract_field="$2"  # "content", "data", etc. (optional)

    if [ "$JSON_PARSER" = "jq" ]; then
        if [ -n "$extract_field" ]; then
            echo "$response" | jq ".$extract_field" 2>/dev/null
        else
            echo "$response"
        fi
    else
        print_error "jq required for FTP operations"
        exit 1
    fi
}

# Make FTP request with standard error handling
make_ftp_request() {
    local endpoint="$1"    # list, stat, retrieve, delete
    local payload="$2"

    local response
    response=$(make_request_json "POST" "/ftp/$endpoint" "$payload")

    # Check for FTP-specific error handling if needed
    echo "$response"
}

# Format ls-style output from FTP list entries
format_ls_output() {
    local entries="$1"
    local long_format="${2:-false}"

    echo "$entries" | jq -r '.[] | .name'
}

# Parse tenant path and extract routing information
parse_tenant_path() {
    local path="$1"

    if [[ "$path" =~ ^/tenant/([^/]+)/(.*) ]]; then
        local tenant_spec="${BASH_REMATCH[1]}"
        local api_path="/${BASH_REMATCH[2]}"

        # Parse tenant specification (server:tenant or just tenant)
        if [[ "$tenant_spec" =~ ^([^:]+):(.+)$ ]]; then
            # Full server:tenant specification
            echo "server=${BASH_REMATCH[1]};tenant=${BASH_REMATCH[2]};path=$api_path;tenant_routing=true"
        else
            # Tenant only, use current server
            echo "server=current;tenant=$tenant_spec;path=$api_path;tenant_routing=true"
        fi
    else
        # Standard path, use current session
        echo "server=current;tenant=current;path=$path;tenant_routing=false"
    fi
}

# Get current session key (server:tenant)
current_session_key() {
    local current_server current_tenant
    current_server=$(jq -r '.current_server' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant' "$ENV_CONFIG" 2>/dev/null)

    if [ -n "$current_server" ] && [ "$current_server" != "null" ] &&

       [ -n "$current_tenant" ] && [ "$current_tenant" != "null" ]; then
        echo "${current_server}:${current_tenant}"
    else
        return 1
    fi
}

# Resolve session key from server and tenant specifications
resolve_session() {
    local server="$1"
    local tenant="$2"

    # Handle "current" values
    if [ "$server" = "current" ]; then
        server=$(jq -r '.current_server' "$ENV_CONFIG" 2>/dev/null)
    fi
    if [ "$tenant" = "current" ]; then
        tenant=$(jq -r '.current_tenant' "$ENV_CONFIG" 2>/dev/null)
    fi

    # Validate inputs
    if [ -z "$server" ] || [ "$server" = "null" ]; then
        print_error "No server specified and no current server selected"
        return 1
    fi
    if [ -z "$tenant" ] || [ "$tenant" = "null" ]; then
        print_error "No tenant specified and no current tenant selected"

        return 1
    fi

    # Build and validate session key
    local session_key="${server}:${tenant}"

    if jq -e ".sessions.\"$session_key\"" "$AUTH_CONFIG" >/dev/null 2>&1; then
        echo "$session_key"
    else
        print_error "No authentication found for $session_key"
        print_info_always "Use 'monk auth login $tenant <username>' on server '$server' to authenticate"
        return 1
    fi
}

# Temporarily switch context for single operation
with_tenant_context() {
    local target_session_key="$1"
    local operation_func="$2"
    shift 2
    local args=("$@")

    # Save current context
    local original_server original_tenant original_user
    original_server=$(jq -r '.current_server' "$ENV_CONFIG" 2>/dev/null)
    original_tenant=$(jq -r '.current_tenant' "$ENV_CONFIG" 2>/dev/null)

    original_user=$(jq -r '.current_user' "$ENV_CONFIG" 2>/dev/null)

    # Parse target session
    local target_server target_tenant
    target_server=$(echo "$target_session_key" | cut -d':' -f1)
    target_tenant=$(echo "$target_session_key" | cut -d':' -f2)

    # Get user from session
    local target_user
    target_user=$(jq -r ".sessions.\"$target_session_key\".user" "$AUTH_CONFIG" 2>/dev/null)

    print_info "Switching to context: $target_session_key (user: $target_user)"

    # Temporarily update env context
    local temp_file=$(mktemp)
    jq --arg server "$target_server" \
       --arg tenant "$target_tenant" \
       --arg user "$target_user" \
       '.current_server = $server | .current_tenant = $tenant | .current_user = $user' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

    # Execute operation with new context
    local result exit_code
    result=$("$operation_func" "${args[@]}")
    exit_code=$?

    # Restore original context

    temp_file=$(mktemp)
    jq --arg server "$original_server" \
       --arg tenant "$original_tenant" \
       --arg user "$original_user" \
       '.current_server = $server | .current_tenant = $tenant | .current_user = $user' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

    print_info "Restored context: $original_server:$original_tenant"

    echo "$result"
    return $exit_code
}

# Enhanced FTP request with tenant routing support
make_ftp_request_with_routing() {
    local endpoint="$1"    # list, stat, retrieve, delete
    local path="$2"
    local options="$3"
    local tenant_flag="$4" # Optional --tenant flag value

    local routing_info target_session_key api_path

    # Determine routing: flag takes precedence over path-based routing
    if [ -n "$tenant_flag" ]; then
        # Use --tenant flag specification
        if [[ "$tenant_flag" =~ ^([^:]+):(.+)$ ]]; then
            # Full server:tenant from flag
            target_session_key=$(resolve_session "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")
        else
            # Tenant only from flag, use current server

            target_session_key=$(resolve_session "current" "$tenant_flag")
        fi
        api_path="$path"  # Use path as-is when flag provided

    else
        # Parse path for tenant routing
        routing_info=$(parse_tenant_path "$path")
        eval "$routing_info"  # Sets server, tenant, path, tenant_routing variables

        if [ "$tenant_routing" = "true" ]; then
            target_session_key=$(resolve_session "$server" "$tenant")
            api_path="$path"  # api_path from parsing
        else
            # Standard operation with current session
            target_session_key=$(current_session_key)
            api_path="$path"
        fi
    fi

    # Validate session exists
    if ! validate_session "$target_session_key"; then
        return 1
    fi

    # Build payload
    local payload
    payload=$(build_ftp_payload "$api_path" "$options")

    # Execute request with appropriate context
    local current_key
    current_key=$(current_session_key 2>/dev/null)

    if [ "$target_session_key" = "$current_key" ]; then
        # Same as current context - direct execution
        make_ftp_request "$endpoint" "$payload"
    else
        # Different context - use temporary switching
        with_tenant_context "$target_session_key" make_ftp_request "$endpoint" "$payload"
    fi
}

# Validate session exists and has valid authentication
validate_session() {
    local session_key="$1"

    if [ -z "$session_key" ]; then
        return 1
    fi

    local jwt_token
    jwt_token=$(jq -r ".sessions.\"$session_key\".jwt_token" "$AUTH_CONFIG" 2>/dev/null)

    if [ -n "$jwt_token" ] && [ "$jwt_token" != "null" ]; then
        return 0
    else
        return 1
    fi
}

# Validate schema exists (best effort)
validate_schema() {
    local schema="$1"

    # Don't validate if running in non-verbose mode for speed
    if [ "$CLI_VERBOSE" != "true" ]; then
        return 0
    fi

    # Try to get schema info - if it fails, just warn but continue
    local response
    if response=$(make_request_json "GET" "/api/meta/schema" "" 2>/dev/null); then
        if echo "$response" | grep -q "\"$schema\""; then
            print_info "Schema validated: $schema"
        else
            print_warning "Schema '$schema' not found in meta API, but continuing anyway"
        fi
    else
        print_info "Could not validate schema dynamically, assuming valid: $schema"
    fi
}

# URL encode a string for safe HTTP requests
url_encode() {
    local string="$1"
    # Use python for proper URL encoding if available, otherwise basic sed
    if command -v python3 >/dev/null 2>&1; then
        python3 -c "import urllib.parse; print(urllib.parse.quote('''$string''', safe=''))"
    else
        # Fallback: basic encoding for common characters
        printf '%s' "$string" | sed \
            -e 's/ /%20/g' \
            -e 's/!/%21/g' \
            -e 's/"/%22/g' \
            -e 's/#/%23/g' \
            -e 's/\$/%24/g' \
            -e 's/%/%25/g' \
            -e 's/&/%26/g' \
            -e "s/'/%27/g"
    fi
}

# Make HTTP request to root API (no authentication required for localhost development)
make_root_request() {
    local method="$1"
    local endpoint="$2"  # e.g., "tenant", "tenant/my_app"
    local data="$3"
    local base_url=$(get_base_url)

    # URL encode tenant names in endpoints for proper HTTP handling
    if [[ "$endpoint" == tenant/* ]]; then
        local tenant_path="${endpoint#tenant/}"
        # Split on additional path segments (e.g., tenant/name/health)
        if [[ "$tenant_path" == */* ]]; then
            local tenant_name="${tenant_path%%/*}"
            local remaining_path="${tenant_path#*/}"
            local encoded_name=$(url_encode "$tenant_name")
            endpoint="tenant/${encoded_name}/${remaining_path}"
        else
            local encoded_name=$(url_encode "$tenant_path")
            endpoint="tenant/${encoded_name}"
        fi
    fi

    local full_url="${base_url}/api/root/${endpoint}"

    print_info "Making $method request to: $full_url"

    local curl_args=(-s -X "$method")

    # Add content-type header if data provided
    if [ -n "$data" ]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi

    local response
    local http_code

    # Make request and capture both response and HTTP status code
    response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Handle HTTP errors
    case "$http_code" in
        200|201|204)
            print_success "Success ($http_code)"
            echo "$response"
            return 0
            ;;
        400|404|500)
            print_error "HTTP Error ($http_code)"
            echo "$response" >&2
            exit 1
            ;;
        *)
            print_error "HTTP $http_code"
            echo "$response" >&2
            exit 1
            ;;
    esac
}

# Format tenant data for table output
format_tenant_table() {
    local tenants="$1"
    local include_trashed="$2"
    local include_deleted="$3"

    if [ "$JSON_PARSER" != "jq" ]; then
        print_error "jq required for tenant table formatting"
        exit 1
    fi

    local count
    count=$(echo "$tenants" | jq 'length')

    echo
    print_info "Total tenants: $count"
    echo

    if [[ "$count" -gt 0 ]]; then
        printf "%-20s %-10s %-20s %-20s %-20s\n" "NAME" "STATUS" "DATABASE" "HOST" "CREATED"
        echo "--------------------------------------------------------------------------------"

        echo "$tenants" | jq -r '.[] | [.name, .status, .database, .host, (.created_at | split("T")[0])] | @tsv' | \
        while IFS=$'\t' read -r name status database host created; do
            printf "%-20s %-10s %-20s %-20s %-20s\n" "$name" "$status" "$database" "$host" "$created"
        done
    else
        print_info "No tenants found"
    fi
    echo
}

# Confirm destructive operation with user input
confirm_destructive_operation() {
    local operation="$1"
    local target="$2"
    local force_flag="$3"
    local confirmation_word="${4:-y}"  # Default to 'y', or use custom word like 'DELETE'

    if [[ "$force_flag" == "1" ]]; then
        return 0  # Skip confirmation if --force used
    fi

    if [[ "$confirmation_word" == "y" ]]; then
        print_warning "Are you sure you want to $operation '$target'? (y/N)"
        read -r user_input

        if echo "$user_input" | grep -E "^[Yy]$" >/dev/null 2>&1; then
            return 0
        else
            print_info "Operation cancelled"
            exit 0
        fi
    else
        print_warning "DANGER: This will $operation '$target'!"
        print_warning "Type '$confirmation_word' to confirm:"
        read -r user_input

        if [[ "$user_input" == "$confirmation_word" ]]; then
            return 0
        else
            print_info "Operation cancelled"
            exit 0
        fi
    fi
}

# Determine output format from global flags
get_output_format() {
    local default_format="$1"  # "text" or "json"

    # Check global flags
    if [[ "${args[--text]}" == "1" ]]; then
        echo "text"
    elif [[ "${args[--json]}" == "1" ]]; then
        echo "json"
    else
        echo "$default_format"
    fi
}

# Validate format compatibility and show error if incompatible
validate_output_format() {
    local requested_format="$1"
    local supported_formats="$2"  # Space-separated list: "text json"

    if [[ "$supported_formats" == *"$requested_format"* ]]; then
        return 0
    else
        print_error "Output format '$requested_format' not supported for this command"
        print_info "Supported formats: $(echo "$supported_formats" | tr ' ' ', ')"
        exit 1
    fi
}

# Convert JSON to human-readable text format
json_to_text() {
    local json_data="$1"
    local context="$2"  # Context hint for formatting (e.g., "server_list", "tenant_status")

    if [ "$JSON_PARSER" != "jq" ]; then
        print_error "jq required for text formatting"
        echo "$json_data"
        return
    fi

    case "$context" in
        "server_list")
            echo
            printf "%-15s %-30s %-8s %-8s %-12s %-20s %s\n" "Name" "Endpoint" "Status" "Auth" "Last Ping" "Added" "Description"
            echo "--------------------------------------------------------------------------------------------"
            echo "$json_data" | jq -r '.servers[]? | [.name, .endpoint, .status, (if .auth_sessions > 0 then "yes (\(.auth_sessions))" else "no" end), (.last_ping | split("T")[0]), (.added_at | split("T")[0]), .description] | @tsv' | \
            while IFS=$'\t' read -r name endpoint status auth last_ping added desc; do
                current_marker=""
                if echo "$json_data" | jq -e ".current_server == \"$name\"" >/dev/null 2>&1; then
                    current_marker=" *"
                fi
                printf "%-15s %-30s %-8s %-8s %-12s %-20s %s%s\n" "$name" "$endpoint" "$status" "$auth" "$last_ping" "$added" "$desc" "$current_marker"
            done
            echo
            ;;
        "tenant_list")
            echo
            printf "%-20s %-30s %-8s %-20s %s\n" "Name" "Display Name" "Auth" "Added" "Description"
            echo "-------------------------------------------------------------------------------------"
            echo "$json_data" | jq -r '.tenants[]? | [.name, .display_name, (if .authenticated then "yes" else "no" end), (.added_at | split("T")[0]), .description] | @tsv' | \
            while IFS=$'\t' read -r name display_name auth added desc; do
                current_marker=""
                if echo "$json_data" | jq -e ".current_tenant == \"$name\"" >/dev/null 2>&1; then
                    current_marker=" *"
                fi
                printf "%-20s %-30s %-8s %-20s %s%s\n" "$name" "$display_name" "$auth" "$added" "$desc" "$current_marker"
            done
            echo
            ;;
        "auth_status")
            if echo "$json_data" | jq -e '.authenticated' >/dev/null 2>&1; then
                local tenant=$(echo "$json_data" | jq -r '.current_context.tenant')
                local server=$(echo "$json_data" | jq -r '.current_context.server')
                local user=$(echo "$json_data" | jq -r '.current_context.user')
                local database=$(echo "$json_data" | jq -r '.token_info.database')
                local exp_date=$(echo "$json_data" | jq -r '.token_info.exp_date')

                echo "Tenant: $tenant"
                echo "Database: $database"
                echo "Expires: $exp_date"
                echo "Server: $server"
                echo "Tenant: $tenant"
                echo "User: $user"
                print_success "Authenticated"
            else
                print_error "Not authenticated"
            fi
            ;;
        "data_table")
            # Generic data table - try to format as table if array
            if echo "$json_data" | jq -e 'type == "array"' >/dev/null 2>&1; then
                if echo "$json_data" | jq -e 'length > 0' >/dev/null 2>&1; then
                    # Get column headers from first object
                    local headers=$(echo "$json_data" | jq -r '.[0] | keys_unsorted | @tsv')
                    echo "$headers" | tr '\t' '\n' | nl -w3 -s') ' -v0
                    echo "---"
                    echo "$json_data" | jq -r '.[] | [.[] | tostring] | @tsv'
                else
                    echo "No data found"
                fi
            else
                echo "$json_data" | jq '.'
            fi
            ;;
        *)
            # Default: output compact JSON for machine readability
            echo "$json_data" | jq -c '.'
            ;;
    esac
}

# Convert JSON to YAML format
json_to_yaml() {
    local json_data="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        # Use yq if available, otherwise fallback to compact JSON with warning
        if command -v yq >/dev/null 2>&1; then
            echo "$json_data" | yq -P '.'
        else
            print_warning "yq not available - outputting compact JSON instead of YAML" >&2
            echo "$json_data" | jq -c '.'
        fi
    else
        print_error "jq required for YAML conversion"
        echo "$json_data"
    fi
}

# Convert YAML to JSON format
yaml_to_json() {
    local yaml_data="$1"

    if command -v yq >/dev/null 2>&1; then
        echo "$yaml_data" | yq -o=json '.'
    else
        print_error "yq required for YAML to JSON conversion"
        echo "$yaml_data"
    fi
}

# Universal output handler - handles text and JSON formats
handle_output() {
    local data="$1"
    local requested_format="$2"
    local default_format="$3"
    local context="${4:-default}"
    local supported_formats="${5:-text json}"

    # Validate format is supported
    validate_output_format "$requested_format" "$supported_formats"

    # Handle JSON format - always compress to single line for machine readability
    if [[ "$requested_format" == "json" ]]; then
        if [[ "$default_format" == "json" ]]; then
            # Already JSON - compress it
            echo "$data" | jq -c '.'
        else
            print_error "Cannot convert text output to structured format"
            print_info "Text format is human-readable only"
            exit 1
        fi
        return
    fi

    # Handle text format
    if [[ "$requested_format" == "text" ]]; then
        if [[ "$default_format" == "text" ]]; then
            # Already text - output directly
            echo "$data"
        elif [[ "$default_format" == "json" ]]; then
            # Convert JSON to text
            json_to_text "$data" "$context"
        else
            print_error "Unsupported format conversion: $default_format to $requested_format"
            echo "$data"
        fi
        return
    fi

    # Fallback: output data as-is
    echo "$data"
}

# :command.command_functions
# :command.function
monk_init_command() {

  # src/init_command.sh
  #!/bin/bash

  # init_command.sh - Initialize CLI configuration directory with complete structure
  #
  # This command creates the CLI configuration directory and initializes all config files
  # for clean domain separation following the new architecture.
  #
  # Creates:
  #   ~/.config/monk/cli/server.json  - Server endpoint registry
  #   ~/.config/monk/cli/tenant.json  - Tenant registry (server-scoped)
  #   ~/.config/monk/cli/auth.json    - Authentication sessions (per server+tenant)
  #   ~/.config/monk/cli/env.json     - Current working context (server+tenant+user)

  # Get arguments from bashly
  path="${args[path]}"
  force_flag="${args[--force]}"

  # Set configuration path (respects MONK_CLI_CONFIG_DIR environment variable)
  if [[ -n "$path" ]]; then
      cli_config_dir="$path"
  else
      cli_config_dir="${MONK_CLI_CONFIG_DIR:-${HOME}/.config/monk/cli}"
  fi

  # Colors for output
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  RED='\033[0;31m'
  NC='\033[0m' # No Color

  echo -e "${BLUE}Initializing Monk CLI configuration...${NC}"
  echo "Configuration path: ${cli_config_dir}"

  # Create CLI directory if it doesn't exist
  if [[ ! -d "$cli_config_dir" ]]; then
      echo -e "${YELLOW}→${NC} Creating CLI directory: ${cli_config_dir}"
      mkdir -p "$cli_config_dir"
  else
      echo -e "${GREEN}✓${NC} CLI directory exists: ${cli_config_dir}"
  fi

  # Initialize server.json
  server_file="${cli_config_dir}/server.json"
  if [[ ! -f "$server_file" ]] || [[ "$force_flag" = "1" ]]; then
      if [[ -f "$server_file" ]] && [[ "$force_flag" = "1" ]]; then
          echo -e "${YELLOW}→${NC} Force overwriting server.json"
      else
          echo -e "${YELLOW}→${NC} Creating server.json"
      fi
      cat > "$server_file" << 'EOF'
{
  "servers": {}
}
EOF
      echo -e "${GREEN}✓${NC} Created server.json"
  else
      echo -e "${GREEN}✓${NC} server.json already exists"
  fi

  # Initialize tenant.json
  tenant_file="${cli_config_dir}/tenant.json"
  if [[ ! -f "$tenant_file" ]] || [[ "$force_flag" = "1" ]]; then
      if [[ -f "$tenant_file" ]] && [[ "$force_flag" = "1" ]]; then
          echo -e "${YELLOW}→${NC} Force overwriting tenant.json"
      else
          echo -e "${YELLOW}→${NC} Creating tenant.json"
      fi
      cat > "$tenant_file" << 'EOF'
{
  "tenants": {}
}
EOF
      echo -e "${GREEN}✓${NC} Created tenant.json"
  else
      echo -e "${GREEN}✓${NC} tenant.json already exists"
  fi

  # Initialize auth.json
  auth_file="${cli_config_dir}/auth.json"
  if [[ ! -f "$auth_file" ]] || [[ "$force_flag" = "1" ]]; then
      if [[ -f "$auth_file" ]] && [[ "$force_flag" = "1" ]]; then
          echo -e "${YELLOW}→${NC} Force overwriting auth.json"
      else
          echo -e "${YELLOW}→${NC} Creating auth.json"
      fi
      cat > "$auth_file" << 'EOF'
{
  "sessions": {}
}
EOF
      chmod 600 "$auth_file"
      echo -e "${GREEN}✓${NC} Created auth.json (secure permissions)"
  else
      echo -e "${GREEN}✓${NC} auth.json already exists"
  fi

  # Initialize env.json (never force overwrite - preserve user context)
  env_file="${cli_config_dir}/env.json"
  if [[ ! -f "$env_file" ]]; then
      echo -e "${YELLOW}→${NC} Creating env.json"
      cat > "$env_file" << 'EOF'
{
  "current_server": null,
  "current_tenant": null,
  "current_user": null,
  "recents": []
}
EOF
      echo -e "${GREEN}✓${NC} Created env.json"
  else
      echo -e "${GREEN}✓${NC} env.json already exists (preserved)"
      if [[ "$force_flag" = "1" ]]; then
          echo -e "${BLUE}ℹ${NC} env.json is never overwritten to preserve your context"
      fi
  fi

  echo -e "${GREEN}✓${NC} Monk CLI configuration initialized successfully!"
  echo
  echo "CLI configuration files created in: ${cli_config_dir}"
  echo "  - server.json: Server endpoint registry"
  echo "  - tenant.json: Tenant registry (server-scoped)"
  echo "  - auth.json: Authentication sessions per server+tenant"

  echo "  - env.json: Current working context (server+tenant+user)"
  echo
  echo "Next steps:"
  echo "  1. Add a server: monk server add <name> <hostname:port>"
  echo "  2. Add a tenant: monk tenant add <name> <display_name>"
  echo "  3. Select server: monk server use <name>"
  echo "  4. Select tenant: monk tenant use <name>"
  echo "  5. Authenticate: monk auth login <tenant> <username>"
  echo "  6. Start working: monk data select <schema>"
}

# :command.function
monk_server_add_command() {

  # src/server_add_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"
  endpoint="${args[endpoint]}"
  description="${args[--description]}"

  init_cli_configs

  # Parse endpoint
  parsed=$(parse_endpoint "$endpoint")
  protocol=$(echo "$parsed" | cut -d'|' -f1)
  hostname=$(echo "$parsed" | cut -d'|' -f2)
  port=$(echo "$parsed" | cut -d'|' -f3)

  print_info "Adding server: $name"
  print_info "Endpoint: $protocol://$hostname:$port"
  if [ -n "$description" ]; then
      print_info "Description: $description"
  fi

  # Check if server already exists
  if command -v jq >/dev/null 2>&1; then
      if jq -e ".servers.\"$name\"" "$SERVER_CONFIG" >/dev/null 2>&1; then
          print_error "Server '$name' already exists"
          print_info "Use 'monk server delete $name' first, or choose a different name"
          exit 1
      fi
  fi

  # Test connectivity
  print_info "Testing connectivity to $protocol://$hostname:$port"
  base_url="$protocol://$hostname:$port"

  if ping_server_url "$base_url"; then
      print_success "Server is reachable"
      status="up"
  else
      print_info "Server appears to be down (this is OK, adding anyway)"
      status="down"
  fi

  # Add server to config
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  if command -v jq >/dev/null 2>&1; then
      # Use jq for JSON manipulation
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg hostname "$hostname" \
         --arg port "$port" \
         --arg protocol "$protocol" \
         --arg description "$description" \
         --arg timestamp "$timestamp" \
         --arg status "$status" \
         '.servers[$name] = {
             "hostname": $hostname,
             "port": ($port | tonumber),
             "protocol": $protocol,
             "description": $description,
             "added_at": $timestamp,
             "last_ping": $timestamp,
             "status": $status
         }' "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

      print_success "Server '$name' added successfully"

      # If this is the first server, make it current in env config
      server_count=$(jq '.servers | length' "$SERVER_CONFIG")
      if [ "$server_count" -eq 1 ]; then
          temp_file=$(mktemp)
          jq --arg name "$name" '.current_server = $name' "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
          print_info "Set as current server (first server added)"
      fi
  else
      print_error "jq is required for server management"
      print_info "Please install jq: brew install jq (macOS) or apt-get install jq (Linux)"
      exit 1
  fi
}

# :command.function
monk_server_list_command() {

  # src/server_list_command.sh
  #!/bin/bash

  # server_list_command.sh - List all servers with universal output format support

  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  server_names=$(jq -r '.servers | keys[]' "$SERVER_CONFIG" 2>/dev/null)

  if [ -z "$server_names" ]; then
      # No servers - handle based on output format
      empty_result='{"servers": [], "current_server": null}'

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Registered Servers"
          echo
          print_info "No servers configured"
          print_info "Use 'monk server add <name> <hostname:port>' to add servers"
      else
          handle_output "$empty_result" "$output_format" "json" "server_list"
      fi
      exit 0
  fi

  # Build JSON data internally (always generate JSON first)
  servers_json=$(echo "$server_names" | while read -r name; do
      if [ -n "$name" ]; then
          server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG")

          hostname=$(echo "$server_info" | jq -r '.hostname')
          port=$(echo "$server_info" | jq -r '.port')
          protocol=$(echo "$server_info" | jq -r '.protocol')
          status=$(echo "$server_info" | jq -r '.status // "unknown"')
          last_ping=$(echo "$server_info" | jq -r '.last_ping // "never"')
          added_at=$(echo "$server_info" | jq -r '.added_at // "unknown"')
          description=$(echo "$server_info" | jq -r '.description // ""')

          endpoint="$protocol://$hostname:$port"

          # Check authentication count
          auth_count=$(jq --arg server "$name" '[.sessions | to_entries[] | select(.key | startswith($server + ":"))] | length' "$AUTH_CONFIG" 2>/dev/null || echo "0")
          is_current=$([ "$name" = "$current_server" ] && echo "true" || echo "false")

          # Create JSON object for this server
          jq -n \
              --arg name "$name" \
              --arg hostname "$hostname" \
              --argjson port "$port" \
              --arg protocol "$protocol" \
              --arg endpoint "$endpoint" \
              --arg status "$status" \
              --arg last_ping "$last_ping" \
              --arg added_at "$added_at" \
              --arg description "$description" \
              --argjson auth_sessions "$auth_count" \
              --argjson is_current "$is_current" \
              '{
                  name: $name,
                  hostname: $hostname,
                  port: $port,
                  protocol: $protocol,
                  endpoint: $endpoint,
                  status: $status,
                  last_ping: $last_ping,
                  added_at: $added_at,
                  description: $description,
                  auth_sessions: $auth_sessions,
                  is_current: $is_current
              }'
      fi
  done | jq -s --arg current_server "$current_server" \
      '{servers: ., current_server: ($current_server | if . == "" then null else . end)}')

  # Output in requested format using universal handler
  handle_output "$servers_json" "$output_format" "json" "server_list"
}

# :command.function
monk_server_current_command() {

  # src/server_current_command.sh
  #!/bin/bash

  # server_current_command.sh - Show currently selected server with universal format support

  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      # No current server - generate appropriate response
      error_result='{"current_server": null, "error": "No current server selected"}'

      if [[ "$output_format" == "text" ]]; then
          print_info "No current server selected"
          print_info "Use 'monk server use <name>' to select a server"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 0
  fi

  server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      # Server not found in registry
      error_result=$(jq -n --arg server "$current_server" '{"current_server": $server, "error": "Server not found in registry"}')

      if [[ "$output_format" == "text" ]]; then
          print_error "Current server '$current_server' not found in registry"
          print_info "The server may have been deleted. Use 'monk server list' to see available servers"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  # Extract server details
  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  status=$(echo "$server_info" | jq -r '.status // "unknown"')
  description=$(echo "$server_info" | jq -r '.description // ""')
  base_url="$protocol://$hostname:$port"

  # Check authentication count
  auth_count=$(jq --arg server "$current_server" '[.sessions | to_entries[] | select(.key | startswith($server + ":"))] | length' "$AUTH_CONFIG" 2>/dev/null || echo "0")

  # Build JSON response
  server_json=$(jq -n \
      --arg name "$current_server" \
      --arg hostname "$hostname" \
      --arg port "$port" \
      --arg protocol "$protocol" \
      --arg endpoint "$base_url" \
      --arg status "$status" \
      --arg description "$description" \
      --argjson auth_count "$auth_count" \
      '{
          name: $name,
          hostname: $hostname,
          port: ($port | tonumber),
          protocol: $protocol,
          endpoint: $endpoint,
          base_url: $endpoint,
          status: $status,
          description: $description,
          auth_sessions: $auth_count
      }')

  # Handle text format with custom formatting for single server
  if [[ "$output_format" == "text" ]]; then
      echo
      print_info "Current Server"
      echo
      echo "Name: $current_server"
      echo "Endpoint: $base_url"
      echo "Status: $status"
      if [ -n "$description" ]; then
          echo "Description: $description"
      fi
      echo "Auth Sessions: $auth_count"
      echo
  else
      # Use universal handler for JSON output
      handle_output "$server_json" "$output_format" "json"
  fi
}

# :command.function
monk_server_use_command() {

  # src/server_use_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # If no name provided, show current server (alias for 'current' command)
  if [ -z "$name" ]; then
      current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
          print_info "No current server selected"
          print_info "Use 'monk servers use <name>' to select a server"
          exit 0
      fi

      server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)
      if [ "$server_info" = "null" ]; then
          print_error "Current server '$current_server' not found in registry"
          print_info "The server may have been deleted. Use 'monk servers list' to see available servers"
          exit 1
      fi

      echo
      print_info "Current Server"
      echo

      hostname=$(echo "$server_info" | jq -r '.hostname')
      port=$(echo "$server_info" | jq -r '.port')
      protocol=$(echo "$server_info" | jq -r '.protocol')
      status=$(echo "$server_info" | jq -r '.status // "unknown"')
      description=$(echo "$server_info" | jq -r '.description // ""')

      echo "Name: $current_server"
      echo "Endpoint: $protocol://$hostname:$port"
      echo "Status: $status"
      if [ -n "$description" ]; then
          echo "Description: $description"
      fi

      # Show calculated base URL
      base_url="$protocol://$hostname:$port"
      echo "Base URL: $base_url"
      exit 0
  fi

  # Check if server exists
  server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  # Set as current server
  temp_file=$(mktemp)
  jq --arg name "$name" '.current_server = $name' "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

  # Get server details for confirmation
  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"

  print_success "Switched to server: $name"
  print_info "Endpoint: $base_url"
  print_info "All monk commands will now use this server"
  print_info "Base URL: $base_url"
}

# :command.function
monk_server_delete_command() {

  # src/server_delete_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Check if server exists
  if ! jq -e ".servers.\"$name\"" "$SERVER_CONFIG" >/dev/null 2>&1; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  print_info "Deleting server: $name"

  # Remove server from config
  temp_file=$(mktemp)
  jq --arg name "$name" 'del(.servers[$name])' "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

  # If this was the current server, clear current
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ "$current_server" = "$name" ]; then
      jq '.current_server = null' "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
      print_info "Cleared current server (was deleted server)"
  fi

  print_success "Server '$name' deleted successfully"
}

# :command.function
monk_server_ping_command() {

  # src/server_ping_command.sh
  #!/bin/bash

  # server_ping_command.sh - Health check server with universal format support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # If no name provided, use current server
  if [ -z "$name" ]; then
      name=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      if [ -z "$name" ] || [ "$name" = "null" ]; then
          error_result='{"error": "No server specified and no current server selected"}'

          if [[ "$output_format" == "text" ]]; then
              print_error "No server specified and no current server selected"
              print_info "Use 'monk server ping <name>' or 'monk server use <name>' first"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
      fi

      if [[ "$output_format" == "text" ]]; then
          print_info "Using current server: $name"
      fi
  fi

  # Get server info
  server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      error_result=$(jq -n --arg server_name "$name" '{"server_name": $server_name, "error": "Server not found"}')

      if [[ "$output_format" == "text" ]]; then
          print_error "Server '$name' not found"
          print_info "Use 'monk server list' to see available servers"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  if [[ "$output_format" == "text" ]]; then
      print_info "Pinging server: $name ($base_url)"
  fi

  # Test connectivity to root endpoint
  # Use curl's built-in timing to avoid bash arithmetic overflow
  if response_time_raw=$(curl -s --max-time 10 --fail -w '%{time_total}' -o /dev/null "$base_url/" 2>/dev/null); then
      # Convert seconds to milliseconds using awk
      response_time=$(echo "$response_time_raw" | awk '{printf "%.0f", $1 * 1000}')

      # Update status in config
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg timestamp "$timestamp" \
         '.servers[$name].last_ping = $timestamp | .servers[$name].status = "up"' \
         "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

      # Build success response JSON
      ping_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          --arg status "up" \
          --arg timestamp "$timestamp" \
          --argjson response_time_ms "$response_time" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              status: $status,
              timestamp: $timestamp,
              response_time_ms: $response_time_ms,
              success: true
          }')

      if [[ "$output_format" == "text" ]]; then
          print_success "Server is up and responding"
          print_info "Response time: ${response_time}ms"
      else
          handle_output "$ping_result" "$output_format" "json"
      fi
  else
      # Update status in config
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg timestamp "$timestamp" \
         '.servers[$name].last_ping = $timestamp | .servers[$name].status = "down"' \
         "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

      # Build failure response JSON
      ping_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          --arg status "down" \
          --arg timestamp "$timestamp" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              status: $status,
              timestamp: $timestamp,
              success: false,
              error: "Server is down or not responding"
          }')

      if [[ "$output_format" == "text" ]]; then
          print_error "Server is down or not responding"
      else
          handle_output "$ping_result" "$output_format" "json"
      fi
      exit 1
  fi
}

# :command.function
monk_server_ping_all_command() {

  # src/server_ping_all_command.sh
  #!/bin/bash

  # server_ping_all_command.sh - Health check all servers with universal format support

  # Check dependencies
  check_dependencies

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  server_names=$(jq -r '.servers | keys[]' "$SERVER_CONFIG" 2>/dev/null)

  if [ -z "$server_names" ]; then
      empty_result='{"servers": [], "summary": {"total": 0, "up": 0, "down": 0}}'

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Pinging All Servers"
          echo
          print_info "No servers configured"
          print_info "Use 'monk server add <name> <hostname:port>' to add servers"
      else
          handle_output "$empty_result" "$output_format" "json"
      fi
      exit 0
  fi

  if [[ "$output_format" == "text" ]]; then
      echo
      print_info "Pinging All Servers"
      echo
  fi

  # Build results array for JSON output
  ping_results=$(echo "$server_names" | while read -r name; do
      if [ -n "$name" ]; then
          server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG")
          hostname=$(echo "$server_info" | jq -r '.hostname')
          port=$(echo "$server_info" | jq -r '.port')
          protocol=$(echo "$server_info" | jq -r '.protocol')
          base_url="$protocol://$hostname:$port"
          timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Test connectivity with timeout
          if response_time_raw=$(curl -s --max-time 5 --fail -w '%{time_total}' -o /dev/null "$base_url/" 2>/dev/null); then
              response_time=$(echo "$response_time_raw" | awk '{printf "%.0f", $1 * 1000}')
              server_status="up"
              success=true

              if [[ "$output_format" == "text" ]]; then
                  printf "%-15s %-30s %-8s %s\n" "$name" "$base_url" "up" "${response_time}ms"
              fi
          else
              response_time=0
              server_status="down"
              success=false

              if [[ "$output_format" == "text" ]]; then
                  printf "%-15s %-30s %-8s %s\n" "$name" "$base_url" "down" "timeout"
              fi
          fi

          # Update server status in config
          temp_file=$(mktemp)
          jq --arg name "$name" \
             --arg timestamp "$timestamp" \
             --arg status "$server_status" \
             '.servers[$name].last_ping = $timestamp | .servers[$name].status = $status' \
             "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

          # Generate JSON result for this server
          jq -n \
              --arg server_name "$name" \
              --arg hostname "$hostname" \
              --arg port "$port" \
              --arg protocol "$protocol" \
              --arg endpoint "$base_url" \
              --arg status "$server_status" \
              --arg timestamp "$timestamp" \
              --argjson response_time_ms "$response_time" \
              --argjson success "$success" \
              '{
                  server_name: $server_name,
                  hostname: $hostname,
                  port: ($port | tonumber),
                  protocol: $protocol,
                  endpoint: $endpoint,
                  status: $status,
                  timestamp: $timestamp,
                  response_time_ms: $response_time_ms,
                  success: $success
              }'
      fi
  done)

  # Calculate summary statistics and build final result
  if [[ "$output_format" == "json" ]]; then
      # Build complete JSON response with summary
      final_result=$(echo "$ping_results" | jq -s '{
          servers: .,
          summary: {
              total: length,
              up: [.[] | select(.success == true)] | length,
              down: [.[] | select(.success == false)] | length
          }
      }')
      handle_output "$final_result" "$output_format" "json"
  elif [[ "$output_format" == "text" ]]; then
      # Show summary for text output
      total_servers=$(echo "$ping_results" | jq -s 'length')
      up_servers=$(echo "$ping_results" | jq -s '[.[] | select(.success == true)] | length')
      down_servers=$(echo "$ping_results" | jq -s '[.[] | select(.success == false)] | length')

      echo
      print_info "Summary: $up_servers up, $down_servers down (total: $total_servers)"
  fi
}

# :command.function
monk_tenant_add_command() {

  # src/tenant_add_command.sh
  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  name="${args[name]}"
  display_name="${args[display_name]}"
  description="${args[--description]}"

  # Get current server
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      print_error "No current server selected"
      print_info "Use 'monk server use <name>' to select a server first"
      exit 1
  fi

  # Validate tenant name
  if [[ ! "$name" =~ ^[a-zA-Z0-9][a-zA-Z0-9_-]*$ ]]; then
      print_error "Invalid tenant name: '$name'"
      print_info "Tenant names must start with alphanumeric character and contain only letters, numbers, hyphens, and underscores"
      exit 1
  fi

  # Check if tenant already exists for this server
  existing_tenant=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG" 2>/dev/null)
  if [ "$existing_tenant" != "null" ]; then
      existing_server=$(echo "$existing_tenant" | jq -r '.server')
      if [ "$existing_server" = "$current_server" ]; then
          print_error "Tenant '$name' already exists for server '$current_server'"
          exit 1
      elif [ "$existing_server" != "null" ]; then
          print_error "Tenant '$name' already exists for server '$existing_server'"
          print_info "Use a different tenant name or remove the existing tenant first"
          exit 1
      fi
  fi

  # Create timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  # Add tenant to config with server association
  temp_file=$(mktemp)
  jq --arg name "$name" \
     --arg display_name "$display_name" \
     --arg description "${description:-}" \
     --arg server "$current_server" \
     --arg timestamp "$timestamp" \
     '.tenants[$name] = {
         "display_name": $display_name,
         "description": $description,
         "server": $server,
         "added_at": $timestamp
     }' "$TENANT_CONFIG" > "$temp_file" && mv "$temp_file" "$TENANT_CONFIG"

  print_success "Added tenant '$name' ($display_name) for server '$current_server'"
  if [ -n "$description" ]; then
      print_info "Description: $description"
  fi
}

# :command.function
monk_tenant_list_command() {

  # src/tenant_list_command.sh
  #!/bin/bash

  # tenant_list_command.sh - List all registered tenants with universal format support

  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  server_flag="${args[--server]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

  # Determine target server
  target_server="$server_flag"
  if [ -z "$target_server" ]; then
      target_server="$current_server"
  fi

  if [ -z "$target_server" ] || [ "$target_server" = "null" ]; then
      error_result='{"error": "No server specified and no current server selected"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "No server specified and no current server selected"
          print_info "Use 'monk server use <name>' to select a server or use --server flag"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  # Get tenant names for the target server
  tenant_names=$(jq -r --arg server "$target_server" '.tenants | to_entries[] | select(.value.server == $server) | .key' "$TENANT_CONFIG" 2>/dev/null)

  if [ -z "$tenant_names" ]; then
      empty_result=$(jq -n --arg server "$target_server" '{"tenants": [], "current_tenant": null, "server": $server}')

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Registered Tenants for Server: $target_server"
          echo
          print_info "No tenants configured for this server"
          print_info "Use 'monk tenant add <name> <display_name>' to add tenants"
      else
          handle_output "$empty_result" "$output_format" "json"
      fi
      exit 0
  fi

  # Build JSON data for all tenants
  tenants_json=$(echo "$tenant_names" | while read -r name; do
      if [ -n "$name" ]; then
          tenant_info=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG")

          display_name=$(echo "$tenant_info" | jq -r '.display_name')
          description=$(echo "$tenant_info" | jq -r '.description // ""')
          server=$(echo "$tenant_info" | jq -r '.server')
          added_at=$(echo "$tenant_info" | jq -r '.added_at // "unknown"')

          # Check authentication count for this tenant on this specific server
          session_key="${server}:${name}"
          auth_count=$(jq --arg session_key "$session_key" '.sessions | has($session_key) | if . then 1 else 0 end' "$AUTH_CONFIG" 2>/dev/null || echo "0")
          is_current=$([ "$name" = "$current_tenant" ] && [ "$server" = "$current_server" ] && echo "true" || echo "false")

          jq -n \
              --arg name "$name" \
              --arg display_name "$display_name" \
              --arg description "$description" \
              --arg server "$server" \
              --arg added_at "$added_at" \
              --argjson auth_count "$auth_count" \
              --argjson is_current "$is_current" \
              '{
                  name: $name,
                  display_name: $display_name,
                  description: $description,
                  server: $server,
                  added_at: $added_at,
                  authenticated: ($auth_count > 0),
                  is_current: $is_current
              }'
      fi
  done | jq -s --arg current_tenant "$current_tenant" \
      --arg server "$target_server" \
      '{tenants: ., current_tenant: ($current_tenant | if . == "" then null else . end), server: $server}')

  # Output in requested format
  if [[ "$output_format" == "text" ]]; then
      # Custom text formatting for tenant list
      echo
      print_info "Registered Tenants for Server: $target_server"
      echo

      printf "%-20s %-30s %-8s %-20s %s\n" "Name" "Display Name" "Auth" "Added" "Description"
      echo "-------------------------------------------------------------------------------------"

      echo "$tenants_json" | jq -r '.tenants[] | [.name, .display_name, (if .authenticated then "yes" else "no" end), (.added_at | split("T")[0]), .description] | @tsv' | \
      while IFS=$'\t' read -r name display_name auth added desc; do
          current_marker=""
          if echo "$tenants_json" | jq -e ".current_tenant == \"$name\"" >/dev/null 2>&1; then
              current_marker=" *"
          fi
          printf "%-20s %-30s %-8s %-20s %s%s\n" "$name" "$display_name" "$auth" "$added" "$desc" "$current_marker"
      done

      echo
      if [ -n "$current_tenant" ] && [ "$target_server" = "$current_server" ]; then
          print_info "Current tenant: $current_tenant (marked with *)"
      else
          print_info "No current tenant selected for this server"
          print_info "Use 'monk tenant use <name>' to select a tenant"
      fi
  else
      handle_output "$tenants_json" "$output_format" "json"
  fi
}

# :command.function
monk_tenant_delete_command() {

  # src/tenant_delete_command.sh
  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  name="${args[name]}"

  # Check if tenant exists
  tenant_info=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG" 2>/dev/null)
  if [ "$tenant_info" = "null" ]; then
      print_error "Tenant '$name' not found"
      exit 1
  fi

  display_name=$(echo "$tenant_info" | jq -r '.display_name')

  # Check if this is the current tenant
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ "$name" = "$current_tenant" ]; then
      print_warning "Cannot delete current tenant '$name'"
      print_info "Use 'monk tenant use <other_tenant>' to switch first"
      exit 1
  fi

  # Check for active sessions
  auth_count=$(jq --arg tenant "$name" '[.sessions | to_entries[] | select(.key | endswith(":" + $tenant))] | length' "$AUTH_CONFIG" 2>/dev/null || echo "0")
  if [ "$auth_count" -gt 0 ]; then
      print_warning "Tenant '$name' has $auth_count active sessions"
      print_info "Sessions will be removed along with tenant"
  fi

  # Confirmation
  print_warning "Are you sure you want to delete tenant '$name' ($display_name)? (y/N)"
  read -r confirmation
  if ! echo "$confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
      print_info "Operation cancelled"
      exit 0
  fi

  # Remove tenant from config
  temp_file=$(mktemp)
  jq --arg name "$name" \
     'del(.tenants[$name])' \
     "$TENANT_CONFIG" > "$temp_file" && mv "$temp_file" "$TENANT_CONFIG"

  # Remove any sessions for this tenant
  temp_file=$(mktemp)
  jq --arg tenant "$name" \
     'del(.sessions[] | select(.tenant == $tenant))' \
     "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"

  print_success "Deleted tenant '$name' ($display_name)"
  if [ "$auth_count" -gt 0 ]; then
      print_info "Removed $auth_count authentication sessions"
  fi
}

# :command.function
monk_tenant_use_command() {

  # src/tenant_use_command.sh
  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  name="${args[name]}"

  # Get current server
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      print_error "No current server selected"
      print_info "Use 'monk server use <name>' to select a server first"
      exit 1
  fi

  # Check if tenant exists and belongs to current server
  tenant_info=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG" 2>/dev/null)
  if [ "$tenant_info" = "null" ]; then
      print_error "Tenant '$name' not found"
      print_info "Use 'monk tenant list' to see available tenants for current server"
      exit 1
  fi

  tenant_server=$(echo "$tenant_info" | jq -r '.server')
  if [ "$tenant_server" != "$current_server" ]; then
      print_error "Tenant '$name' belongs to server '$tenant_server', but current server is '$current_server'"
      print_info "Use 'monk server use $tenant_server' to switch servers first"
      exit 1
  fi

  # Update current tenant in env config
  temp_file=$(mktemp)
  jq --arg tenant "$name" \
     '.current_tenant = $tenant' \
     "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

  display_name=$(echo "$tenant_info" | jq -r '.display_name')
  print_success "Switched to tenant: $name ($display_name)"

  # Show authentication status for this tenant on current server
  session_key="${current_server}:${name}"
  if jq -e ".sessions.\"$session_key\"" "$AUTH_CONFIG" >/dev/null 2>&1; then
      user=$(jq -r ".sessions.\"$session_key\".user" "$AUTH_CONFIG" 2>/dev/null)
      print_info "Authenticated as: $user on server '$current_server'"
  else
      print_warning "Not authenticated for this tenant on server '$current_server'"
      print_info "Use 'monk auth login $name <username>' to authenticate"
  fi
}

# :command.function
monk_auth_login_command() {

  # src/auth_login_command.sh
  # Check dependencies
  check_dependencies

  # Extract tenant and username from bashly args
  tenant="${args[tenant]}"
  username="${args[username]}"

  print_info "Authenticating with tenant: $tenant, username: $username"

  # Prepare authentication request
  auth_data="{\"tenant\": \"$tenant\", \"username\": \"$username\"}"
  base_url=$(get_base_url)

  print_info "Sending authentication request to: ${base_url}/auth/login"

  # Make authentication request
  if response=$(make_request_json "POST" "/auth/login" "$auth_data"); then
      # Extract token from response
      token=""
      if [ "$JSON_PARSER" = "jq" ]; then
          token=$(echo "$response" | jq -r '.data.token' 2>/dev/null)
      elif [ "$JSON_PARSER" = "jshon" ]; then
          token=$(echo "$response" | jshon -e data -e token -u 2>/dev/null)
      else
          # Fallback: extract token manually
          token=$(echo "$response" | grep -o '"token":"[^"]*"' | cut -d'"' -f4)
      fi

      if [ -n "$token" ] && [ "$token" != "null" ]; then
          # Store token with tenant and username
          store_token "$token" "$tenant" "$username"

          print_success "Authentication successful"
          print_info "JWT token stored for server+tenant context"
      else
          print_error "Failed to extract JWT token from response"
          print_info "Response: $response"
          exit 1
      fi
  else
      print_error "Authentication failed"
      exit 1
  fi
}

# :command.function
monk_auth_logout_command() {

  # src/auth_logout_command.sh
  # Check dependencies
  check_dependencies

  # Check if we have any stored authentication
  if get_jwt_token >/dev/null 2>&1; then
      remove_stored_token
      print_success "Logged out successfully"
      print_info_always "Cleared authentication for current server+tenant context"
  else
      print_info_always "Already logged out (no active authentication found)"
  fi
}

# :command.function
monk_auth_status_command() {

  # src/auth_status_command.sh
  #!/bin/bash

  # auth_status_command.sh - Show authentication status with universal format support

  # Check dependencies
  check_dependencies

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  token=$(get_jwt_token)

  # Get current context information
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  current_user=$(jq -r '.current_user // empty' "$ENV_CONFIG" 2>/dev/null)

  if [ -n "$token" ]; then
      # Extract token info
      tenant="unknown"
      database="unknown"
      exp="unknown"
      exp_date="unknown"

      # Try to extract domain from token (basic JWT decode)
      if [ "$JSON_PARSER" = "jq" ] || [ "$JSON_PARSER" = "jshon" ]; then
          # Decode JWT payload (basic base64 decode of middle part)
          payload=$(echo "$token" | cut -d'.' -f2)
          # Add padding if needed
          case $((${#payload} % 4)) in
              2) payload="${payload}==" ;;
              3) payload="${payload}=" ;;
          esac

          if command -v base64 &> /dev/null; then
              decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
              if [ -n "$decoded" ]; then
                  if [ "$JSON_PARSER" = "jq" ]; then
                      tenant=$(echo "$decoded" | jq -r '.tenant' 2>/dev/null || echo "unknown")
                      database=$(echo "$decoded" | jq -r '.database' 2>/dev/null || echo "unknown")
                      exp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null || echo "unknown")
                  elif [ "$JSON_PARSER" = "jshon" ]; then
                      tenant=$(echo "$decoded" | jshon -e tenant -u 2>/dev/null || echo "unknown")
                      database=$(echo "$decoded" | jshon -e database -u 2>/dev/null || echo "unknown")
                      exp=$(echo "$decoded" | jshon -e exp -u 2>/dev/null || echo "unknown")
                  fi

                  if [ "$exp" != "unknown" ] && [ "$exp" != "null" ]; then
                      if command -v date &> /dev/null; then
                          exp_date=$(date -r "$exp" 2>/dev/null || echo "unknown")
                      fi
                  fi
              fi
          fi
      fi

      # Build authenticated status JSON
      auth_status=$(jq -n \
          --arg authenticated "true" \
          --arg tenant "$tenant" \
          --arg database "$database" \
          --arg exp "$exp" \
          --arg exp_date "$exp_date" \
          --arg current_server "$current_server" \
          --arg current_tenant "$current_tenant" \
          --arg current_user "$current_user" \
          --arg has_token "true" \
          '{
              authenticated: ($authenticated == "true"),
              has_token: ($has_token == "true"),
              token_info: {
                  tenant: $tenant,
                  database: $database,
                  exp: ($exp | if . == "unknown" then null else (. | tonumber) end),
                  exp_date: ($exp_date | if . == "unknown" then null else . end)
              },
              current_context: {
                  server: ($current_server | if . == "" or . == "null" then null else . end),
                  tenant: ($current_tenant | if . == "" or . == "null" then null else . end),
                  user: ($current_user | if . == "" or . == "null" then null else . end)
              }
          }')

      if [[ "$output_format" == "text" ]]; then
          echo "Tenant: $tenant"
          echo "Database: $database"
          if [ "$exp_date" != "unknown" ]; then
              echo "Expires: $exp_date"
          fi
          echo "Server: $current_server"
          echo "Tenant: $current_tenant"
          echo "User: $current_user"
          print_success "Authenticated"
      else
          handle_output "$auth_status" "$output_format" "json"
      fi
  else
      # Build unauthenticated status JSON
      unauth_status=$(jq -n \
          --arg current_server "$current_server" \
          --arg current_tenant "$current_tenant" \
          --arg current_user "$current_user" \
          '{
              authenticated: false,
              has_token: false,
              token_info: null,
              current_context: {
                  server: ($current_server | if . == "" or . == "null" then null else . end),
                  tenant: ($current_tenant | if . == "" or . == "null" then null else . end),
                  user: ($current_user | if . == "" or . == "null" then null else . end)
              },
              message: "Not authenticated. Use monk auth login TENANT USERNAME to authenticate."
          }')

      if [[ "$output_format" == "text" ]]; then
          print_error "Not authenticated"
          print_info "Use 'monk auth login TENANT USERNAME' to authenticate"
      else
          handle_output "$unauth_status" "$output_format" "json"
      fi
  fi
}

# :command.function
monk_auth_token_command() {

  # src/auth_token_command.sh
  token=$(get_jwt_token)

  if [ -n "$token" ]; then
      echo "$token"
  else
      print_error "No token found. Use 'monk auth login TENANT USERNAME' first"
      exit 1
  fi
}

# :command.function
monk_auth_info_command() {

  # src/auth_info_command.sh
  #!/bin/bash

  # auth_info_command.sh - Decode and display JWT token contents with universal format support

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  token=$(get_jwt_token)

  if [ -z "$token" ]; then
      error_result='{"error": "No authentication token found", "message": "Use monk auth login TENANT USERNAME to authenticate"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "No authentication token found"
          print_info "Use 'monk auth login TENANT USERNAME' to authenticate"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  # Extract payload (second part) from JWT
  payload=$(echo "$token" | cut -d'.' -f2)

  # Add padding if needed for base64 decoding
  padding=$((4 - ${#payload} % 4))
  if [ $padding -ne 4 ]; then
      payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
  fi

  # Decode base64 payload
  if command -v base64 >/dev/null 2>&1; then
      decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
  else
      error_result='{"error": "base64 command not found"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "base64 command not found"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  if [ -n "$decoded" ]; then
      if command -v jq >/dev/null 2>&1; then
          # Add computed fields to the token payload for JSON output
          exp_timestamp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null)
          exp_date=""
          if [ "$exp_timestamp" != "null" ] && [ -n "$exp_timestamp" ]; then
              exp_date=$(date -r "$exp_timestamp" 2>/dev/null || echo 'unknown')
          fi

          # Build enhanced token info JSON
          token_info=$(echo "$decoded" | jq --arg exp_date "$exp_date" \
              '. + {
                  exp_date: (if $exp_date == "" or $exp_date == "unknown" then null else $exp_date end),
                  token_valid: true
              }')

          if [[ "$output_format" == "text" ]]; then
              # Human-readable output
              print_success "JWT Token Information:"
              echo

              # Extract key fields for display
              sub=$(echo "$decoded" | jq -r '.sub // "unknown"' 2>/dev/null)
              name=$(echo "$decoded" | jq -r '.name // "unknown"' 2>/dev/null)
              tenant=$(echo "$decoded" | jq -r '.tenant // "unknown"' 2>/dev/null)
              database=$(echo "$decoded" | jq -r '.database // "unknown"' 2>/dev/null)
              access=$(echo "$decoded" | jq -r '.access // "unknown"' 2>/dev/null)
              iat=$(echo "$decoded" | jq -r '.iat // "unknown"' 2>/dev/null)
              exp=$(echo "$decoded" | jq -r '.exp // "unknown"' 2>/dev/null)

              echo "Subject: $sub"
              echo "Name: $name"

              echo "Tenant: $tenant"
              echo "Database: $database"
              echo "Access Level: $access"

              if [ "$iat" != "unknown" ] && [ "$iat" != "null" ]; then
                  iat_date=$(date -r "$iat" 2>/dev/null || echo 'unknown')
                  echo "Issued At: $iat_date"
              fi

              if [ "$exp" != "unknown" ] && [ "$exp" != "null" ]; then
                  echo "Expires At: $exp_date"
              fi

              echo
          else
              handle_output "$token_info" "$output_format" "json"
          fi
      else
          # Fallback without jq
          fallback_result='{"error": "jq required for token parsing", "raw_payload": "'"$decoded"'"}'

          if [[ "$output_format" == "text" ]]; then
              print_error "jq required for token parsing"
              echo "Raw payload: $decoded"
          else
              handle_output "$fallback_result" "$output_format" "json"
          fi
      fi
  else
      decode_error='{"error": "Failed to decode JWT token", "message": "Token may be malformed"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "Failed to decode JWT token"
          print_info "Token may be malformed"
      else
          handle_output "$decode_error" "$output_format" "json"
      fi
      exit 1
  fi
}

# :command.function
monk_auth_ping_command() {

  # src/auth_ping_command.sh
  #!/bin/bash

  # auth_ping_command.sh - Authenticated API health check with universal format support

  # Check dependencies
  check_dependencies

  # Get flags from bashly args
  verbose_flag="${args[--verbose]}"
  jwt_token_arg="${args[--jwt-token]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Set CLI_VERBOSE if flag is present

  if [ "$verbose_flag" = "1" ] || [ "$verbose_flag" = "true" ]; then
      CLI_VERBOSE=true
  fi

  # Make ping request
  base_url=$(get_base_url)

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Pinging server at: $base_url"
  fi

  # Prepare curl arguments
  curl_args=(-s -X GET -H "Content-Type: application/json")

  # Add JWT token (provided via -j flag or stored token)
  token_to_use="$jwt_token_arg"
  if [ -z "$token_to_use" ]; then
      token_to_use=$(get_jwt_token)
  fi

  if [ -n "$token_to_use" ]; then
      curl_args+=(-H "Authorization: Bearer $token_to_use")
      if [ "$CLI_VERBOSE" = "true" ]; then
          if [ -n "$jwt_token_arg" ]; then
              print_info "Using provided JWT token"
          else
              print_info "Using stored JWT token"
          fi
      fi
  fi

  # Make request
  full_url="${base_url}/ping"
  response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
  http_code=$(echo "$response" | tail -n1)
  response=$(echo "$response" | sed '$d')
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  # Handle response based on HTTP code
  case "$http_code" in
      200)
          # Success - build response JSON
          if [ "$JSON_PARSER" = "jq" ]; then
              ping_result=$(echo "$response" | jq --arg http_code "$http_code" \
                  --arg timestamp "$timestamp" \
                  --arg success "true" \
                  '. + {
                      http_code: ($http_code | tonumber),
                      timestamp: $timestamp,
                      success: ($success == "true"),
                      reachable: true
                  }')
          else
              # Fallback JSON
              ping_result='{"success": true, "reachable": true, "http_code": '"$http_code"', "timestamp": "'"$timestamp"'", "raw_response": "'"$response"'"}'
          fi

          if [[ "$output_format" == "text" ]]; then
              if [ "$CLI_VERBOSE" = "true" ]; then
                  print_success "Server is reachable (HTTP $http_code)"
                  echo "Response: $response"
              else
                  # Parse response for clean output
                  if [ "$JSON_PARSER" = "jq" ]; then
                      pong=$(echo "$response" | jq -r '.pong' 2>/dev/null || echo "unknown")
                      domain=$(echo "$response" | jq -r '.domain' 2>/dev/null || echo "null")
                      database=$(echo "$response" | jq -r '.database' 2>/dev/null || echo "null")

                      echo "pong: $pong"
                      if [ "$domain" != "null" ] && [ "$domain" != "" ]; then
                          echo "domain: $domain"
                      fi
                      if [ "$database" != "null" ] && [ "$database" != "" ]; then
                          if [ "$database" = "ok" ]; then
                              echo "database: $database"
                          else
                              echo "database: ERROR - $database"
                          fi
                      fi
                  else
                      echo "Response: $response"
                  fi
              fi
          else
              handle_output "$ping_result" "$output_format" "json"
          fi
          ;;
      401)
          # Unauthorized
          error_result=$(jq -n \
              --arg http_code "$http_code" \
              --arg timestamp "$timestamp" \
              --arg error "Authentication failed" \
              '{
                  success: false,
                  reachable: true,
                  http_code: ($http_code | tonumber),
                  timestamp: $timestamp,
                  error: $error,
                  message: "JWT token is invalid or expired"
              }')

          if [[ "$output_format" == "text" ]]; then
              print_error "Authentication failed (HTTP $http_code)"
              print_info "JWT token is invalid or expired"
              print_info "Use 'monk auth login TENANT USERNAME' to re-authenticate"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
          ;;
      *)
          # Other HTTP error
          error_result=$(jq -n \
              --arg http_code "$http_code" \
              --arg timestamp "$timestamp" \
              --arg response "$response" \
              '{
                  success: false,
                  reachable: (if ($http_code | tonumber) == 0 then false else true end),
                  http_code: ($http_code | tonumber),
                  timestamp: $timestamp,
                  error: "HTTP error",
                  response: $response
              }')

          if [[ "$output_format" == "text" ]]; then
              print_error "HTTP error ($http_code)"
              if [ "$CLI_VERBOSE" = "true" ]; then
                  echo "Response: $response"
              fi
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
          ;;
  esac
}

# :command.function
monk_auth_import_command() {

  # src/auth_import_command.sh
  #!/bin/bash

  # auth_import_command.sh - Import JWT token from external auth flow
  #
  # This command allows users to manually store JWT tokens obtained from external
  # authentication systems (OAuth, SSO, external tools, web UI, etc.) without
  # going through the standard login flow.
  #
  # Usage Examples:
  #   monk auth import tenant-a admin --token "eyJhbGciOiJIUzI1NiIs..."
  #   echo "eyJhbGciOiJIUzI1NiIs..." | monk auth import tenant-a admin
  #   cat jwt-token.txt | monk auth import my-tenant developer
  #
  # Input Methods:
  #   1. Via --token/-t flag: Direct token parameter
  #   2. Via stdin: Pipe token content (useful for scripting)
  #
  # Token Storage:
  #   - Stores in current server+tenant context in auth.json
  #   - Updates env.json with current tenant and user
  #   - Validates token format (basic JWT structure check)
  #   - Sets secure permissions on auth config file
  #
  # Use Cases:
  #   - OAuth/SSO authentication flows
  #   - External authentication tools
  #   - Token sharing between environments

  #   - Manual token management for automation
  #   - Development/testing with pre-generated tokens
  #
  # Requirements:
  #   - Current server must be selected (monk server use <name>)
  #   - Valid JWT token format (basic validation only)
  #   - Tenant and username must be specified

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  tenant="${args[tenant]}"
  username="${args[username]}"
  token_flag="${args[--token]}"

  print_info "Importing JWT token for tenant: $tenant, username: $username"

  # Get token from flag or stdin
  if [ -n "$token_flag" ]; then
      token="$token_flag"
      print_info "Using token from --token parameter"
  else
      # Read token from stdin
      token=$(cat)
      if [ -z "$token" ]; then
          print_error "No JWT token provided"
          print_info "Usage: monk auth import <tenant> <username> --token <jwt>"
          print_info "   or: echo '<jwt>' | monk auth import <tenant> <username>"
          exit 1
      fi
      print_info "Using token from stdin"
  fi

  # Basic JWT format validation (should have 3 parts separated by dots)
  if ! echo "$token" | grep -q '^[^.]*\.[^.]*\.[^.]*$'; then
      print_error "Invalid JWT token format"
      print_info "JWT tokens should have format: header.payload.signature"
      exit 1
  fi

  # Store the token using the same mechanism as login
  store_token "$token" "$tenant" "$username"

  print_success "JWT token imported successfully"
  print_info_always "Token stored for server+tenant context"

  # Show current context
  if [ "$CLI_VERBOSE" = "true" ]; then
      current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
      print_info "Context: server=$current_server, tenant=$tenant, user=$username"
  fi
}

# :command.function
monk_auth_expires_command() {

  # src/auth_expires_command.sh
  #!/bin/bash

  # auth_expires_command.sh - Show JWT token expiration time
  #
  # This command extracts and displays the expiration time from the current JWT token
  # in a human-readable format.
  #
  # Usage Examples:
  #   monk auth expires                    # Show expiration time
  #   monk auth expires > expiry.txt       # Save expiration to file
  #
  # Output Format:
  #   Displays the expiration date/time in local timezone
  #   Example: "Wed Aug 28 15:30:45 PDT 2025"
  #
  # Requirements:
  #   - Active authentication (JWT token available)
  #   - base64 command for JWT decoding
  #   - date command for timestamp formatting

  # Check dependencies
  check_dependencies

  token=$(get_jwt_token)

  if [ -z "$token" ]; then
      print_error "No authentication token found"
      print_info_always "Use 'monk auth login' or 'monk auth import' to authenticate"
      exit 1
  fi

  # Extract payload (second part) from JWT
  payload=$(echo "$token" | cut -d'.' -f2)

  # Add padding if needed for base64 decoding
  padding=$((4 - ${#payload} % 4))
  if [ $padding -ne 4 ]; then
      payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
  fi

  # Decode base64 payload
  if command -v base64 >/dev/null 2>&1; then
      decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
  else
      print_error "base64 command not found"
      exit 1
  fi

  if [ -n "$decoded" ]; then
      if command -v jq >/dev/null 2>&1; then
          exp_timestamp=$(echo "$decoded" | jq -r '.exp // empty' 2>/dev/null)
          if [ -n "$exp_timestamp" ] && [ "$exp_timestamp" != "null" ] && [ "$exp_timestamp" != "empty" ]; then
              exp_date=$(date -r "$exp_timestamp" 2>/dev/null || echo 'Invalid timestamp')
              echo "$exp_date"
          else
              print_error "No expiration timestamp found in JWT token"
              exit 1
          fi
      else
          print_error "jq required for JWT token parsing"
          exit 1
      fi
  else
      print_error "Failed to decode JWT token"
      exit 1
  fi
}

# :command.function
monk_auth_expired_command() {

  # src/auth_expired_command.sh
  #!/bin/bash

  # auth_expired_command.sh - Check if JWT token is expired (exit code based)
  #
  # This command checks if the current JWT token has expired and returns
  # appropriate exit codes for scripting and automation.
  #
  # Usage Examples:
  #   monk auth expired && echo "Token valid"
  #   if monk auth expired; then echo "Need to re-authenticate"; fi
  #   monk auth expired || monk auth login tenant user
  #
  # Exit Codes:
  #   0: Token is valid (not expired)
  #   1: Token is expired or no token found
  #   1: Error in token processing
  #
  # Output:
  #   Minimal output by design - primarily for scripting
  #   Use 'monk auth expires' for human-readable expiration time
  #
  # Requirements:
  #   - Active authentication (JWT token available)
  #   - base64 command for JWT decoding
  #   - date command for timestamp comparison

  # Check dependencies
  check_dependencies

  token=$(get_jwt_token)

  if [ -z "$token" ]; then
      # No token found
      exit 1
  fi

  # Extract payload (second part) from JWT
  payload=$(echo "$token" | cut -d'.' -f2)

  # Add padding if needed for base64 decoding
  padding=$((4 - ${#payload} % 4))
  if [ $padding -ne 4 ]; then
      payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
  fi

  # Decode base64 payload
  if command -v base64 >/dev/null 2>&1; then
      decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
  else
      # Can't decode - assume expired for safety
      exit 1
  fi

  if [ -n "$decoded" ]; then
      if command -v jq >/dev/null 2>&1; then
          exp_timestamp=$(echo "$decoded" | jq -r '.exp // empty' 2>/dev/null)
          if [ -n "$exp_timestamp" ] && [ "$exp_timestamp" != "null" ] && [ "$exp_timestamp" != "empty" ]; then
              current_timestamp=$(date +%s)

              if [ "$exp_timestamp" -gt "$current_timestamp" ]; then
                  # Token is still valid
                  exit 0
              else
                  # Token is expired
                  exit 1
              fi
          else
              # No expiration found - assume expired for safety
              exit 1
          fi
      else
          # No jq - can't parse - assume expired for safety
          exit 1
      fi
  else
      # Failed to decode - assume expired for safety
      exit 1
  fi
}

# :command.function
monk_data_select_command() {

  # src/data_select_command.sh
  #!/bin/bash

  # data_select_command.sh - Unified data selection with intelligent query routing
  #
  # This command handles all data selection scenarios:
  # 1. Direct ID selection for single records
  # 2. Default listing when no parameters provided

  # 3. Simple query parameters via --filter flag (limit, order, offset)
  # 4. Complex queries should use 'monk find' command directly
  #
  # Usage Examples:
  #   monk data select users 123                           # Get specific user by ID
  #   monk data select users                               # List all users (default)
  #   monk data select users --filter '{"limit": 10}'     # Limit results
  #   monk data select users --filter '{"order": "name asc"}'  # Sort by name
  #   monk data select users --filter '{"limit": 5, "offset": 10}'  # Pagination
  #
  # For complex queries with 'where' clauses, use:
  #   echo '{"where": {"status": "active"}}' | monk find users
  #
  # API Endpoints:
  #   GET /api/data/:schema/:id     (direct ID)
  #   GET /api/data/:schema         (default listing)
  #   GET /api/data/:schema?params  (with query string)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"
  filter_json="${args[--filter]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  if [ -n "$id" ]; then
      # Case 1: ID provided - direct record selection
      print_info "Selecting specific record: $id"
      response=$(make_request_json "GET" "/api/data/$schema/$id" "")
      handle_response_json "$response" "select"

  elif [ -n "$filter_json" ]; then
      # Case 2: Filter provided - parse and build query string
      print_info "Processing query filter for schema: $schema"

      # Check if this is a complex query that should use find command
      if has_complex_query "$filter_json"; then
          print_error "Complex queries with 'where' clauses should use 'monk find' command"
          print_info "Example: echo '$filter_json' | monk find $schema"
          exit 1
      fi

      # Build query string from filter parameters
      query_string=$(build_query_string "$filter_json")

      if [ -n "$query_string" ]; then
          print_info "Using query parameters: $query_string"
      else
          print_info "No valid query parameters found, using default selection"
      fi

      response=$(make_request_json "GET" "/api/data/$schema$query_string" "")
      handle_response_json "$response" "select"

  else
      # Case 3: No ID, no filter - default listing
      print_info "Selecting all records for schema: $schema"
      response=$(make_request_json "GET" "/api/data/$schema" "")
      handle_response_json "$response" "select"
  fi
}

# :command.function
monk_data_create_command() {

  # src/data_create_command.sh
  #!/bin/bash

  # data_create_command.sh - Create records with flexible input handling
  #
  # This command creates new records in a schema with intelligent array/object handling:
  # - Single object input → wraps in array for API → unwraps response to match input
  # - Array input → sends directly to API → returns array response

  #
  # Usage Examples:
  #   echo '{"name": "John", "email": "john@example.com"}' | monk data create users
  #   cat user.json | monk data create users
  #   echo '[{"name": "Alice"}, {"name": "Bob"}]' | monk data create users  # Bulk create
  #
  # Input/Output Behavior:
  #   Object in → Object out (single record creation)
  #   Array in → Array out (bulk record creation)

  #
  # API Endpoint:
  #   POST /api/data/:schema (always expects array, handles wrapping/unwrapping)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  # Read and validate JSON input
  json_data=$(read_and_validate_json_input "creating" "$schema")

  # Process the create operation (uses handle_response_json which now outputs compact JSON)
  process_data_operation "create" "POST" "$schema" "" "$json_data"
}

# :command.function
monk_data_update_command() {

  # src/data_update_command.sh
  #!/bin/bash

  # data_update_command.sh - Update records with flexible ID handling
  #
  # This command updates existing records with multiple input patterns:
  # - ID as parameter: uses object endpoint, removes ID from JSON payload
  # - ID extracted from JSON: uses object endpoint for single updates
  # - Array input: uses array endpoint for bulk updates
  #
  # Usage Examples:
  #   echo '{"name": "Updated Name"}' | monk data update users 123  # ID as param
  #   echo '{"id": 123, "name": "Updated Name"}' | monk data update users  # ID in JSON

  #   echo '[{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]' | monk data update users  # Bulk
  #
  # API Endpoints:
  #   PUT /api/data/:schema/:id  (single record - ID from parameter or extracted)
  #   PUT /api/data/:schema      (bulk update - array input)
  #
  # ID Handling:
  #   - Parameter ID takes precedence over JSON ID
  #   - JSON ID automatically extracted when parameter omitted
  #   - ID removed from payload for object endpoints (API requirement)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  # Read and validate JSON input
  json_data=$(read_and_validate_json_input "updating" "$schema")

  # Process the update operation
  process_data_operation "update" "PUT" "$schema" "$id" "$json_data"
}

# :command.function
monk_data_delete_command() {

  # src/data_delete_command.sh
  #!/bin/bash

  # data_delete_command.sh - Delete records with confirmation and flexible input
  #
  # This command deletes records with multiple input patterns and safety confirmations:
  # - Direct ID deletion with optional confirmation prompts

  # - ID extracted from JSON objects for scripted deletions
  # - Bulk deletion from array input
  #
  # Usage Examples:
  #   monk data delete users 123                           # Direct ID deletion
  #   echo '{"id": 123}' | monk data delete users         # ID from JSON
  #   echo '[{"id": 1}, {"id": 2}]' | monk data delete users  # Bulk deletion
  #
  # Safety Features:
  #   - Confirmation prompts in CLI_VERBOSE mode for destructive operations
  #   - Clear error messages when ID missing from both parameter and JSON
  #
  # API Endpoints:
  #   DELETE /api/data/:schema/:id  (single record deletion)

  #   DELETE /api/data/:schema      (bulk deletion from array)
  #
  # Input Requirements:
  #   - Either ID parameter OR JSON with 'id' field(s) required
  #   - No payload sent for single deletions (just endpoint)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  if [ -n "$id" ]; then
      # ID provided - direct delete, no stdin needed
      process_data_operation "delete" "DELETE" "$schema" "$id" "" "true"
  elif [ -t 0 ]; then
      # No ID and no stdin (terminal input) - error
      print_error "No ID provided and no JSON data on stdin"
      print_info "Usage: monk data delete $schema <id> OR provide JSON with 'id' field(s) via stdin"
      exit 1
  else
      # No ID but have stdin - read and process JSON data
      json_data=$(read_and_validate_json_input "deleting" "$schema")
      process_data_operation "delete" "DELETE" "$schema" "" "$json_data" "true"
  fi
}

# :command.function
monk_data_export_command() {

  # src/data_export_command.sh
  #!/bin/bash

  # data_export_command.sh - Export schema records to individual JSON files
  #
  # This command exports all records from a schema to separate JSON files in a directory.
  # Each record is saved as {record_id}.json with pretty-formatted JSON content.
  #
  # Usage Examples:
  #   monk data export users ./backup/users/              # Export to directory
  #   monk data export products /tmp/export-$(date +%Y%m%d)/  # Timestamped export
  #
  # Output Structure:
  #   - Creates target directory if it doesn't exist
  #   - One file per record: {directory}/{record_id}.json
  #   - Pretty-formatted JSON with 4-space indentation
  #   - Verbose progress reporting when CLI_VERBOSE=true
  #
  # Requirements:
  #   - Python3 required for JSON parsing and file operations
  #   - Records must have 'id' field for filename generation
  #   - Write permissions needed for target directory
  #
  # API Endpoint:
  #   GET /api/data/:schema (retrieves all records)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  directory="${args[dir]}"

  validate_schema "$schema"

  # Create directory if it doesn't exist
  if [ ! -d "$directory" ]; then
      print_info "Creating directory: $directory"
      mkdir -p "$directory"
  fi

  print_info "Exporting $schema records to: $directory"

  # Get all records using the API
  response=$(make_request_json "GET" "/api/data/$schema" "")

  # Check if jq is available (should be, since it's a hard dependency)
  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for export functionality"
      exit 1
  fi

  # Validate API response format
  if ! echo "$response" | jq -e '.success == true and .data' >/dev/null 2>&1; then
      print_error "Invalid API response format"
      echo "$response"
      exit 1
  fi

  # Export each record to individual JSON file
  count=0
  while IFS= read -r record; do
      # Extract ID from record
      id=$(echo "$record" | jq -r '.id // empty')

      if [ -z "$id" ] || [ "$id" = "null" ]; then
          print_warning "Skipping record without id field"
          continue
      fi

      # Write pretty-formatted JSON to file
      filename="$directory/$id.json"
      echo "$record" | jq '.' > "$filename"

      if [ $? -eq 0 ]; then
          print_info "Exported: $filename"
          count=$((count + 1))
      else
          print_error "Failed to write: $filename"
          exit 1
      fi

  done < <(echo "$response" | jq -c '.data[]')

  print_success "Successfully exported $count records to $directory"
}

# :command.function
monk_data_import_command() {

  # src/data_import_command.sh
  #!/bin/bash

  # data_import_command.sh - Bulk import JSON files as records
  #
  # This command imports multiple JSON files from a directory as records in a schema.
  # All .json files are collected into an array and sent in a single bulk API request.
  #
  # Usage Examples:
  #   monk data import users ./backup/users/              # Import from directory
  #   monk data import products /tmp/migration/           # Migration import
  #
  # Input Structure:
  #   - Scans directory for all *.json files
  #   - Each file should contain a valid JSON object (one record)
  #   - Files processed in sorted order by filename
  #   - All records combined into array for bulk import
  #
  # Requirements:
  #   - Python3 required for JSON parsing and file operations
  #   - Directory must exist and contain .json files
  #   - Each JSON file must be valid and represent one record
  #
  # API Endpoint:

  #   PUT /api/data/:schema (bulk import with array payload)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  directory="${args[dir]}"

  validate_schema "$schema"

  if [ ! -d "$directory" ]; then
      print_error "Directory does not exist: $directory"
      exit 1
  fi

  print_info "Importing $schema records from: $directory"

  # Check if jq is available (should be, since it's a hard dependency)
  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for import functionality"
      exit 1
  fi

  # Check for JSON files in directory
  json_files=("$directory"/*.json)

  # Check if glob found any files (if not, array contains the literal pattern)
  if [ ! -f "${json_files[0]}" ]; then
      print_error "No .json files found in directory: $directory"
      exit 1
  fi

  print_info "Found ${#json_files[@]} JSON files to import"

  # Collect all JSON files into an array using jq
  records_json=$(jq -n --slurpfile records <(cat "${json_files[@]}") '$records')

  if [ -z "$records_json" ] || [ "$records_json" = "null" ]; then
      print_error "Failed to process JSON files"
      exit 1
  fi

  # Validate each file was valid JSON (jq would have failed above if not)
  count=0
  for file in "${json_files[@]}"; do
      filename=$(basename "$file")
      print_info "Loaded: $filename"
      count=$((count + 1))
  done

  print_info "Prepared $count records for import"

  # Make bulk import request
  response=$(make_request_json "PUT" "/api/data/$schema" "$records_json")

  print_success "Import completed successfully"
  handle_response_json "$response" "import"
}

# :command.function
monk_meta_select_command() {

  # src/meta_select_command.sh
  #!/bin/bash

  # meta_select_command.sh - Retrieve specific schema definition

  #
  # This command retrieves the complete YAML schema definition for a named schema.
  # Returns the full schema specification including validation rules, properties, and metadata.
  #
  # Usage Examples:
  #   monk meta select schema users           # Get users schema definition
  #   monk meta select schema products > products.yaml  # Save schema to file
  #
  # Output Format:
  #   - Returns complete YAML schema definition
  #   - Includes JSON Schema validation rules, properties, required fields
  #   - Contains metadata like title, description, and custom attributes
  #
  # API Endpoint:
  #   GET /api/meta/schema/:name (returns YAML content)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  type="${args[type]}"
  name="${args[name]}"

  # Meta commands only support YAML format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for meta operations"
      print_info "Meta operations work with YAML schema definitions"
      exit 1
  fi

  if [[ "${args[--json]}" == "1" ]]; then
      print_error "The --json option is not supported for meta operations"
      print_info "Meta operations work with YAML schema definitions"
      exit 1
  fi

  # Validate metadata type (currently only schema supported)
  case "$type" in
      schema)
          # Valid type
          ;;
      *)
          print_error "Unsupported metadata type: $type"
          print_info "Currently supported types: schema"
          exit 1
          ;;
  esac

  print_info "Selecting $type object: $name"

  response=$(make_request_yaml "GET" "/api/meta/$type/$name" "")
  handle_response_yaml "$response" "select"
}

# :command.function
monk_meta_create_command() {

  # src/meta_create_command.sh
  #!/bin/bash

  # meta_create_command.sh - Create new schema from YAML definition
  #
  # This command creates a new schema in the database from a YAML schema definition.
  # The schema definition includes JSON Schema validation rules and generates database DDL.
  #
  # Usage Examples:
  #   cat users.yaml | monk meta create schema           # Create from file
  #   echo "name: test..." | monk meta create schema     # Create from inline YAML
  #
  # Input Format:
  #   - YAML schema definition via stdin
  #   - Must include 'name' field for schema identification

  #   - Supports full JSON Schema specification (type, properties, required, etc.)
  #   - Optional metadata (title, description)
  #
  # Schema Processing:
  #   - Validates YAML syntax and schema structure
  #   - Generates PostgreSQL table DDL automatically
  #   - Creates schema cache entry for performance
  #   - Prevents modification of system schemas
  #
  # API Endpoint:
  #   POST /api/meta/schema (Content-Type: application/yaml)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  type="${args[type]}"

  # Meta commands only support YAML format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for meta operations"
      print_info "Meta operations work with YAML schema definitions"
      exit 1
  fi

  if [[ "${args[--json]}" == "1" ]]; then
      print_error "The --json option is not supported for meta operations"
      print_info "Meta operations work with YAML schema definitions"
      exit 1
  fi

  # Validate metadata type (currently only schema supported)
  case "$type" in
      schema)
          # Valid type
          ;;
      *)
          print_error "Unsupported metadata type: $type"
          print_info "Currently supported types: schema"
          exit 1
          ;;
  esac

  # Read YAML data from stdin
  data=$(cat)

  if [ -z "$data" ]; then
      print_error "No YAML data provided on stdin"
      print_info "Usage: cat schema.yaml | monk meta create schema"
      exit 1
  fi

  print_info "Creating $type with YAML data:"
  if [ "$CLI_VERBOSE" = "true" ]; then
      echo "$data" | sed 's/^/  /'
  fi

  response=$(make_request_yaml "POST" "/api/meta/$type" "$data")
  handle_response_yaml "$response" "create"
}

# :command.function
monk_meta_update_command() {

  # src/meta_update_command.sh
  #!/bin/bash

  # meta_update_command.sh - Update existing schema with new YAML definition
  #
  # This command updates an existing schema with a new YAML definition.
  # Automatically handles database DDL changes and schema cache invalidation.
  #
  # Usage Examples:
  #   cat updated-users.yaml | monk meta update schema users    # Update from file
  #   echo "name: users..." | monk meta update schema users     # Update with inline YAML
  #
  # Input Format:
  #   - YAML schema definition via stdin
  #   - Schema name must match existing schema or be provided in YAML 'name' field
  #   - Full JSON Schema specification supported
  #
  # Update Process:
  #   - Validates new schema definition
  #   - Compares with existing schema for compatibility
  #   - Updates PostgreSQL table DDL (ADD/DROP columns as needed)
  #   - Invalidates and regenerates schema cache
  #   - Preserves existing data where possible
  #
  # Safety Features:
  #   - System schemas cannot be updated
  #   - Destructive changes require data migration planning
  #
  # API Endpoint:
  #   PUT /api/meta/schema/:name (Content-Type: application/yaml)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  type="${args[type]}"
  name="${args[name]}"

  # Meta commands only support YAML format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for meta operations"
      print_info "Meta operations work with YAML schema definitions"
      exit 1
  fi

  if [[ "${args[--json]}" == "1" ]]; then
      print_error "The --json option is not supported for meta operations"
      print_info "Meta operations work with YAML schema definitions"
      exit 1
  fi

  # Validate metadata type (currently only schema supported)
  case "$type" in
      schema)
          # Valid type
          ;;
      *)
          print_error "Unsupported metadata type: $type"
          print_info "Currently supported types: schema"
          exit 1
          ;;
  esac

  # Read YAML data from stdin
  data=$(cat)

  if [ -z "$data" ]; then
      print_error "No YAML data provided on stdin"
      print_info "Usage: cat schema.yaml | monk meta update schema <name>"
      exit 1
  fi

  print_info "Updating $type '$name' with YAML data:"
  if [ "$CLI_VERBOSE" = "true" ]; then
      echo "$data" | sed 's/^/  /'
  fi

  response=$(make_request_yaml "PUT" "/api/meta/$type/$name" "$data")
  handle_response_yaml "$response" "update"
}

# :command.function
monk_meta_delete_command() {

  # src/meta_delete_command.sh
  #!/bin/bash

  # meta_delete_command.sh - Soft delete schema and associated table
  #
  # This command soft deletes a schema definition and its associated database table.
  # Uses soft deletion to preserve data while hiding the schema from normal operations.
  #
  # Usage Examples:
  #   monk meta delete schema test-schema     # Delete test schema
  #   CLI_VERBOSE=true monk meta delete schema users  # With confirmation prompt
  #
  # Deletion Process:
  #   - Soft deletes schema definition (can be restored)
  #   - Marks database table as deleted (preserves data)
  #   - Removes from schema cache
  #   - Hides from schema listing operations
  #
  # Safety Features:
  #   - Confirmation prompt in verbose mode
  #   - System schemas cannot be deleted
  #   - Soft deletion allows data recovery
  #   - All associated records remain intact but inaccessible
  #
  # Recovery:
  #   - Schema can be restored via direct database operations
  #   - Data remains in PostgreSQL table with soft-delete marker
  #
  # API Endpoint:
  #   DELETE /api/meta/schema/:name

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  type="${args[type]}"
  name="${args[name]}"

  # Meta commands only support YAML format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for meta operations"
      print_info "Meta operations work with YAML schema definitions"
      exit 1
  fi

  if [[ "${args[--json]}" == "1" ]]; then
      print_error "The --json option is not supported for meta operations"
      print_info "Meta operations work with YAML schema definitions"
      exit 1
  fi

  # Validate metadata type (currently only schema supported)
  case "$type" in
      schema)
          # Valid type
          ;;
      *)
          print_error "Unsupported metadata type: $type"
          print_info "Currently supported types: schema"
          exit 1
          ;;
  esac

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_warning "Are you sure you want to delete $type '$name'? (y/N)"
      read -r confirmation

      if ! echo "$confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
          print_info "Operation cancelled"
          exit 0
      fi
  fi

  response=$(make_request_yaml "DELETE" "/api/meta/$type/$name" "")
  handle_response_yaml "$response" "delete"
}

# :command.function
monk_bulk_raw_command() {

  # src/bulk_raw_command.sh
  #!/bin/bash

  # bulk_raw_command.sh - Execute bulk operations immediately (synchronous)
  #
  # This command executes an array of bulk operations in a single API transaction.
  # All operations are processed sequentially and results returned immediately.
  #
  # Usage Examples:
  #   cat operations.json | monk bulk raw
  #   echo '[{"operation": "create", "schema": "users", "data": {...}}]' | monk bulk raw
  #
  # Input Format - Array of operation objects:
  #   [
  #     {
  #       "operation": "create",        // Required: operation type
  #       "schema": "users",            // Required: schema name
  #       "data": {"name": "Alice"},    // Optional: record data
  #       "id": "123",                  // Optional: record ID
  #       "filter": {"status": "active"}, // Optional: filter criteria
  #       "message": "Custom error"     // Optional: custom error message
  #     }
  #   ]
  #
  # Supported Operations:
  #   Read: select, select-all, select-one, select-404, count
  #   Write: create, create-one, create-all, update, update-one, update-all, update-any, update-404
  #   Write: delete, delete-one, delete-all, delete-any, delete-404
  #   Access: access, access-one, access-all, access-any, access-404
  #   (upsert operations not yet implemented in API)
  #
  # Output Format:
  #   Returns same array with 'result' field added to each operation containing the operation outcome
  #
  # API Endpoint:
  #   POST /api/bulk (with operations array)
  #
  # Future Extensions:
  #   This 'raw' command provides immediate execution. Future async commands:
  #   - monk bulk submit (get operation ID)
  #   - monk bulk status <id> (check progress)

  #   - monk bulk result <id> (download results)

  # Check dependencies
  check_dependencies

  # Read and validate JSON input
  json_data=$(read_and_validate_json_input "executing bulk operations" "multiple schemas")

  # Validate that input is an array
  input_type=$(detect_input_type "$json_data")

  if [ "$input_type" != "array" ]; then
      print_error "Bulk operations require an array of operation objects"
      print_info "Usage: cat operations.json | monk bulk raw"
      print_info "Expected format: [{\"operation\": \"create\", \"schema\": \"users\", \"data\": {...}}]"
      exit 1
  fi

  # Validate basic structure of operations (best effort)
  if [ "$JSON_PARSER" = "jq" ]; then
      # Check that all items have required operation and schema fields
      missing_fields=$(echo "$json_data" | jq -r '.[] | select(.operation == null or .schema == null) | "missing operation or schema"' 2>/dev/null)

      if [ -n "$missing_fields" ]; then
          print_error "One or more operations missing required 'operation' and 'schema' fields"
          exit 1
      fi

      # Count operations for user feedback
      op_count=$(echo "$json_data" | jq 'length' 2>/dev/null || echo "unknown")
      print_info "Executing $op_count bulk operations"
  fi

  # Execute bulk operations via API
  response=$(make_request_json "POST" "/api/bulk" "$json_data")

  # Handle response - return full operations array with results
  handle_response_json "$response" "bulk"
}

# :command.function
monk_bulk_submit_command() {

  # src/bulk_submit_command.sh
  #!/bin/bash

  # bulk_submit_command.sh - Submit bulk operations for async processing (FUTURE FEATURE)
  #
  # This command will submit bulk operations to a background processing queue
  # and return an operation ID for tracking progress and retrieving results.
  #
  # Planned Usage:
  #   cat large-operations.json | monk bulk submit
  #   # Returns: {"operation_id": "bulk-12345", "status": "submitted", "count": 1000}
  #
  # Input Format:
  #   Same as 'bulk raw' - array of operation objects with operation, schema, data, etc.
  #   Designed for large operation sets that would timeout in synchronous mode
  #
  # Planned API Endpoints:
  #   POST /api/bulk/async/submit → Returns operation ID
  #   Implementation requires:
  #   - Background job queue (Redis/database)
  #   - Operation progress tracking
  #   - Result storage and retrieval system
  #   - Timeout and retry handling
  #
  # Related Commands:
  #   monk bulk status <id>   # Check processing progress
  #   monk bulk result <id>   # Download completed results

  #   monk bulk cancel <id>   # Cancel pending operations
  #
  # Current Status: NOT IMPLEMENTED
  # API backend does not yet support async bulk operations

  # Check dependencies
  check_dependencies

  print_error "Async bulk operations not yet implemented"
  print_info "Use 'monk bulk raw' for immediate synchronous execution"
  print_info "Async bulk processing (submit/status/result) is planned for future release"
  exit 1
}

# :command.function
monk_bulk_status_command() {

  # src/bulk_status_command.sh
  #!/bin/bash

  # bulk_status_command.sh - Check status of async bulk operation (FUTURE FEATURE)
  #
  # This command will check the processing status of a submitted bulk operation
  # and return progress information, estimated completion time, and current state.
  #
  # Planned Usage:
  #   monk bulk status bulk-12345
  #   # Returns: {"operation_id": "bulk-12345", "status": "processing", "progress": "450/1000", "eta": "2min"}
  #
  # Status States:
  #   - submitted: Operation queued, waiting to start
  #   - processing: Currently executing operations

  #   - completed: All operations finished successfully
  #   - failed: Operation failed with errors
  #   - cancelled: Operation was cancelled by user
  #
  # Progress Information:
  #   - Total operation count and completed count
  #   - Estimated time remaining based on current throughput
  #   - Success/error breakdown for completed operations
  #   - Current operation being processed
  #
  # Planned API Endpoint:
  #   GET /api/bulk/async/status/:operation_id
  #   Implementation requires:
  #   - Operation progress tracking in database/cache
  #   - Real-time status updates from background workers
  #   - Performance metrics for ETA calculations
  #
  # Error Handling:
  #   - Invalid operation ID returns appropriate error
  #   - Expired/cleaned up operations handled gracefully
  #
  # Current Status: NOT IMPLEMENTED
  # API backend does not yet support async bulk operations

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  operation_id="${args[operation_id]}"

  print_error "Async bulk status checking not yet implemented"
  print_info "Operation ID would be: $operation_id"
  print_info "Use 'monk bulk raw' for immediate synchronous execution"
  print_info "Async bulk processing (submit/status/result) is planned for future release"
  exit 1
}

# :command.function
monk_bulk_result_command() {

  # src/bulk_result_command.sh
  #!/bin/bash

  # bulk_result_command.sh - Download results of completed bulk operation (FUTURE FEATURE)
  #
  # This command will download the complete results of a finished bulk operation,
  # including all operation outcomes, errors, and generated data.
  #
  # Planned Usage:
  #   monk bulk result bulk-12345
  #   monk bulk result bulk-12345 > results.json    # Save to file
  #   monk bulk result bulk-12345 --errors-only     # Only failed operations
  #
  # Result Format:
  #   Returns the original operations array with 'result' field populated for each operation:
  #   [
  #     {
  #       "operation": "create",
  #       "schema": "users",

  #       "data": {"name": "Alice"},
  #       "result": {"id": "user-789", "status": "success"}
  #     },
  #     {
  #       "operation": "update",
  #       "schema": "users",
  #       "id": "123",

  #       "data": {"name": "Updated"},
  #       "result": {"error": "Record not found", "status": "failed"}
  #     }
  #   ]
  #
  # Result Processing:
  #   - Full operation audit trail with success/failure status
  #   - Generated IDs for successful create operations
  #   - Detailed error messages for failed operations
  #   - Performance metrics (execution time, throughput)
  #   - Data integrity validation results
  #
  # Planned API Endpoint:
  #   GET /api/bulk/async/result/:operation_id
  #   Implementation requires:
  #   - Result storage system (database/file storage)
  #   - Result cleanup policies (TTL, size limits)
  #   - Streaming download for large result sets
  #
  # Error Handling:
  #   - Invalid operation ID returns appropriate error
  #   - Results not yet ready returns status information
  #   - Expired results handled with cleanup notification
  #
  # Current Status: NOT IMPLEMENTED
  # API backend does not yet support async bulk operations

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  operation_id="${args[operation_id]}"

  print_error "Async bulk result download not yet implemented"
  print_info "Operation ID would be: $operation_id"
  print_info "Use 'monk bulk raw' for immediate synchronous execution with results"
  print_info "Async bulk processing (submit/status/result) is planned for future release"
  exit 1
}

# :command.function
monk_bulk_cancel_command() {

  # src/bulk_cancel_command.sh
  #!/bin/bash

  # bulk_cancel_command.sh - Cancel pending bulk operation (FUTURE FEATURE)
  #
  # This command will cancel a pending or in-progress bulk operation before completion,
  # allowing users to abort long-running batch processes when needed.
  #
  # Planned Usage:
  #   monk bulk cancel bulk-12345
  #   monk bulk cancel bulk-12345 --force    # Force cancel even if partially completed
  #
  # Cancellation Behavior:
  #   - submitted/queued operations: Immediately cancelled, no operations executed
  #   - processing operations: Graceful shutdown after current operation completes
  #   - completed operations: Cannot be cancelled, returns appropriate error
  #   - failed operations: Marks as cancelled instead of failed for clarity
  #
  # Cancellation Results:
  #   Returns summary of cancellation:
  #   {
  #     "operation_id": "bulk-12345",
  #     "status": "cancelled",
  #     "operations_completed": 150,
  #     "operations_cancelled": 850,
  #     "partial_results_available": true
  #   }
  #
  # Safety Features:
  #   - Confirmation prompt for operations with completed results
  #   - Partial results preserved and downloadable
  #   - Graceful shutdown prevents data corruption
  #   - Audit trail maintained for cancelled operations
  #
  # Planned API Endpoint:
  #   DELETE /api/bulk/async/:operation_id
  #   Implementation requires:
  #   - Background worker cancellation support
  #   - Partial result preservation
  #   - Operation state management
  #   - Cleanup of cancelled operation resources
  #
  # Edge Cases:
  #   - Operations that cannot be safely cancelled (mid-transaction)
  #   - Already completed operations (no-op with status info)
  #   - Invalid operation IDs handled gracefully
  #
  # Current Status: NOT IMPLEMENTED
  # API backend does not yet support async bulk operations

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  operation_id="${args[operation_id]}"

  print_error "Async bulk cancellation not yet implemented"
  print_info "Operation ID would be: $operation_id"
  print_info "Currently, only synchronous 'monk bulk raw' operations are supported"
  print_info "Async bulk processing (submit/status/result/cancel) is planned for future release"
  exit 1
}

# :command.function
monk_fs_ls_command() {

  # src/fs_ls_command.sh
  #!/bin/bash

  # fs_ls_command.sh - List directory contents with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  long_flag="${args[--long]}"
  tenant_flag="${args[--tenant]}"

  print_info "Listing directory: $path"

  # Build FTP options
  long_format="false"
  if [ "$long_flag" = "true" ]; then
      long_format="true"
  fi

  ftp_options=$(jq -n \
      --argjson long_format "$long_format" \
      '{
          "show_hidden": false,
          "recursive": false,
          "long_format": $long_format
      }')

  # Make request with tenant routing
  response=$(make_ftp_request_with_routing "list" "$path" "$ftp_options" "$tenant_flag")

  # Extract and format entries
  entries=$(process_ftp_response "$response" "data")
  format_ls_output "$entries"
}

# :command.function
monk_fs_cat_command() {

  # src/fs_cat_command.sh
  #!/bin/bash

  # fs_cat_command.sh - Display file content with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  tenant_flag="${args[--tenant]}"

  print_info "Reading file content: $path"

  # Make request with tenant routing
  response=$(make_ftp_request_with_routing "retrieve" "$path" "" "$tenant_flag")

  # Extract and display content
  content=$(process_ftp_response "$response" "content")

  if [ -n "$content" ] && [ "$content" != "null" ]; then
      # Pretty print JSON objects, show raw for simple values
      echo "$content" | jq . 2>/dev/null || echo "$content" | jq -r .
  else
      print_error "No content found for path: $path"
      exit 1
  fi
}

# :command.function
monk_fs_rm_command() {

  # src/fs_rm_command.sh
  #!/bin/bash

  # fs_rm_command.sh - Remove files with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  force_flag="${args[--force]}"
  tenant_flag="${args[--tenant]}"

  print_info "Removing: $path"

  # Build FTP options based on flags
  permanent="false"
  if [ "$force_flag" = "true" ]; then
      permanent="true"
      print_warning "Permanent deletion requested (not recoverable)"
  else
      print_info "Using soft delete (recoverable)"
  fi

  ftp_options=$(jq -n \
      --argjson permanent "$permanent" \
      '{
          "permanent": $permanent,
          "atomic": true,
          "force": false
      }')

  # Confirmation prompt for destructive operations
  if [ "$force_flag" = "true" ] && [ "$CLI_VERBOSE" = "true" ]; then
      print_warning "Are you sure you want to permanently delete: $path? (y/N)"
      read -r confirmation

      if ! echo "$confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
          print_info_always "Operation cancelled"
          exit 0
      fi
  fi

  # Make request with tenant routing
  response=$(make_ftp_request_with_routing "delete" "$path" "$ftp_options" "$tenant_flag")

  # Process deletion result
  if [ "$permanent" = "true" ]; then
      print_success "Permanently deleted: $path"
  else
      print_success "Soft deleted: $path (recoverable)"
  fi
}

# :command.function
monk_fs_stat_command() {

  # src/fs_stat_command.sh
  #!/bin/bash

  # fs_stat_command.sh - Display detailed status with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly

  path="${args[path]}"
  tenant_flag="${args[--tenant]}"

  print_info "Getting status for: $path"

  # Make request with tenant routing
  response=$(make_ftp_request_with_routing "stat" "$path" "" "$tenant_flag")

  # Extract basic information
  file_type=$(process_ftp_response "$response" "type")
  permissions=$(process_ftp_response "$response" "permissions")
  size=$(process_ftp_response "$response" "size")
  modified_time=$(process_ftp_response "$response" "modified_time")

  # Display basic stat information
  echo "  File: '$path'"
  echo "  Type: $file_type"
  echo "  Permissions: $permissions"

  echo "  Size: $size bytes"

  # Format and display timestamps
  if [ -n "$modified_time" ] && [ "$modified_time" != "null" ] && [ ${#modified_time} -eq 14 ]; then
      formatted_time=$(date -j -f "%Y%m%d%H%M%S" "$modified_time" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$modified_time")
      echo "Modified: $formatted_time"
  fi

  # Show record information if available
  record_info=$(process_ftp_response "$response" "record_info")
  if [ -n "$record_info" ] && [ "$record_info" != "null" ]; then
      echo
      echo "Record Information:"

      schema=$(echo "$record_info" | jq -r '.schema // "unknown"' 2>/dev/null)
      soft_deleted=$(echo "$record_info" | jq -r '.soft_deleted // false' 2>/dev/null)

      echo "  Schema: $schema"
      echo "  Soft Deleted: $soft_deleted"

      # Show access permissions if available
      access_perms=$(echo "$record_info" | jq -r '.access_permissions[]?' 2>/dev/null | tr '\n' ',' | sed 's/,$//')
      if [ -n "$access_perms" ]; then
          echo "  Access: $access_perms"
      fi
  fi

  # Show children count for directories
  children_count=$(process_ftp_response "$response" "children_count")
  if [ -n "$children_count" ] && [ "$children_count" != "null" ]; then
      echo
      echo "Directory contains: $children_count entries"
  fi
}

# :command.function
monk_find_command() {

  # src/find_command.sh
  #!/bin/bash

  # find_command.sh - Advanced search with enterprise Filter DSL
  #
  # This command performs complex searches using the enterprise Filter DSL with support
  # for advanced filtering, nested queries, and result limiting options.
  #
  # Usage Examples:
  #   echo '{"where": {"name": {"$like": "john*"}}}' | monk find users
  #   echo '{"where": {"age": {"$gt": 25}}, "limit": 10}' | monk find users
  #   echo '{"where": {"$and": [{"status": "active"}, {"role": "admin"}]}}' | monk find users --head
  #   cat complex-query.json | monk find documents --tail
  #
  # Filter DSL Support:
  #   - Comparison operators: $eq, $ne, $gt, $gte, $lt, $lte
  #   - Array operators: $in, $nin, $any, $nany

  #   - Pattern matching: $like, $ilike (case-insensitive)
  #   - Logical operators: $and, $or, $not
  #   - Range operators: $between
  #   - Nested object queries and complex expressions
  #
  # Output Options:
  #   --head/-H: Return only the first record from results
  #   --tail/-T: Return only the last record from results
  #   (default): Return all matching records
  #
  # API Endpoint:
  #   POST /api/find/:schema (with Filter DSL JSON payload)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  head_flag="${args[--head]}"
  tail_flag="${args[--tail]}"

  validate_schema "$schema"

  # Read and validate JSON input (Filter DSL)
  json_data=$(read_and_validate_json_input "searching" "$schema")

  # Make the find request
  response=$(make_request_json "POST" "/api/find/$schema" "$json_data")

  # Process response with head/tail support
  if [ "$head_flag" = "true" ]; then
      # Extract first record from array
      print_info "Returning first record only"
      if [ "$JSON_PARSER" = "jq" ]; then
          if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
              first_record=$(echo "$response" | jq '.data[0] // null')
              echo "$response" | jq --argjson first "$first_record" '{"success": .success, "data": $first}'
          else
              echo "$response"
          fi
      else
          # Fallback for jshon or no parser
          if echo "$response" | grep -q '"success":true'; then
              first_record=$(echo "$response" | jshon -e data -e 0 2>/dev/null || echo "null")
              if [ "$first_record" != "null" ]; then
                  echo "{\"success\":true,\"data\":$first_record}"
              else
                  echo '{"success":true,"data":null}'
              fi
          else
              echo "$response"
          fi
      fi
  elif [ "$tail_flag" = "true" ]; then
      # Extract last record from array
      print_info "Returning last record only"
      if [ "$JSON_PARSER" = "jq" ]; then
          if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
              last_record=$(echo "$response" | jq '.data[-1] // null')
              echo "$response" | jq --argjson last "$last_record" '{"success": .success, "data": $last}'
          else
              echo "$response"
          fi
      else
          # Fallback for jshon or no parser
          if echo "$response" | grep -q '"success":true'; then
              array_length=$(echo "$response" | jshon -e data -l 2>/dev/null || echo "0")
              if [ "$array_length" -gt 0 ]; then
                  last_index=$((array_length - 1))
                  last_record=$(echo "$response" | jshon -e data -e "$last_index" 2>/dev/null || echo "null")
                  echo "{\"success\":true,\"data\":$last_record}"
              else
                  echo '{"success":true,"data":null}'
              fi
          else
              echo "$response"
          fi
      fi
  else
      # Use standard response handler
      handle_response_json "$response" "find"
  fi
}

# :command.function
monk_root_tenant_list_command() {

  # src/root_tenant_list_command.sh
  #!/bin/bash

  # root_tenant_list_command.sh - List all tenants via /api/root/tenant

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  include_trashed="${args[--include-trashed]}"
  include_deleted="${args[--include-deleted]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Build query parameters
  params=""
  [[ "$include_trashed" == "1" ]] && params="?include_trashed=true"
  [[ "$include_deleted" == "1" ]] && params="${params:+${params}&}include_deleted=true"

  # Make request to root API
  endpoint="tenant${params}"
  response=$(make_root_request "GET" "$endpoint" "")

  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      if [[ "$output_format" == "text" ]]; then
          # Human-readable table output using existing function
          tenants=$(echo "$response" | jq -r '.tenants')
          format_tenant_table "$tenants" "$include_trashed" "$include_deleted"
      else
          # JSON output - pass through as compact JSON
          handle_output "$response" "$output_format" "json"
      fi
  else
      print_error "Failed to retrieve tenants"
      echo "$response" >&2
      exit 1
  fi
}

# :command.function
monk_root_tenant_create_command() {

  # src/root_tenant_create_command.sh
  #!/bin/bash

  # root_tenant_create_command.sh - Create new tenant via /api/root/tenant

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"
  host="${args[--host]:-localhost}"
  force="${args[--force]}"

  # Create JSON payload
  payload=$(jq -n --arg name "$name" --arg host "$host" '{name: $name, host: $host}')

  # Check if tenant exists (unless force flag used)
  if [[ "$force" != "1" ]]; then
      # Use curl directly for existence check to avoid set -e issues
      base_url=$(get_base_url)
      local encoded_name=$(url_encode "$name")
      existing=$(curl -s "${base_url}/api/root/tenant/${encoded_name}" 2>/dev/null)

      if echo "$existing" | jq -e '.success and .tenant' >/dev/null 2>&1; then
          print_error "Tenant '$name' already exists. Use --force to override."
          exit 1
      fi
  fi

  print_info "Creating tenant with payload: $payload"

  # Make create request
  response=$(make_root_request "POST" "tenant" "$payload")

  # Handle response
  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      # API now returns tenant as object
      tenant=$(echo "$response" | jq -r '.tenant')
      tenant_name=$(echo "$tenant" | jq -r '.name')
      database=$(echo "$tenant" | jq -r '.database')
      tenant_host=$(echo "$tenant" | jq -r '.host')

      print_success "Tenant '$tenant_name' created successfully"
      print_info "Database: $database"
      print_info "Host: $tenant_host"
  else
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Failed to create tenant: $error_msg"
      exit 1
  fi
}

# :command.function
monk_root_tenant_show_command() {

  # src/root_tenant_show_command.sh
  #!/bin/bash

  # root_tenant_show_command.sh - Show tenant details via /api/root/tenant/:name

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Make request to get tenant details
  response=$(make_root_request "GET" "tenant/${name}" "")

  if echo "$response" | jq -e '.success and .tenant' >/dev/null 2>&1; then
      if [[ "$output_format" == "text" ]]; then
          # Human-readable output
          tenant=$(echo "$response" | jq -r '.tenant')

          echo
          print_info "Tenant Details: $name"
          echo

          # Extract and display fields
          tenant_name=$(echo "$tenant" | jq -r '.name')
          database=$(echo "$tenant" | jq -r '.database')
          host=$(echo "$tenant" | jq -r '.host')
          status=$(echo "$tenant" | jq -r '.status')
          created_at=$(echo "$tenant" | jq -r '.created_at')
          updated_at=$(echo "$tenant" | jq -r '.updated_at')
          trashed_at=$(echo "$tenant" | jq -r '.trashed_at // "null"')

          printf "%-15s %s\n" "Name:" "$tenant_name"
          printf "%-15s %s\n" "Database:" "$database"
          printf "%-15s %s\n" "Host:" "$host"
          printf "%-15s %s\n" "Status:" "$status"
          printf "%-15s %s\n" "Created:" "$(echo "$created_at" | cut -d'T' -f1)"
          printf "%-15s %s\n" "Updated:" "$(echo "$updated_at" | cut -d'T' -f1)"

          if [[ "$trashed_at" != "null" ]]; then
              printf "%-15s %s\n" "Trashed:" "$(echo "$trashed_at" | cut -d'T' -f1)"
          fi

          echo
      else
          # JSON output - compact format
          handle_output "$response" "$output_format" "json"
      fi
  else
      error_msg=$(echo "$response" | jq -r '.error // "Tenant not found"')
      print_error "$error_msg"
      exit 1
  fi
}

# :command.function
monk_root_tenant_trash_command() {

  # src/root_tenant_trash_command.sh
  #!/bin/bash

  # root_tenant_trash_command.sh - Soft delete tenant via /api/root/tenant/:name

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Confirmation prompt
  confirm_destructive_operation "soft delete tenant" "$name" "0"

  # Make soft delete request (DELETE without force parameter)
  response=$(make_root_request "DELETE" "tenant/${name}" "")

  # Handle response
  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      print_success "Tenant '$name' moved to trash"
      print_info "Use 'monk root tenant restore $name' to restore"
  else
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Failed to trash tenant: $error_msg"
      exit 1
  fi
}

# :command.function
monk_root_tenant_restore_command() {

  # src/root_tenant_restore_command.sh
  #!/bin/bash

  # root_tenant_restore_command.sh - Restore soft deleted tenant via /api/root/tenant/:name

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Make restore request (PUT to clear trashed_at)
  response=$(make_root_request "PUT" "tenant/${name}" "")

  # Handle response
  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      print_success "Tenant '$name' restored from trash"
  else
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Failed to restore tenant: $error_msg"
      exit 1
  fi
}

# :command.function
monk_root_tenant_delete_command() {

  # src/root_tenant_delete_command.sh
  #!/bin/bash

  # root_tenant_delete_command.sh - Hard delete tenant via /api/root/tenant/:name?force=true

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"
  force_flag="${args[--force]}"

  # Confirmation prompt (unless --force used)
  confirm_destructive_operation "PERMANENTLY delete tenant and database" "$name" "$force_flag" "DELETE"

  # Make hard delete request (DELETE with force=true parameter)
  # Handle query parameter separately from URL encoding
  base_url=$(get_base_url)
  encoded_name=$(url_encode "$name")
  response=$(curl -s -X DELETE "${base_url}/api/root/tenant/${encoded_name}?force=true")

  # Handle response
  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      print_success "Tenant '$name' permanently deleted"
      print_warning "Database and all data have been removed"
  else
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Failed to delete tenant: $error_msg"
      exit 1
  fi
}

# :command.function
monk_root_tenant_health_command() {

  # src/root_tenant_health_command.sh
  #!/bin/bash

  # root_tenant_health_command.sh - Check tenant database health via /api/root/tenant/:name/health

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Make health check request
  response=$(make_root_request "GET" "tenant/${name}/health" "")

  if echo "$response" | jq -e '.success and .health' >/dev/null 2>&1; then
      if [[ "$output_format" == "text" ]]; then
          # Human-readable output
          health=$(echo "$response" | jq -r '.health')

          tenant_name=$(echo "$health" | jq -r '.tenant')
          timestamp=$(echo "$health" | jq -r '.timestamp')
          status=$(echo "$health" | jq -r '.status')

          echo
          print_info "Health Check for Tenant: $tenant_name"
          echo
          printf "%-20s %s\n" "Status:" "$status"
          printf "%-20s %s\n" "Checked:" "$(echo "$timestamp" | cut -d'T' -f1,2 | tr 'T' ' ')"
          echo

          # Display individual checks
          echo "Database Checks:"
          checks=$(echo "$health" | jq -r '.checks')

          echo "$checks" | jq -r 'to_entries[] | "\(.key): \(.value)"' | while read -r check; do
              key=$(echo "$check" | cut -d':' -f1)
              value=$(echo "$check" | cut -d':' -f2 | tr -d ' ')

              if [[ "$value" == "true" ]]; then
                  printf "  %-25s %s\n" "$key" "✓"
              else
                  printf "  %-25s %s\n" "$key" "✗"
              fi
          done

          # Show errors if any
          errors=$(echo "$health" | jq -r '.errors[]?' 2>/dev/null)
          if [[ -n "$errors" ]]; then
              echo
              echo "Errors:"
              echo "$errors" | while read -r error; do
                  echo "  • $error"
              done
          fi

          echo
      else
          # JSON output - compact format
          handle_output "$response" "$output_format" "json"
      fi
  else
      error_msg=$(echo "$response" | jq -r '.error // "Health check failed"')
      print_error "$error_msg"
      exit 1
  fi
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        monk_usage
        exit
        ;;

      # :flag.case
      --text)

        # :flag.case_no_arg
        args['--text']=1
        shift
        ;;

      # :flag.case
      --json)

        # :flag.case_no_arg
        args['--json']=1
        shift
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("CLI_VERBOSE")
  env_var_names+=("MONK_CLI_CONFIG_DIR")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init)
      action="init"
      shift
      monk_init_parse_requirements "$@"
      shift $#
      ;;

    server)
      action="server"
      shift
      monk_server_parse_requirements "$@"
      shift $#
      ;;

    tenant)
      action="tenant"
      shift
      monk_tenant_parse_requirements "$@"
      shift $#
      ;;

    auth)
      action="auth"
      shift
      monk_auth_parse_requirements "$@"
      shift $#
      ;;

    data)
      action="data"
      shift
      monk_data_parse_requirements "$@"
      shift $#
      ;;

    meta)
      action="meta"
      shift
      monk_meta_parse_requirements "$@"
      shift $#
      ;;

    bulk)
      action="bulk"
      shift
      monk_bulk_parse_requirements "$@"
      shift $#
      ;;

    fs)
      action="fs"
      shift
      monk_fs_parse_requirements "$@"
      shift $#
      ;;

    find)
      action="find"
      shift
      monk_find_parse_requirements "$@"
      shift $#
      ;;

    root)
      action="root"
      shift
      monk_root_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      monk_server_add_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_server_list_parse_requirements "$@"
      shift $#
      ;;

    current)
      action="current"
      shift
      monk_server_current_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      monk_server_use_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_server_delete_parse_requirements "$@"
      shift $#
      ;;

    ping)
      action="ping"
      shift
      monk_server_ping_parse_requirements "$@"
      shift $#
      ;;

    ping-all)
      action="ping-all"
      shift
      monk_server_ping_all_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_server_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --description)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description DESCRIPTION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        # :argument.case
        elif [[ -z ${args['endpoint']+x} ]]; then
          args['endpoint']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk server add NAME ENDPOINT [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['endpoint']+x} ]]; then
    printf "missing required argument: ENDPOINT\nusage: monk server add NAME ENDPOINT [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_server_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_current_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_current_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server current"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk server delete NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_server_ping_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_ping_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server ping"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_ping_all_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_ping_all_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server ping-all"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      monk_tenant_add_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_tenant_list_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_tenant_delete_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      monk_tenant_use_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_tenant_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --description)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description DESCRIPTION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        # :argument.case
        elif [[ -z ${args['display_name']+x} ]]; then
          args['display_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant add NAME DISPLAY_NAME [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['display_name']+x} ]]; then
    printf "missing required argument: DISPLAY_NAME\nusage: monk tenant add NAME DISPLAY_NAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_tenant_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --server)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--server']="$2"
          shift
          shift
        else
          printf "%s\n" "--server requires an argument: --server SERVER" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant delete NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_tenant_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant use NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    login)
      action="login"
      shift
      monk_auth_login_parse_requirements "$@"
      shift $#
      ;;

    logout)
      action="logout"
      shift
      monk_auth_logout_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      monk_auth_status_parse_requirements "$@"
      shift $#
      ;;

    token)
      action="token"
      shift
      monk_auth_token_parse_requirements "$@"
      shift $#
      ;;

    info)
      action="info"
      shift
      monk_auth_info_parse_requirements "$@"
      shift $#
      ;;

    ping)
      action="ping"
      shift
      monk_auth_ping_parse_requirements "$@"
      shift $#
      ;;

    import)
      action="import"
      shift
      monk_auth_import_parse_requirements "$@"
      shift $#
      ;;

    expires)
      action="expires"
      shift
      monk_auth_expires_parse_requirements "$@"
      shift $#
      ;;

    expired)
      action="expired"
      shift
      monk_auth_expired_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_auth_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_login_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_login_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth login"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['tenant']+x} ]]; then
          args['tenant']=$1
          shift
        # :argument.case
        elif [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tenant']+x} ]]; then
    printf "missing required argument: TENANT\nusage: monk auth login TENANT USERNAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: monk auth login TENANT USERNAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_logout_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_logout_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth logout"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_token_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_token_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth token"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_info_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_info_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth info"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_ping_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_ping_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth ping"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      # :flag.case
      --jwt-token | -j)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--jwt-token']="$2"
          shift
          shift
        else
          printf "%s\n" "--jwt-token requires an argument: --jwt-token, -j TOKEN" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_import_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_import_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth import"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --token | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--token']="$2"
          shift
          shift
        else
          printf "%s\n" "--token requires an argument: --token, -t TOKEN" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['tenant']+x} ]]; then
          args['tenant']=$1
          shift
        # :argument.case
        elif [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tenant']+x} ]]; then
    printf "missing required argument: TENANT\nusage: monk auth import TENANT USERNAME [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: monk auth import TENANT USERNAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_expires_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_expires_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth expires"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_expired_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_expired_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth expired"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_data_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    select)
      action="select"
      shift
      monk_data_select_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      monk_data_create_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_data_update_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_data_delete_parse_requirements "$@"
      shift $#
      ;;

    export)
      action="export"
      shift
      monk_data_export_parse_requirements "$@"
      shift $#
      ;;

    import)
      action="import"
      shift
      monk_data_import_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_data_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_data_select_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_select_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data select"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --filter)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--filter']="$2"
          shift
          shift
        else
          printf "%s\n" "--filter requires an argument: --filter JSON" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data select SCHEMA [ID] [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data create SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data update SCHEMA [ID]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data delete SCHEMA [ID]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_export_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_export_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data export"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['dir']+x} ]]; then
          args['dir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data export SCHEMA DIR\n" >&2

    exit 1
  fi

  if [[ -z ${args['dir']+x} ]]; then
    printf "missing required argument: DIR\nusage: monk data export SCHEMA DIR\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_import_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_import_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data import"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['dir']+x} ]]; then
          args['dir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data import SCHEMA DIR\n" >&2

    exit 1
  fi

  if [[ -z ${args['dir']+x} ]]; then
    printf "missing required argument: DIR\nusage: monk data import SCHEMA DIR\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    select)
      action="select"
      shift
      monk_meta_select_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      monk_meta_create_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_meta_update_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_meta_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_meta_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_meta_select_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_select_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta select"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        # :argument.case
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta select TYPE NAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk meta select TYPE NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta create TYPE\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        # :argument.case
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta update TYPE NAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk meta update TYPE NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        # :argument.case
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta delete TYPE NAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk meta delete TYPE NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_bulk_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    raw)
      action="raw"
      shift
      monk_bulk_raw_parse_requirements "$@"
      shift $#
      ;;

    submit)
      action="submit"
      shift
      monk_bulk_submit_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      monk_bulk_status_parse_requirements "$@"
      shift $#
      ;;

    result)
      action="result"
      shift
      monk_bulk_result_parse_requirements "$@"
      shift $#
      ;;

    cancel)
      action="cancel"
      shift
      monk_bulk_cancel_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_bulk_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_bulk_raw_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_raw_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bulk raw"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_bulk_submit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_submit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bulk submit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_bulk_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bulk status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['operation_id']+x} ]]; then
          args['operation_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['operation_id']+x} ]]; then
    printf "missing required argument: OPERATION_ID\nusage: monk bulk status OPERATION_ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_bulk_result_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_result_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bulk result"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['operation_id']+x} ]]; then
          args['operation_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['operation_id']+x} ]]; then
    printf "missing required argument: OPERATION_ID\nusage: monk bulk result OPERATION_ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_bulk_cancel_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_cancel_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bulk cancel"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['operation_id']+x} ]]; then
          args['operation_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['operation_id']+x} ]]; then
    printf "missing required argument: OPERATION_ID\nusage: monk bulk cancel OPERATION_ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    ls)
      action="ls"
      shift
      monk_fs_ls_parse_requirements "$@"
      shift $#
      ;;

    cat)
      action="cat"
      shift
      monk_fs_cat_parse_requirements "$@"
      shift $#
      ;;

    rm)
      action="rm"
      shift
      monk_fs_rm_parse_requirements "$@"
      shift $#
      ;;

    stat)
      action="stat"
      shift
      monk_fs_stat_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_fs_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_fs_ls_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_ls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs ls"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --long | -l)

        # :flag.case_no_arg
        args['--long']=1
        shift
        ;;

      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs ls PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_cat_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_cat_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs cat"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs cat PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_rm_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_rm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs rm"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs rm PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_stat_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_stat_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs stat"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs stat PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_find_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_find_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="find"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --head | -H)

        # :flag.case_no_arg
        args['--head']=1
        shift
        ;;

      # :flag.case
      --tail | -T)

        # :flag.case_no_arg
        args['--tail']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk find SCHEMA [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    tenant)
      action="tenant"
      shift
      monk_root_tenant_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_root_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_root_tenant_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list | ls)
      action="list"
      shift
      monk_root_tenant_list_parse_requirements "$@"
      shift $#
      ;;

    create | add)
      action="create"
      shift
      monk_root_tenant_create_parse_requirements "$@"
      shift $#
      ;;

    show | info)
      action="show"
      shift
      monk_root_tenant_show_parse_requirements "$@"
      shift $#
      ;;

    trash)
      action="trash"
      shift
      monk_root_tenant_trash_parse_requirements "$@"
      shift $#
      ;;

    restore)
      action="restore"
      shift
      monk_root_tenant_restore_parse_requirements "$@"
      shift $#
      ;;

    delete | purge)
      action="delete"
      shift
      monk_root_tenant_delete_parse_requirements "$@"
      shift $#
      ;;

    health)
      action="health"
      shift
      monk_root_tenant_health_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_root_tenant_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_root_tenant_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --include-trashed)

        # :flag.case_no_arg
        args['--include-trashed']=1
        shift
        ;;

      # :flag.case
      --include-deleted)

        # :flag.case_no_arg
        args['--include-deleted']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_root_tenant_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOSTNAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant create NAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_tenant_show_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant show NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_tenant_trash_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_trash_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant trash"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant trash NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_tenant_restore_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_restore_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant restore"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant restore NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_tenant_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant delete NAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_tenant_health_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_health_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant health"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant health NAME\n" >&2

    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="2.5.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "init") monk_init_command ;;
    "server") monk_server_command ;;
    "server add") monk_server_add_command ;;
    "server list") monk_server_list_command ;;
    "server current") monk_server_current_command ;;
    "server use") monk_server_use_command ;;
    "server delete") monk_server_delete_command ;;
    "server ping") monk_server_ping_command ;;
    "server ping-all") monk_server_ping_all_command ;;
    "tenant") monk_tenant_command ;;
    "tenant add") monk_tenant_add_command ;;
    "tenant list") monk_tenant_list_command ;;
    "tenant delete") monk_tenant_delete_command ;;
    "tenant use") monk_tenant_use_command ;;
    "auth") monk_auth_command ;;
    "auth login") monk_auth_login_command ;;
    "auth logout") monk_auth_logout_command ;;
    "auth status") monk_auth_status_command ;;
    "auth token") monk_auth_token_command ;;
    "auth info") monk_auth_info_command ;;
    "auth ping") monk_auth_ping_command ;;
    "auth import") monk_auth_import_command ;;
    "auth expires") monk_auth_expires_command ;;
    "auth expired") monk_auth_expired_command ;;
    "data") monk_data_command ;;
    "data select") monk_data_select_command ;;
    "data create") monk_data_create_command ;;
    "data update") monk_data_update_command ;;
    "data delete") monk_data_delete_command ;;
    "data export") monk_data_export_command ;;
    "data import") monk_data_import_command ;;
    "meta") monk_meta_command ;;
    "meta select") monk_meta_select_command ;;
    "meta create") monk_meta_create_command ;;
    "meta update") monk_meta_update_command ;;
    "meta delete") monk_meta_delete_command ;;
    "bulk") monk_bulk_command ;;
    "bulk raw") monk_bulk_raw_command ;;
    "bulk submit") monk_bulk_submit_command ;;
    "bulk status") monk_bulk_status_command ;;
    "bulk result") monk_bulk_result_command ;;
    "bulk cancel") monk_bulk_cancel_command ;;
    "fs") monk_fs_command ;;
    "fs ls") monk_fs_ls_command ;;
    "fs cat") monk_fs_cat_command ;;
    "fs rm") monk_fs_rm_command ;;
    "fs stat") monk_fs_stat_command ;;
    "find") monk_find_command ;;
    "root") monk_root_command ;;
    "root tenant") monk_root_tenant_command ;;
    "root tenant list") monk_root_tenant_list_command ;;
    "root tenant create") monk_root_tenant_create_command ;;
    "root tenant show") monk_root_tenant_show_command ;;
    "root tenant trash") monk_root_tenant_trash_command ;;
    "root tenant restore") monk_root_tenant_restore_command ;;
    "root tenant delete") monk_root_tenant_delete_command ;;
    "root tenant health") monk_root_tenant_health_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
