#!/usr/bin/env bash
# This script was generated by bashly 1.3.1 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
monk_usage() {
  if [[ -n $long_usage ]]; then
    printf "monk\n\n"
    printf "  Monk CLI - Command-line interface for PaaS Backend API\n  \n  Getting started:\n    monk examples getting-started    # Browse interactive examples\n    monk docs data                   # View API documentation for the Data API\n  \n  Usage examples:\n    monk status                      # Show current server/tenant/user\n    monk data list users             # List all users\n    monk examples                    # List all available examples\n  \n  For detailed help on a command, run: monk <command> --help\n\n"
  else
    printf "monk - Monk CLI - Command-line interface for PaaS Backend API\n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  monk [OPTIONS] COMMAND\n"
  printf "  monk [COMMAND] --help | -h\n"
  printf "  monk --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Initialize configuration directory with required files\n" "init     "
  printf "  %s   Browse interactive examples and complete workflows (start here!)\n" "examples "
  printf "  %s   Show current server, tenant, user, and available schemas\n" "status   "
  printf "  %s   Make authenticated API requests using current server and credentials\n" "curl     "
  printf "  %s   Remote server management\n" "server   "
  printf "  %s   Tenant registry management\n" "tenant   "
  printf "  %s   Authentication and token management\n" "auth     "
  printf "  %s   Data operations on dynamic schemas\n" "data     "
  printf "  %s   Schema description and metadata management\n" "describe "
  printf "  %s   Execute multiple operations across schemas in a single transaction via JSON input\n" "bulk     "
  printf "  %s   Filesystem-like operations for API data exploration via File API\n" "fs       "
  printf "  %s   Advanced search with enterprise Filter DSL via JSON input\n" "find     "
  printf "  %s   Perform aggregation queries with GROUP BY and statistics via JSON input\n" "aggregate"
  printf "  %s   Synchronize data between tenants, servers, or local directories\n" "sync     "
  printf "  %s   View API documentation from remote server\n" "docs     "
  printf "  %s   User management operations requiring sudo token (requires root access)\n" "sudo     "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Global Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--text"
    printf "    Output in human-readable text format\n"
    echo

    # :flag.usage
    printf "  %s\n" "--json"
    printf "    Output in JSON format\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "CLI_VERBOSE"
    printf "    Enable verbose output for all commands\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "MONK_CLI_CONFIG_DIR"
    printf "    Custom directory for CLI configuration files (default: ~/.config/monk/cli)\n"
    echo

  fi
}

# :command.usage
monk_init_usage() {
  printf "monk init - Initialize configuration directory with required files\n\n"

  printf "%s\n" "Usage:"
  printf "  monk init [PATH] [OPTIONS]\n"
  printf "  monk init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force"
    printf "    Force reinitialization by overwriting existing config files (preserves\n    env.json)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    Custom path for configuration directory (default: ~/.config/monk/cli)\n"
    echo

  fi
}

# :command.usage
monk_examples_usage() {
  printf "monk examples - Browse interactive examples and complete workflows (start here!)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk examples [NAME]\n"
  printf "  monk examples --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Example name to display (omit to list all examples)\n"
    echo

  fi
}

# :command.usage
monk_status_usage() {
  printf "monk status - Show current server, tenant, user, and available schemas\n\n"

  printf "%s\n" "Usage:"
  printf "  monk status\n"
  printf "  monk status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_curl_usage() {
  printf "monk curl - Make authenticated API requests using current server and credentials\n\n"

  printf "%s\n" "Usage:"
  printf "  monk curl METHOD PATH [OPTIONS]\n"
  printf "  monk curl --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--data, -d JSON"
    printf "    JSON data to send (alternative to stdin)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--raw, -r"
    printf "    Output raw response without pretty-printing\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "METHOD"
    printf "    HTTP method (GET, POST, PUT, DELETE, etc.)\n"
    echo

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    API endpoint path (e.g., /api/file/list, /api/auth/ping)\n"
    echo

  fi
}

# :command.usage
monk_server_usage() {
  printf "monk server - Remote server management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server COMMAND\n"
  printf "  monk server [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Register remote server\n" "add     "
  printf "  %s   List all servers with health status\n" "list    "
  printf "  %s   Show currently selected server\n" "current "
  printf "  %s   Switch to server (persistent selection) or show current server\n" "use     "
  printf "  %s   Remove server from registry\n" "delete  "
  printf "  %s   Health check specific server (defaults to current server)\n" "ping    "
  printf "  %s   Health check all registered servers\n" "ping-all"
  printf "  %s   Show server information from API root endpoint\n" "info    "
  printf "  %s   Check server health status from API /health endpoint\n" "health  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_add_usage() {
  printf "monk server add - Register remote server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server add NAME ENDPOINT [OPTIONS]\n"
  printf "  monk server add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--description DESCRIPTION"
    printf "    Optional server description\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ENDPOINT"
    printf "    Server endpoint (host:port)\n"
    echo

  fi
}

# :command.usage
monk_server_list_usage() {
  printf "monk server list - List all servers with health status\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server list\n"
  printf "  monk server list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_current_usage() {
  printf "monk server current - Show currently selected server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server current\n"
  printf "  monk server current --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_use_usage() {
  printf "monk server use - Switch to server (persistent selection) or show current server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server use [NAME]\n"
  printf "  monk server use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to switch to (omit to show current server)\n"
    echo

  fi
}

# :command.usage
monk_server_delete_usage() {
  printf "monk server delete - Remove server from registry\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server delete NAME\n"
  printf "  monk server delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to delete\n"
    echo

  fi
}

# :command.usage
monk_server_ping_usage() {
  printf "monk server ping - Health check specific server (defaults to current server)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server ping [NAME]\n"
  printf "  monk server ping --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to ping (optional, defaults to current server)\n"
    echo

  fi
}

# :command.usage
monk_server_ping_all_usage() {
  printf "monk server ping-all - Health check all registered servers\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server ping-all\n"
  printf "  monk server ping-all --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_info_usage() {
  printf "monk server info - Show server information from API root endpoint\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server info [NAME]\n"
  printf "  monk server info --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to query (optional, defaults to current server)\n"
    echo

  fi
}

# :command.usage
monk_server_health_usage() {
  printf "monk server health - Check server health status from API /health endpoint\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server health [NAME]\n"
  printf "  monk server health --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to check (optional, defaults to current server)\n"
    echo

  fi
}

# :command.usage
monk_tenant_usage() {
  printf "monk tenant - Tenant registry management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant COMMAND\n"
  printf "  monk tenant [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Register new tenant\n" "add   "
  printf "  %s   List all registered tenants\n" "list  "
  printf "  %s   Remove tenant from registry\n" "delete"
  printf "  %s   Switch to tenant (persistent selection)\n" "use   "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_add_usage() {
  printf "monk tenant add - Register new tenant\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant add NAME DISPLAY_NAME [OPTIONS]\n"
  printf "  monk tenant add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--description DESCRIPTION"
    printf "    Optional tenant description\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant identifier name\n"
    echo

    # :argument.usage
    printf "  %s\n" "DISPLAY_NAME"
    printf "    Human-readable tenant name\n"
    echo

  fi
}

# :command.usage
monk_tenant_list_usage() {
  printf "monk tenant list - List all registered tenants\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant list [OPTIONS]\n"
  printf "  monk tenant list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--server SERVER"
    printf "    Target server (defaults to current server)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_delete_usage() {
  printf "monk tenant delete - Remove tenant from registry\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant delete NAME\n"
  printf "  monk tenant delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name to delete\n"
    echo

  fi
}

# :command.usage
monk_tenant_use_usage() {
  printf "monk tenant use - Switch to tenant (persistent selection)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant use NAME\n"
  printf "  monk tenant use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name to switch to\n"
    echo

  fi
}

# :command.usage
monk_auth_usage() {
  printf "monk auth - Authentication and token management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth COMMAND\n"
  printf "  monk auth [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all stored JWT tokens and sessions\n" "list    "
  printf "  %s   Register new tenant and user (creates both and stores JWT)\n" "register"
  printf "  %s   Authenticate with tenant and username\n" "login   "
  printf "  %s   Clear stored JWT token\n" "logout  "
  printf "  %s   Show authentication status\n" "status  "
  printf "  %s   Display current JWT token\n" "token   "
  printf "  %s   Decode and display JWT token contents\n" "info    "
  printf "  %s   Authenticated API health check\n" "ping    "
  printf "  %s   Import JWT token from external auth flow\n" "import  "
  printf "  %s   Show JWT token expiration time\n" "expires "
  printf "  %s   Check if JWT token is expired (exit code 0=valid, 1=expired)\n" "expired "
  printf "  %s   List available tenants (personal mode only)\n" "tenants "
  printf "  %s   Request sudo token for dangerous operations (15min validity)\n" "sudo    "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_list_usage() {
  printf "monk auth list - List all stored JWT tokens and sessions\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth list\n"
  printf "  monk auth list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_register_usage() {
  printf "monk auth register - Register new tenant and user (creates both and stores JWT)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth register TENANT [USERNAME] [OPTIONS]\n"
  printf "  monk auth register --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--database DATABASE"
    printf "    Custom database name (personal mode only)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--description DESCRIPTION"
    printf "    Human-readable description of the tenant\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TENANT"
    printf "    Tenant name to register\n"
    echo

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    Username to register (defaults to 'root' in personal mode, required in\n    enterprise mode)\n"
    echo

  fi
}

# :command.usage
monk_auth_login_usage() {
  printf "monk auth login - Authenticate with tenant and username\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth login TENANT USERNAME\n"
  printf "  monk auth login --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TENANT"
    printf "    Tenant name for authentication\n"
    echo

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    Username for authentication\n"
    echo

  fi
}

# :command.usage
monk_auth_logout_usage() {
  printf "monk auth logout - Clear stored JWT token\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth logout\n"
  printf "  monk auth logout --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_status_usage() {
  printf "monk auth status - Show authentication status\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth status\n"
  printf "  monk auth status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_token_usage() {
  printf "monk auth token - Display current JWT token\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth token\n"
  printf "  monk auth token --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_info_usage() {
  printf "monk auth info - Decode and display JWT token contents\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth info\n"
  printf "  monk auth info --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_ping_usage() {
  printf "monk auth ping - Authenticated API health check\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth ping [OPTIONS]\n"
  printf "  monk auth ping --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Verbose server information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--jwt-token, -j TOKEN"
    printf "    Include JWT token in request\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_import_usage() {
  printf "monk auth import - Import JWT token from external auth flow\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth import TENANT USERNAME [OPTIONS]\n"
  printf "  monk auth import --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--token, -t TOKEN"
    printf "    JWT token to import (or provide via stdin)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TENANT"
    printf "    Tenant name for this JWT token\n"
    echo

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    Username for this JWT token\n"
    echo

  fi
}

# :command.usage
monk_auth_expires_usage() {
  printf "monk auth expires - Show JWT token expiration time\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth expires\n"
  printf "  monk auth expires --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_expired_usage() {
  printf "monk auth expired - Check if JWT token is expired (exit code 0=valid, 1=expired)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth expired\n"
  printf "  monk auth expired --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_tenants_usage() {
  printf "monk auth tenants - List available tenants (personal mode only)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth tenants\n"
  printf "  monk auth tenants --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_sudo_usage() {
  printf "monk auth sudo - Request sudo token for dangerous operations (15min validity)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth sudo [OPTIONS]\n"
  printf "  monk auth sudo --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--reason REASON"
    printf "    Reason for privilege escalation (for audit trail)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_data_usage() {
  printf "monk data - Data operations on dynamic schemas\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data COMMAND\n"
  printf "  monk data [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List record(s) with flexible query support\n" "list  "
  printf "  %s   Create record from stdin\n" "create"
  printf "  %s   Update record(s) from stdin\n" "update"
  printf "  %s   Delete record(s)\n" "delete"
  printf "  %s   Export records to JSON files\n" "export"
  printf "  %s   Import JSON files as records\n" "import"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_data_list_usage() {
  printf "monk data list - List record(s) with flexible query support\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data list SCHEMA [ID] [OPTIONS]\n"
  printf "  monk data list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--filter JSON"
    printf "    JSON filter for query parameters (limit, offset, order)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to retrieve (optional)\n"
    echo

  fi
}

# :command.usage
monk_data_create_usage() {
  printf "monk data create - Create record from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data create SCHEMA\n"
  printf "  monk data create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to create record in\n"
    echo

  fi
}

# :command.usage
monk_data_update_usage() {
  printf "monk data update - Update record(s) from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data update SCHEMA [ID]\n"
  printf "  monk data update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to update (optional if ID in JSON)\n"
    echo

  fi
}

# :command.usage
monk_data_delete_usage() {
  printf "monk data delete - Delete record(s)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data delete SCHEMA [ID]\n"
  printf "  monk data delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to delete (optional if ID in JSON or using stdin)\n"
    echo

  fi
}

# :command.usage
monk_data_export_usage() {
  printf "monk data export - Export records to JSON files\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data export SCHEMA DIR\n"
  printf "  monk data export --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to export\n"
    echo

    # :argument.usage
    printf "  %s\n" "DIR"
    printf "    Directory to export to\n"
    echo

  fi
}

# :command.usage
monk_data_import_usage() {
  printf "monk data import - Import JSON files as records\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data import SCHEMA DIR\n"
  printf "  monk data import --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to import into\n"
    echo

    # :argument.usage
    printf "  %s\n" "DIR"
    printf "    Directory to import from\n"
    echo

  fi
}

# :command.usage
monk_describe_usage() {
  printf "monk describe - Schema description and metadata management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe COMMAND\n"
  printf "  monk describe [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all available schema names in the current tenant\n" "list  "
  printf "  %s   Select specific schema definition\n" "select"
  printf "  %s   Create new schema from JSON definition\n" "create"
  printf "  %s   Update existing schema from JSON definition\n" "update"
  printf "  %s   Delete schema definition (soft delete)\n" "delete"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_describe_list_usage() {
  printf "monk describe list - List all available schema names in the current tenant\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe list\n"
  printf "  monk describe list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_describe_select_usage() {
  printf "monk describe select - Select specific schema definition\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe select SCHEMA\n"
  printf "  monk describe select --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to retrieve\n"
    echo

  fi
}

# :command.usage
monk_describe_create_usage() {
  printf "monk describe create - Create new schema from JSON definition\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe create SCHEMA\n"
  printf "  monk describe create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to create\n"
    echo

  fi
}

# :command.usage
monk_describe_update_usage() {
  printf "monk describe update - Update existing schema from JSON definition\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe update SCHEMA\n"
  printf "  monk describe update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to update\n"
    echo

  fi
}

# :command.usage
monk_describe_delete_usage() {
  printf "monk describe delete - Delete schema definition (soft delete)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe delete SCHEMA\n"
  printf "  monk describe delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to delete\n"
    echo

  fi
}

# :command.usage
monk_bulk_usage() {
  printf "monk bulk - Execute multiple operations across schemas in a single transaction via JSON input\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk\n"
  printf "  monk bulk --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_fs_usage() {
  printf "monk fs - Filesystem-like operations for API data exploration via File API\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs COMMAND\n"
  printf "  monk fs [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List directory contents with wildcard support\n" "ls   "
  printf "  %s   Display file content or record data\n" "cat  "
  printf "  %s   Remove files, records, or fields\n" "rm   "
  printf "  %s   Display detailed file/directory status and schema information\n" "stat "
  printf "  %s   Copy records between schemas or duplicate records\n" "cp   "
  printf "  %s   Calculate storage footprint for files or directories\n" "size "
  printf "  %s   Retrieve modified timestamps for files or directories\n" "mtime"
  printf "  %s   Find files/directories with content filtering (Unix find-like)\n" "find "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_fs_ls_usage() {
  printf "monk fs ls - List directory contents with wildcard support\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs ls PATH [OPTIONS]\n"
  printf "  monk fs ls --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--long, -l"
    printf "    Use long listing format with detailed information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--all, -a"
    printf "    Show hidden entries (system fields like access_*, created_at, etc.)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--sort, -S FIELD"
    printf "    Sort entries by field (name, size, time, or type)\n"
    printf "    %s\n" "Allowed: name, size, time, type"
    printf "    %s\n" "Default: name"
    echo

    # :flag.usage
    printf "  %s\n" "--reverse, -r"
    printf "    Reverse sort order (descending instead of ascending)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    File path (e.g., /data/users/, /tenant/tenant-a/data/users/)\n"
    echo

  fi
}

# :command.usage
monk_fs_cat_usage() {
  printf "monk fs cat - Display file content or record data\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs cat PATH [OPTIONS]\n"
  printf "  monk fs cat --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--format, -f FORMAT"
    printf "    Output format: json (structured) or raw (string content)\n"
    printf "    %s\n" "Allowed: json, raw"
    printf "    %s\n" "Default: json"
    echo

    # :flag.usage
    printf "  %s\n" "--offset, -o BYTES"
    printf "    Byte offset to start reading from (for partial reads)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--max-bytes, -m BYTES"
    printf "    Maximum bytes to read (for limiting large outputs)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    File path to file or record (e.g., /data/users/user-123.json,\n    /tenant/tenant-a/data/users/user-123.json)\n"
    echo

  fi
}

# :command.usage
monk_fs_rm_usage() {
  printf "monk fs rm - Remove files, records, or fields\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs rm PATH [OPTIONS]\n"
  printf "  monk fs rm --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Force permanent deletion (default is soft delete)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    File path to delete (e.g., /data/users/user-123,\n    /tenant/tenant-a/data/users/user-123)\n"
    echo

  fi
}

# :command.usage
monk_fs_stat_usage() {
  printf "monk fs stat - Display detailed file/directory status and schema information\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs stat PATH [OPTIONS]\n"
  printf "  monk fs stat --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    File path for status information (e.g., /data/users/,\n    /tenant/tenant-a/meta/schema/)\n"
    echo

  fi
}

# :command.usage
monk_fs_cp_usage() {
  printf "monk fs cp - Copy records between schemas or duplicate records\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs cp SOURCE DESTINATION [OPTIONS]\n"
  printf "  monk fs cp --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--recursive, -r"
    printf "    Copy directory contents recursively\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Force overwrite and allow cross-tenant operations\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOURCE"
    printf "    Source path (e.g., /data/users/123.json, /data/users/)\n"
    echo

    # :argument.usage
    printf "  %s\n" "DESTINATION"
    printf "    Destination path (e.g., /data/users/456.json, /data/backup/users/)\n"
    echo

  fi
}

# :command.usage
monk_fs_size_usage() {
  printf "monk fs size - Calculate storage footprint for files or directories\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs size PATH [OPTIONS]\n"
  printf "  monk fs size --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    File path to calculate size (e.g., /data/users/user-123.json)\n"
    echo

  fi
}

# :command.usage
monk_fs_mtime_usage() {
  printf "monk fs mtime - Retrieve modified timestamps for files or directories\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs mtime PATH [OPTIONS]\n"
  printf "  monk fs mtime --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    File path to check modified time (e.g., /data/users/user-123.json)\n"
    echo

  fi
}

# :command.usage
monk_fs_find_usage() {
  printf "monk fs find - Find files/directories with content filtering (Unix find-like)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs find PATH [OPTIONS]\n"
  printf "  monk fs find --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--where, -w CONDITION (repeatable)"
    printf "    Filter by content (key=value or JSON WHERE clause)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--type, -T TYPE"
    printf "    Filter by type (f=file, d=directory, l=link)\n"
    printf "    %s\n" "Allowed: f, d, l"
    echo

    # :flag.usage
    printf "  %s\n" "--name, -n PATTERN"
    printf "    Filter by name pattern (wildcards: * ?)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--maxdepth DEPTH"
    printf "    Maximum directory depth to search\n"
    echo

    # :flag.usage
    printf "  %s\n" "--print0"
    printf "    Null-separated output (for xargs -0)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    Starting path for search (e.g., /data/users/, /data/)\n"
    echo

  fi
}

# :command.usage
monk_find_usage() {
  printf "monk find - Advanced search with enterprise Filter DSL via JSON input\n\n"

  printf "%s\n" "Usage:"
  printf "  monk find SCHEMA [OPTIONS]\n"
  printf "  monk find --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--head, -H"
    printf "    Return only first record from results\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tail, -T"
    printf "    Return only last record from results\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema to search\n"
    echo

  fi
}

# :command.usage
monk_aggregate_usage() {
  printf "monk aggregate - Perform aggregation queries with GROUP BY and statistics via JSON input\n\n"

  printf "%s\n" "Usage:"
  printf "  monk aggregate SCHEMA\n"
  printf "  monk aggregate --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema to aggregate\n"
    echo

  fi
}

# :command.usage
monk_sync_usage() {
  printf "monk sync - Synchronize data between tenants, servers, or local directories\n\n"

  printf "%s\n" "Usage:"
  printf "  monk sync COMMAND\n"
  printf "  monk sync [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Pull data from remote tenant to local directory\n" "pull "
  printf "  %s   Push data from local directory to remote tenant\n" "push "
  printf "  %s   Show differences between two endpoints\n" "diff "
  printf "  %s   Direct copy between two remote tenants (streaming)\n" "copy "
  printf "  %s   Apply a previously generated patch file\n" "patch"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_sync_pull_usage() {
  printf "monk sync pull - Pull data from remote tenant to local directory\n\n"

  printf "%s\n" "Usage:"
  printf "  monk sync pull SOURCE DIRECTORY [OPTIONS]\n"
  printf "  monk sync pull --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--filter, -f JSON"
    printf "    Filter DSL for selective sync\n"
    echo

    # :flag.usage
    printf "  %s\n" "--overwrite"
    printf "    Overwrite existing files in directory\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOURCE"
    printf "    Source endpoint (tenant:schema or server:tenant:schema)\n"
    echo

    # :argument.usage
    printf "  %s\n" "DIRECTORY"
    printf "    Local directory path to save data\n"
    echo

  fi
}

# :command.usage
monk_sync_push_usage() {
  printf "monk sync push - Push data from local directory to remote tenant\n\n"

  printf "%s\n" "Usage:"
  printf "  monk sync push DIRECTORY DESTINATION [OPTIONS]\n"
  printf "  monk sync push --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--dry-run"
    printf "    Show what would be synced without making changes\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DIRECTORY"
    printf "    Local directory path containing JSON files\n"
    echo

    # :argument.usage
    printf "  %s\n" "DESTINATION"
    printf "    Destination endpoint (tenant:schema or server:tenant:schema)\n"
    echo

  fi
}

# :command.usage
monk_sync_diff_usage() {
  printf "monk sync diff - Show differences between two endpoints\n\n"

  printf "%s\n" "Usage:"
  printf "  monk sync diff SOURCE DESTINATION [OPTIONS]\n"
  printf "  monk sync diff --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--format FORMAT"
    printf "    Output format (summary or json)\n"
    printf "    %s\n" "Allowed: summary, json"
    printf "    %s\n" "Default: summary"
    echo

    # :flag.usage
    printf "  %s\n" "--output, -o FILE"
    printf "    Save diff to patch file\n"
    echo

    # :flag.usage
    printf "  %s\n" "--filter, -f JSON"
    printf "    Filter DSL to limit comparison scope\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOURCE"
    printf "    Source endpoint (tenant:schema, server:tenant:schema, or directory)\n"
    echo

    # :argument.usage
    printf "  %s\n" "DESTINATION"
    printf "    Destination endpoint (tenant:schema, server:tenant:schema, or directory)\n"
    echo

  fi
}

# :command.usage
monk_sync_copy_usage() {
  printf "monk sync copy - Direct copy between two remote tenants (streaming)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk sync copy SOURCE DESTINATION [OPTIONS]\n"
  printf "  monk sync copy --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--filter, -f JSON"
    printf "    Filter DSL for selective sync\n"
    echo

    # :flag.usage
    printf "  %s\n" "--dry-run"
    printf "    Show what would be synced without making changes\n"
    echo

    # :flag.usage
    printf "  %s\n" "--strategy STRATEGY"
    printf "    Sync strategy (replace all or merge/upsert)\n"
    printf "    %s\n" "Allowed: replace, merge"
    printf "    %s\n" "Default: replace"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOURCE"
    printf "    Source endpoint (tenant:schema or server:tenant:schema)\n"
    echo

    # :argument.usage
    printf "  %s\n" "DESTINATION"
    printf "    Destination endpoint (tenant:schema or server:tenant:schema)\n"
    echo

  fi
}

# :command.usage
monk_sync_patch_usage() {
  printf "monk sync patch - Apply a previously generated patch file\n\n"

  printf "%s\n" "Usage:"
  printf "  monk sync patch PATCH_FILE DESTINATION [OPTIONS]\n"
  printf "  monk sync patch --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--dry-run"
    printf "    Show what would be changed without applying\n"
    echo

    # :flag.usage
    printf "  %s\n" "--reverse, -R"
    printf "    Apply patch in reverse (undo)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATCH_FILE"
    printf "    Patch file from sync diff --output\n"
    echo

    # :argument.usage
    printf "  %s\n" "DESTINATION"
    printf "    Destination endpoint (tenant:schema or server:tenant:schema)\n"
    echo

  fi
}

# :command.usage
monk_docs_usage() {
  printf "monk docs - View API documentation from remote server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk docs AREA\n"
  printf "  monk docs --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "AREA"
    printf "    Documentation area to view (e.g., auth, data, describe, find, bulk, file,\n    acls, root)\n"
    echo

  fi
}

# :command.usage
monk_sudo_usage() {
  printf "monk sudo - User management operations requiring sudo token (requires root access)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk sudo COMMAND\n"
  printf "  monk sudo [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   User management operations\n" "users"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_sudo_users_usage() {
  printf "monk sudo users - User management operations\n\n"

  printf "%s\n" "Usage:"
  printf "  monk sudo users COMMAND\n"
  printf "  monk sudo users [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all users in current tenant\n" "list  "
  printf "  %s   Create new user\n" "create"
  printf "  %s   Show user details\n" "show  "
  printf "  %s   Update existing user\n" "update"
  printf "  %s   Delete user (soft delete)\n" "delete"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_sudo_users_list_usage() {
  printf "monk sudo users list - List all users in current tenant\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk sudo users list\n"
  printf "  monk sudo users list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_sudo_users_create_usage() {
  printf "monk sudo users create - Create new user\n\n"
  printf "Alias: add\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk sudo users create [OPTIONS]\n"
  printf "  monk sudo users create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--name NAME (required)"
    printf "    Display name for the user\n"
    echo

    # :flag.usage
    printf "  %s\n" "--auth AUTH (required)"
    printf "    Authentication identifier (username/email)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--access ACCESS (required)"
    printf "    Access level: deny, read, edit, full, or root\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_sudo_users_show_usage() {
  printf "monk sudo users show - Show user details\n\n"
  printf "Alias: info\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk sudo users show ID\n"
  printf "  monk sudo users show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    User ID (UUID)\n"
    echo

  fi
}

# :command.usage
monk_sudo_users_update_usage() {
  printf "monk sudo users update - Update existing user\n\n"

  printf "%s\n" "Usage:"
  printf "  monk sudo users update ID [OPTIONS]\n"
  printf "  monk sudo users update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--name NAME"
    printf "    Display name\n"
    echo

    # :flag.usage
    printf "  %s\n" "--access ACCESS"
    printf "    Access level: deny, read, edit, full, or root\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    User ID (UUID)\n"
    echo

  fi
}

# :command.usage
monk_sudo_users_delete_usage() {
  printf "monk sudo users delete - Delete user (soft delete)\n\n"
  printf "Alias: rm\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk sudo users delete ID [OPTIONS]\n"
  printf "  monk sudo users delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force"
    printf "    Skip confirmation\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    User ID (UUID)\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/common.sh
#!/bin/bash

# Common functions for bashly CLI commands
# Clean rewrite to eliminate syntax errors and improve maintainability

# Clean separation of concerns:
# - server.json: Infrastructure endpoints

# - auth.json: Authentication sessions per server+tenant
# - env.json: Current working context (server+tenant selection)

# CLI configuration files

CLI_CONFIG_DIR="${MONK_CLI_CONFIG_DIR:-${HOME}/.config/monk/cli}"
SERVER_CONFIG="${CLI_CONFIG_DIR}/server.json"
TENANT_CONFIG="${CLI_CONFIG_DIR}/tenant.json"
AUTH_CONFIG="${CLI_CONFIG_DIR}/auth.json"
ENV_CONFIG="${CLI_CONFIG_DIR}/env.json"

# Legacy config file (for migration)
LEGACY_SERVERS_CONFIG="${HOME}/.config/monk/servers.json"

# Default configuration
DEFAULT_BASE_URL="http://localhost:3000"
DEFAULT_LIMIT=50
DEFAULT_FORMAT="raw"

# Colors for output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output - all go to stderr to avoid interfering with data pipes
print_error() {
    echo -e "${RED} $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN} $1${NC}" >&2
}

print_info() {
    # Only print if CLI_VERBOSE is true
    if [ "$CLI_VERBOSE" = "true" ]; then
        echo -e "${YELLOW} $1${NC}" >&2
    fi
}

print_info_always() {
    # Always print info messages (ignores CLI_VERBOSE)
    echo -e "${YELLOW} $1${NC}" >&2
}

print_warning() {
    echo -e "${YELLOW} $1${NC}" >&2
}

# Initialize CLI config directory and files
init_cli_configs() {
    # Ensure CLI config directory exists
    mkdir -p "$CLI_CONFIG_DIR"

    # Initialize individual config files
    init_server_config
    init_tenant_config
    init_auth_config

    init_env_config
}

# Initialize server config if it doesn't exist
init_server_config() {
    if [ ! -f "$SERVER_CONFIG" ]; then
        mkdir -p "$(dirname "$SERVER_CONFIG")"
        cat > "$SERVER_CONFIG" << 'EOF'
{
  "servers": {}
}
EOF
    fi
}

# Initialize tenant config if it doesn't exist
init_tenant_config() {
    if [ ! -f "$TENANT_CONFIG" ]; then
        mkdir -p "$(dirname "$TENANT_CONFIG")"
        cat > "$TENANT_CONFIG" << 'EOF'
{
  "tenants": {}
}
EOF
    fi
}

# Initialize auth config if it doesn't exist

init_auth_config() {
    if [ ! -f "$AUTH_CONFIG" ]; then
        mkdir -p "$(dirname "$AUTH_CONFIG")"
        cat > "$AUTH_CONFIG" << 'EOF'
{
  "sessions": {}
}
EOF
    fi
}

# Initialize env config if it doesn't exist
init_env_config() {
    if [ ! -f "$ENV_CONFIG" ]; then
        mkdir -p "$(dirname "$ENV_CONFIG")"
        cat > "$ENV_CONFIG" << 'EOF'
{
  "current_server": null,
  "current_tenant": null,
  "current_user": null,
  "recents": []
}
EOF
    fi
}

# Migrate from legacy servers.json to new CLI config structure
migrate_legacy_config() {
    # Only migrate if legacy file exists and new structure doesn't
    if [[ -f "$LEGACY_SERVERS_CONFIG" && ! -f "$SERVER_CONFIG" ]]; then
        print_info "Migrating legacy configuration to new CLI structure..."

        # Ensure new config directory exists
        mkdir -p "$CLI_CONFIG_DIR"

        # Extract server info and current server from legacy config
        local servers_data current_server
        servers_data=$(jq '.servers' "$LEGACY_SERVERS_CONFIG" 2>/dev/null)
        current_server=$(jq -r '.current_server // empty' "$LEGACY_SERVERS_CONFIG" 2>/dev/null)

        # Create new server.json (infrastructure only)
        echo "{\"servers\": $servers_data}" > "$SERVER_CONFIG"

        # Create env.json with current server selection
        cat > "$ENV_CONFIG" << EOF
{
  "current_server": "$current_server",
  "current_tenant": null,
  "current_user": null,
  "recents": []
}
EOF

        # Create empty auth.json (tokens will be re-established)
        cat > "$AUTH_CONFIG" << 'EOF'
{
  "sessions": {}
}
EOF

        print_success "Configuration migrated to ~/.config/monk/cli/"
        print_warning "JWT tokens were not migrated - please re-authenticate with 'monk auth login'"
    fi
}

# Get base URL from server config - fail if not configured
get_base_url() {
    migrate_legacy_config

    # Check if jq is available
    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for server configuration" >&2
        echo "Install jq to use server configuration" >&2
        exit 1
    fi

    # Check if config file exists
    if [[ ! -f "$SERVER_CONFIG" ]]; then
        echo "Error: No server configuration found" >&2
        echo "Use 'monk server add <name> <hostname:port>' to add a server" >&2
        exit 1
    fi

    # Get current server from env config
    init_env_config
    local current_server
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

    if [[ -z "$current_server" || "$current_server" == "null" ]]; then
        echo "Error: No current server selected" >&2
        echo "Use 'monk server use <name>' to select a server" >&2
        exit 1
    fi

    # Get server info from server config
    local server_info
    server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)

    if [[ "$server_info" == "null" ]]; then
        echo "Error: Current server '$current_server' not found in configuration" >&2
        echo "Use 'monk server list' to see available servers" >&2
        exit 1
    fi

    # Extract connection details
    local hostname=$(echo "$server_info" | jq -r '.hostname')
    local port=$(echo "$server_info" | jq -r '.port')
    local protocol=$(echo "$server_info" | jq -r '.protocol')

    # Validate required fields
    if [[ "$hostname" == "null" || "$port" == "null" || "$protocol" == "null" ]]; then
        echo "Error: Invalid server configuration for '$current_server'" >&2
        echo "Server configuration is missing required fields (hostname, port, protocol)" >&2
        exit 1
    fi

    echo "$protocol://$hostname:$port"
}

# Get stored JWT token for current server+tenant context
get_jwt_token() {
    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for JWT token management" >&2
        return 1
    fi

    # Get current context
    local current_server current_tenant
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        # No current server selected
        return 1
    fi

    if [ -z "$current_tenant" ] || [ "$current_tenant" = "null" ]; then
        # No current tenant selected
        return 1
    fi

    # Get session-specific token using server:tenant key
    local session_key="${current_server}:${current_tenant}"
    local token
    token=$(jq -r ".sessions.\"$session_key\".jwt_token // empty" "$AUTH_CONFIG" 2>/dev/null)

    if [ -n "$token" ] && [ "$token" != "null" ]; then
        echo "$token"
    else
        return 1
    fi
}

# Store JWT token for current server+tenant context
store_token() {
    local token="$1"
    local tenant="$2"
    local user="$3"

    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for JWT token management" >&2
        return 1
    fi

    # Get current server from env config
    local current_server
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        echo "Error: No current server selected. Use 'monk server use <name>' first" >&2
        return 1
    fi

    # Update env config with current tenant and user
    local temp_file=$(mktemp)
    jq --arg tenant "$tenant" \
       --arg user "$user" \
       '.current_tenant = $tenant | .current_user = $user' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

    # Store token in auth config using server:tenant key
    local session_key="${current_server}:${tenant}"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    temp_file=$(mktemp)
    jq --arg session_key "$session_key" \
       --arg token "$token" \
       --arg tenant "$tenant" \
       --arg user "$user" \
       --arg server "$current_server" \
       --arg timestamp "$timestamp" \
       '.sessions[$session_key] = {
           "jwt_token": $token,
           "tenant": $tenant,
           "user": $user,

           "server": $server,
           "created_at": $timestamp
       }' "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"

    # Set secure permissions on auth file
    chmod 600 "$AUTH_CONFIG"
}

# Remove stored JWT token for current server+tenant context
remove_stored_token() {
    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for JWT token management" >&2
        return 1
    fi

    # Get current context
    local current_server current_tenant
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        echo "Error: No current server selected" >&2
        return 1
    fi

    if [ -z "$current_tenant" ] || [ "$current_tenant" = "null" ]; then
        # Clear all tenant info from env
        local temp_file=$(mktemp)
        jq '.current_tenant = null | .current_user = null' \
           "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
        return 0
    fi

    # Remove session from auth config
    local session_key="${current_server}:${current_tenant}"
    local temp_file=$(mktemp)
    jq --arg session_key "$session_key" \
       'del(.sessions[$session_key])' \
       "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"

    # Clear current tenant from env config
    temp_file=$(mktemp)
    jq '.current_tenant = null | .current_user = null' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
}

# Get sudo token for current server+tenant context
get_sudo_token() {
    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for sudo token management" >&2
        return 1
    fi

    # Get current context
    local current_server current_tenant
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        return 1
    fi

    if [ -z "$current_tenant" ] || [ "$current_tenant" = "null" ]; then
        return 1
    fi

    # Get session-specific sudo token using server:tenant key
    local session_key="${current_server}:${current_tenant}"
    local sudo_token expires_at
    sudo_token=$(jq -r ".sessions.\"$session_key\".sudo_token // empty" "$AUTH_CONFIG" 2>/dev/null)
    expires_at=$(jq -r ".sessions.\"$session_key\".sudo_expires_at // empty" "$AUTH_CONFIG" 2>/dev/null)

    if [ -z "$sudo_token" ] || [ "$sudo_token" = "null" ]; then
        return 1
    fi

    # Check if token is expired
    if [ -n "$expires_at" ] && [ "$expires_at" != "null" ]; then
        local current_time=$(date +%s)
        if [ "$current_time" -ge "$expires_at" ]; then
            # Token expired, clear it
            clear_sudo_token
            return 1
        fi
    fi

    echo "$sudo_token"
}

# Store sudo token for current server+tenant context
store_sudo_token() {
    local sudo_token="$1"
    local reason="${2:-}"

    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for sudo token management" >&2
        return 1
    fi

    # Get current context
    local current_server current_tenant
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        echo "Error: No current server selected" >&2
        return 1
    fi

    if [ -z "$current_tenant" ] || [ "$current_tenant" = "null" ]; then
        echo "Error: No current tenant selected" >&2
        return 1
    fi

    # Calculate expiration time (15 minutes from now)
    local expires_at=$(($(date +%s) + 900))
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Store sudo token in auth config
    local session_key="${current_server}:${current_tenant}"
    local temp_file=$(mktemp)

    if [ -n "$reason" ]; then
        jq --arg session_key "$session_key" \
           --arg sudo_token "$sudo_token" \
           --arg expires_at "$expires_at" \
           --arg timestamp "$timestamp" \
           --arg reason "$reason" \
           '.sessions[$session_key].sudo_token = $sudo_token |
            .sessions[$session_key].sudo_expires_at = ($expires_at | tonumber) |
            .sessions[$session_key].sudo_created_at = $timestamp |
            .sessions[$session_key].sudo_reason = $reason' \
           "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"
    else
        jq --arg session_key "$session_key" \
           --arg sudo_token "$sudo_token" \
           --arg expires_at "$expires_at" \
           --arg timestamp "$timestamp" \
           '.sessions[$session_key].sudo_token = $sudo_token |
            .sessions[$session_key].sudo_expires_at = ($expires_at | tonumber) |
            .sessions[$session_key].sudo_created_at = $timestamp' \
           "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"
    fi

    # Set secure permissions on auth file
    chmod 600 "$AUTH_CONFIG"
}

# Clear sudo token for current server+tenant context
clear_sudo_token() {
    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for sudo token management" >&2
        return 1
    fi

    # Get current context
    local current_server current_tenant
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        return 1
    fi

    if [ -z "$current_tenant" ] || [ "$current_tenant" = "null" ]; then
        return 1
    fi

    # Remove sudo token fields from session
    local session_key="${current_server}:${current_tenant}"
    local temp_file=$(mktemp)
    jq --arg session_key "$session_key" \
       'del(.sessions[$session_key].sudo_token) |
        del(.sessions[$session_key].sudo_expires_at) |
        del(.sessions[$session_key].sudo_created_at) |
        del(.sessions[$session_key].sudo_reason)' \
       "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"
}

# Check if sudo token is expired
is_sudo_token_expired() {
    local sudo_token
    sudo_token=$(get_sudo_token 2>/dev/null)

    if [ -z "$sudo_token" ]; then
        return 1  # No token or expired
    fi

    return 0  # Token exists and is valid
}

# Make HTTP request with JSON content-type - programmatic by default
make_request_json() {
    local method="$1"
    local url="$2"
    local data="$3"
    local base_url=$(get_base_url)
    local full_url="${base_url}${url}"

    print_info "Making $method request to: $full_url"

    local curl_args=(-s -X "$method" -H "Content-Type: application/json")

    # Add JWT token if available (unless it's an auth request)
    if [[ "$url" != "/auth/"* ]]; then
        local jwt_token
        jwt_token=$(get_jwt_token)
        if [ -n "$jwt_token" ]; then
            curl_args+=(-H "Authorization: Bearer $jwt_token")
            print_info "Using stored JWT token"
        fi
    fi

    if [ -n "$data" ]; then
        curl_args+=(-d "$data")
    fi

    local response
    local http_code

    # Make request and capture both response and HTTP status code
    response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Handle HTTP errors
    case "$http_code" in
        200|201)
            print_success "Success ($http_code)"
            # Return response without formatting - let caller handle it
            echo "$response"
            return 0
            ;;
        400|404|500)
            # Format error output based on output mode
            output_format=$(get_output_format "text")

            if [[ "$output_format" == "json" ]]; then
                # JSON mode: output compact error without stack trace
                print_error "HTTP Error ($http_code)"
                if command -v jq >/dev/null 2>&1; then
                    echo "$response" | jq -c 'del(.data.stack)' >&2
                else
                    echo "$response" >&2
                fi
            else
                # Text mode: extract human-readable error
                print_error "HTTP Error ($http_code)"
                if command -v jq >/dev/null 2>&1; then
                    error_msg=$(echo "$response" | jq -r '.error // "Unknown error"' 2>/dev/null)
                    error_code=$(echo "$response" | jq -r '.error_code // ""' 2>/dev/null)
                    if [ -n "$error_code" ] && [ "$error_code" != "null" ]; then
                        echo "Error: $error_msg (code: $error_code)" >&2
                    else
                        echo "Error: $error_msg" >&2
                    fi
                else
                    echo "$response" >&2
                fi
            fi
            exit 1
            ;;
        *)
            print_error "HTTP $http_code"
            echo "$response" >&2
            exit 1
            ;;
    esac
}

# Handle response based on CLI flags - optimized for testing
handle_response_json() {
    local response="$1"
    local operation_type="$2"  # "list", "create", "select", etc.

    # Exit code only mode - no output, just exit status
    if [ "$CLI_EXIT_CODE_ONLY" = "true" ]; then
        if echo "$response" | grep -q '"success":true'; then
            exit 0
        else
            exit 1
        fi
    fi

    # Count mode for list operations
    if [ "$CLI_COUNT_MODE" = "true" ] && [ "$operation_type" = "list" ]; then
        if [ "$JSON_PARSER" = "jq" ]; then
            echo "$response" | jq '.data | length' 2>/dev/null || echo "0"
        elif [ "$JSON_PARSER" = "jshon" ]; then
            echo "$response" | jshon -e data -l 2>/dev/null || echo "0"
        else
            echo "$response"
        fi
        return
    fi

    # Field extraction mode
    if [ -n "$CLI_FORMAT" ]; then
        if [ "$JSON_PARSER" = "jq" ]; then
            # Handle both single objects and arrays
            if echo "$response" | jq -e '.data | type == "array"' >/dev/null 2>&1; then
                # Array case - extract field from each item
                echo "$response" | jq -r ".data[].${CLI_FORMAT}" 2>/dev/null || {
                    print_error "Failed to extract field: $CLI_FORMAT"
                    exit 1
                }
            else
                # Single object case - extract field directly
                echo "$response" | jq -r ".data.${CLI_FORMAT}" 2>/dev/null || {
                    print_error "Failed to extract field: $CLI_FORMAT"
                    exit 1
                }
            fi
        elif [ "$JSON_PARSER" = "jshon" ]; then
            echo "$response" | jshon -e data -e "$CLI_FORMAT" -u 2>/dev/null || {
                print_error "Failed to extract field: $CLI_FORMAT"
                exit 1
            }
        else
            print_error "jq or jshon required for field extraction"
            exit 1
        fi
        return
    fi

    # Default: auto-extract 'data' property and output as compact JSON
    if [ "$JSON_PARSER" = "jq" ]; then
        # Check if response has success:true and extract data
        if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
            if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
                # Success response - extract data as compact JSON
                echo "$response" | jq -c '.data'
            else
                # Error response - show full response for debugging as compact JSON
                echo "$response" | jq -c '.'
            fi
        else
            # Not a standard API response - show raw as compact JSON
            echo "$response" | jq -c '.'
        fi
    elif [ "$JSON_PARSER" = "jshon" ]; then
        # Check if response has success:true and extract data
        if echo "$response" | jshon -e success -u 2>/dev/null | grep -q "true"; then
            echo "$response" | jshon -e data 2>/dev/null || echo "$response"
        else
            echo "$response"
        fi
    else
        # No JSON parser - raw output
        echo "$response"
    fi
}

# Validate required arguments
require_args() {
    local required_count="$1"
    local actual_count="$2"
    local usage="$3"

    if [ "$actual_count" -lt "$required_count" ]; then
        print_error "Missing required arguments"
        print_info "Usage: $usage"
        exit 1
    fi
}

# Check dependencies - keep it simple
check_dependencies() {
    if ! command -v curl &> /dev/null; then
        print_error "curl is required but not installed."
        exit 1
    fi

    # Check for JSON parser for extraction operations (prefer jq over jshon)
    if command -v jq &> /dev/null; then
        export JSON_PARSER="jq"
    elif command -v jshon &> /dev/null; then
        export JSON_PARSER="jshon"
    else
        export JSON_PARSER="none"
    fi
}

# Legacy function - kept for compatibility
init_servers_config() {
    # Redirect to new CLI config initialization
    init_cli_configs
}

# Parse hostname:port into components
parse_endpoint() {
    local endpoint="$1"
    local hostname=""
    local port=""
    local protocol=""

    # Handle protocol prefixes
    if echo "$endpoint" | grep -q "^https://"; then
        protocol="https"
        endpoint=$(echo "$endpoint" | sed 's|^https://||')
    elif echo "$endpoint" | grep -q "^http://"; then
        protocol="http"
        endpoint=$(echo "$endpoint" | sed 's|^http://||')
    fi

    # Parse hostname:port
    if echo "$endpoint" | grep -q ":"; then
        hostname=$(echo "$endpoint" | cut -d':' -f1)
        port=$(echo "$endpoint" | cut -d':' -f2)
    else
        hostname="$endpoint"
        port="80"
    fi

    # Auto-detect protocol if not specified
    if [ -z "$protocol" ]; then
        if [ "$port" = "443" ]; then
            protocol="https"
        else
            protocol="http"
        fi
    fi

    echo "$protocol|$hostname|$port"
}

# Health check a server URL
ping_server_url() {
    local base_url="$1"
    local timeout="${2:-5}"

    # Try to ping the /ping endpoint with a short timeout
    if curl -s --max-time "$timeout" --fail "$base_url/ping" >/dev/null 2>&1; then
        return 0
    elif curl -s --max-time "$timeout" --fail "$base_url/" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Initialize tenant database schema
init_tenant_schema() {
    local tenant_name="$1"
    local db_user="${2:-$(whoami)}"

    # Find the schema file relative to the CLI root
    local schema_file=""

    # Try different possible locations for the schema file
    if [ -f "../sql/init-tenant.sql" ]; then
        schema_file="../sql/init-tenant.sql"
    elif [ -f "../../sql/init-tenant.sql" ]; then
        schema_file="../../sql/init-tenant.sql"
    elif [ -f "sql/init-tenant.sql" ]; then
        schema_file="sql/init-tenant.sql"
    else
        print_error "Schema file not found: init-tenant.sql"
        return 1
    fi

    print_info "Initializing tenant database schema..."
    if psql -U "$db_user" -d "$tenant_name" -f "$schema_file" >/dev/null 2>&1; then
        print_success "Tenant database schema initialized"
        return 0
    else
        print_error "Failed to initialize tenant database schema"
        return 1
    fi
}

# Make HTTP request with YAML content-type for meta API
make_request_yaml() {
    local method="$1"
    local url="$2"
    local data="$3"
    local base_url=$(get_base_url)
    local full_url="${base_url}${url}"

    print_info "Making $method request to: $full_url with YAML content-type"

    local curl_args=(-s -X "$method" -H "Content-Type: text/yaml")

    # Add JWT token if available (unless it's an auth request)
    if [[ "$url" != "/auth/"* ]]; then
        local jwt_token
        jwt_token=$(get_jwt_token)
        if [ -n "$jwt_token" ]; then
            curl_args+=(-H "Authorization: Bearer $jwt_token")
            print_info "Using stored JWT token"
        fi
    fi

    if [ -n "$data" ]; then
        curl_args+=(-d "$data")
    fi

    local response
    local http_code

    # Make request and capture both response and HTTP status code
    response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Handle HTTP errors
    case "$http_code" in
        200|201|204)
            print_success "Success ($http_code)"
            # Return response directly (YAML format)
            echo "$response"
            return 0
            ;;
        400|404|500)
            print_error "HTTP Error ($http_code)"
            echo "$response" >&2
            exit 1
            ;;
        *)
            print_error "HTTP $http_code"
            echo "$response" >&2
            exit 1
            ;;
    esac
}

# Handle YAML response - much simpler than JSON
handle_response_yaml() {
    local response="$1"
    local operation_type="$2"  # "create", "select", "update", "delete"

    # Exit code only mode - check if response is not empty for success
    if [ "$CLI_EXIT_CODE_ONLY" = "true" ]; then
        if [ -n "$response" ] || [ "$operation_type" = "delete" ]; then
            exit 0
        else
            exit 1
        fi
    fi

    # For YAML responses, just output directly
    echo "$response"
}

# Detect if input is array or object
detect_input_type() {
    local input="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        if echo "$input" | jq -e 'type == "array"' >/dev/null 2>&1; then
            echo "array"
        else
            echo "object"
        fi
    else
        # Fallback detection - check first non-whitespace character
        first_char=$(echo "$input" | sed 's/^[[:space:]]*//' | cut -c1)
        if [ "$first_char" = "[" ]; then
            echo "array"
        else
            echo "object"
        fi
    fi
}

# Extract ID from object
extract_id_from_object() {
    local input="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        echo "$input" | jq -r '.id // empty'
    elif [ "$JSON_PARSER" = "jshon" ]; then
        echo "$input" | jshon -e id -u 2>/dev/null || echo ""
    else
        # Fallback extraction
        echo "$input" | grep -o '"id"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | head -1
    fi
}

# Remove ID from object (for update operations)
remove_id_from_object() {
    local input="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        echo "$input" | jq 'del(.id)'
    elif [ "$JSON_PARSER" = "jshon" ]; then
        echo "$input" | jshon -d id 2>/dev/null || echo "$input"
    else
        # Fallback - remove id field (basic regex)
        echo "$input" | sed 's/"id"[[:space:]]*:[[:space:]]*"[^"]*"[[:space:]]*,\?//g' | sed 's/,[[:space:]]*}/}/g'
    fi
}

# Read and validate JSON input from stdin
read_and_validate_json_input() {
    local operation="$1"
    local schema="$2"

    # Read JSON data from stdin
    local json_data
    json_data=$(cat)

    if [ -z "$json_data" ]; then
        print_error "No JSON data provided on stdin"
        exit 1
    fi

    print_info "${operation^} $schema record(s) with data:"
    if [ "$CLI_VERBOSE" = "true" ]; then
        echo "$json_data" | sed 's/^/  /' >&2
    fi

    echo "$json_data"
}

# Process data operations with flexible input handling
process_data_operation() {
    local operation="$1"      # create/update/delete
    local http_method="$2"    # POST/PUT/DELETE
    local schema="$3"
    local id="$4"            # optional
    local json_data="$5"
    local confirmation="${6:-false}"  # require confirmation for destructive ops

    # Special case: DELETE with ID but no JSON data
    if [ "$operation" = "delete" ] && [ -n "$id" ] && [ -z "$json_data" ]; then
        if [ "$confirmation" = "true" ] && [ "$CLI_VERBOSE" = "true" ]; then
            print_warning "Are you sure you want to delete $schema record: $id? (y/N)"
            read -r user_confirmation

            if ! echo "$user_confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
                print_info "Operation cancelled"
                exit 0
            fi
        fi

        response=$(make_request_json "$http_method" "/api/data/$schema/$id" "")
        handle_response_json "$response" "$operation"
        return
    fi

    # All other cases require JSON data
    if [ -z "$json_data" ]; then
        print_error "No JSON data provided"
        exit 1
    fi

    # Detect input type and handle accordingly
    input_type=$(detect_input_type "$json_data")

    if [ -n "$id" ]; then
        # ID provided as parameter - use object endpoint
        print_info "Using provided ID: $id"

        # For object endpoint, remove ID from payload if present (API doesn't expect it)
        local clean_data
        if [ "$operation" = "update" ]; then
            clean_data=$(remove_id_from_object "$json_data")
        else
            clean_data="$json_data"
        fi

        response=$(make_request_json "$http_method" "/api/data/$schema/$id" "$clean_data")
        handle_response_json "$response" "$operation"

    elif [ "$input_type" = "array" ]; then
        # Array input  Bulk operation via array endpoint
        print_info "Processing array input for bulk $operation"
        response=$(make_request_json "$http_method" "/api/data/$schema" "$json_data")
        handle_response_json "$response" "$operation"

    elif [ "$operation" = "create" ]; then
        # CREATE: Object input  Array API  Object output (unwrap)
        print_info "Processing single object input"
        array_data="[$json_data]"
        response=$(make_request_json "$http_method" "/api/data/$schema" "$array_data")

        # Extract single object from array response to match input format
        if [ "$JSON_PARSER" = "jq" ]; then
            single_response=$(echo "$response" | jq '{"success": .success, "data": .data[0], "error": .error, "error_code": .error_code}' 2>/dev/null || echo "$response")
            handle_response_json "$single_response" "$operation"
        else
            handle_response_json "$response" "$operation"
        fi

    else
        # UPDATE/DELETE: Object input, no ID param  Extract ID from object, use object endpoint
        extracted_id=$(extract_id_from_object "$json_data")

        if [ -z "$extracted_id" ] || [ "$extracted_id" = "null" ]; then
            print_error "No ID provided as parameter and no 'id' field found in JSON object"
            print_info "Usage: monk data $operation $schema <id> OR provide JSON with 'id' field"
            exit 1
        fi

        print_info "Extracted ID from object: $extracted_id"

        # Confirmation for extracted ID delete operations
        if [ "$operation" = "delete" ] && [ "$confirmation" = "true" ] && [ "$CLI_VERBOSE" = "true" ]; then
            print_warning "Are you sure you want to delete $schema record: $extracted_id? (y/N)"
            read -r user_confirmation

            if ! echo "$user_confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
                print_info "Operation cancelled"
                exit 0
            fi
        fi

        # Remove ID from payload for object endpoint (UPDATE only)
        local clean_data
        if [ "$operation" = "update" ]; then
            clean_data=$(remove_id_from_object "$json_data")
        else
            clean_data=""  # DELETE doesn't need payload
        fi

        response=$(make_request_json "$http_method" "/api/data/$schema/$extracted_id" "$clean_data")
        handle_response_json "$response" "$operation"
    fi
}

# Check if JSON has complex where clause (indicating need for find command)
has_complex_query() {
    local json_data="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        # Check if 'where' field exists
        echo "$json_data" | jq -e '.where' >/dev/null 2>&1
    elif [ "$JSON_PARSER" = "jshon" ]; then
        echo "$json_data" | jshon -e where >/dev/null 2>&1
    else
        # Fallback: basic grep for "where" key
        echo "$json_data" | grep -q '"where"[[:space:]]*:'
    fi
}

# Build query string from JSON parameters (excluding 'where')
build_query_string() {
    local json_data="$1"
    local query_params=""

    if [ "$JSON_PARSER" = "jq" ]; then
        # Extract all keys except 'where' and build query string
        local keys
        keys=$(echo "$json_data" | jq -r 'del(.where) | to_entries[] | "\(.key)=\(.value)"' 2>/dev/null)

        if [ -n "$keys" ]; then
            # URL encode and join with &
            query_params=$(echo "$keys" | sed 's/ /+/g' | tr '\n' '&' | sed 's/&$//')
        fi
    elif [ "$JSON_PARSER" = "jshon" ]; then
        # Basic jshon parsing (limited functionality)
        local limit offset order
        limit=$(echo "$json_data" | jshon -e limit -u 2>/dev/null || echo "")
        offset=$(echo "$json_data" | jshon -e offset -u 2>/dev/null || echo "")
        order=$(echo "$json_data" | jshon -e order -u 2>/dev/null || echo "")

        local params=""
        [ -n "$limit" ] && params="${params}limit=${limit}&"
        [ -n "$offset" ] && params="${params}offset=${offset}&"
        [ -n "$order" ] && params="${params}order=$(echo "$order" | sed 's/ /+/g')&"

        query_params="${params%&}"  # Remove trailing &
    else
        # Fallback: basic regex extraction for common parameters
        local limit offset order
        limit=$(echo "$json_data" | grep -o '"limit"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*//')
        offset=$(echo "$json_data" | grep -o '"offset"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*//')
        order=$(echo "$json_data" | grep -o '"order"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*:[[:space:]]*"\([^"]*\)".*/\1/' | sed 's/ /+/g')

        local params=""
        [ -n "$limit" ] && params="${params}limit=${limit}&"
        [ -n "$offset" ] && params="${params}offset=${offset}&"
        [ -n "$order" ] && params="${params}order=${order}&"

        query_params="${params%&}"  # Remove trailing &
    fi

    if [ -n "$query_params" ]; then
        echo "?${query_params}"
    fi
}

# Redirect to find command with JSON input
redirect_to_find() {
    local schema="$1"
    local json_data="$2"

    print_info "Complex query detected, redirecting to 'monk find $schema'"

    # Execute find command with the JSON data
    echo "$json_data" | "${BASH_SOURCE[0]%/*}/find_command.sh" "$schema"
}

# Build file API request payload with path and options
build_file_payload() {
    local path="$1"
    local options="$2"

    if [ -n "$options" ]; then
        jq -n --arg path "$path" --argjson options "$options" \
           '{"path": $path, "file_options": $options}'
    else
        jq -n --arg path "$path" '{"path": $path}'
    fi
}

# Process file API response and extract specific field - UPDATED for new API format
process_file_response() {
    local response="$1"
    local extract_field="$2"  # "content", "data", "entries", etc. (optional)

    if [ "$JSON_PARSER" = "jq" ]; then
        if [ -n "$extract_field" ]; then
            # Handle nested data structure in new API format
            echo "$response" | jq ".data.$extract_field" 2>/dev/null
        else
            echo "$response"
        fi
    else
        print_error "jq required for file operations"
        exit 1
    fi
}

# Make file API request with standard error handling - UPDATED to use /api/file endpoints
make_file_request() {
    local endpoint="$1"    # list, retrieve, store, stat
    local payload="$2"

    local response
    response=$(make_request_json "POST" "/api/file/$endpoint" "$payload")

    # Check for file-specific error handling if needed
    echo "$response"
}

# Format ls-style output from FTP list entries - UPDATED for new API format
format_ls_output() {
    local entries="$1"
    local long_format="${2:-false}"

    if [ "$long_format" = "true" ]; then
        # Long format shows detailed information - use printf for formatting
        echo "$entries" | jq -r '.[] | "\(.file_permissions) \(.file_size | tostring) \(.file_modified) \(.name)"' | \
        while IFS=' ' read -r permissions size modified name; do
            printf "%-10s %8s %s %s\n" "$permissions" "$size" "$modified" "$name"
        done
    else
        # Simple format shows just names
        echo "$entries" | jq -r '.[] | .name'
    fi
}

# Parse tenant path and extract routing information
parse_tenant_path() {
    local path="$1"

    if [[ "$path" =~ ^/tenant/([^/]+)/(.*) ]]; then
        local tenant_spec="${BASH_REMATCH[1]}"
        local api_path="/${BASH_REMATCH[2]}"

        # Parse tenant specification (server:tenant or just tenant)
        if [[ "$tenant_spec" =~ ^([^:]+):(.+)$ ]]; then
            # Full server:tenant specification
            echo "server=${BASH_REMATCH[1]};tenant=${BASH_REMATCH[2]};path=$api_path;tenant_routing=true"
        else
            # Tenant only, use current server
            echo "server=current;tenant=$tenant_spec;path=$api_path;tenant_routing=true"
        fi
    else
        # Standard path, use current session
        echo "server=current;tenant=current;path=$path;tenant_routing=false"
    fi
}

# Get current session key (server:tenant)
current_session_key() {
    local current_server current_tenant
    current_server=$(jq -r '.current_server' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant' "$ENV_CONFIG" 2>/dev/null)

    if [ -n "$current_server" ] && [ "$current_server" != "null" ] &&

       [ -n "$current_tenant" ] && [ "$current_tenant" != "null" ]; then
        echo "${current_server}:${current_tenant}"
    else
        return 1
    fi
}

# Resolve session key from server and tenant specifications
resolve_session() {
    local server="$1"
    local tenant="$2"

    # Handle "current" values
    if [ "$server" = "current" ]; then
        server=$(jq -r '.current_server' "$ENV_CONFIG" 2>/dev/null)
    fi
    if [ "$tenant" = "current" ]; then
        tenant=$(jq -r '.current_tenant' "$ENV_CONFIG" 2>/dev/null)
    fi

    # Validate inputs
    if [ -z "$server" ] || [ "$server" = "null" ]; then
        print_error "No server specified and no current server selected"
        return 1
    fi
    if [ -z "$tenant" ] || [ "$tenant" = "null" ]; then
        print_error "No tenant specified and no current tenant selected"

        return 1
    fi

    # Build and validate session key
    local session_key="${server}:${tenant}"

    if jq -e ".sessions.\"$session_key\"" "$AUTH_CONFIG" >/dev/null 2>&1; then
        echo "$session_key"
    else
        print_error "No authentication found for $session_key"
        print_info_always "Use 'monk auth login $tenant <username>' on server '$server' to authenticate"
        return 1
    fi
}

# Temporarily switch context for single operation
with_tenant_context() {
    local target_session_key="$1"
    local operation_func="$2"
    shift 2
    local args=("$@")

    # Save current context
    local original_server original_tenant original_user
    original_server=$(jq -r '.current_server' "$ENV_CONFIG" 2>/dev/null)
    original_tenant=$(jq -r '.current_tenant' "$ENV_CONFIG" 2>/dev/null)

    original_user=$(jq -r '.current_user' "$ENV_CONFIG" 2>/dev/null)

    # Parse target session
    local target_server target_tenant
    target_server=$(echo "$target_session_key" | cut -d':' -f1)
    target_tenant=$(echo "$target_session_key" | cut -d':' -f2)

    # Get user from session
    local target_user
    target_user=$(jq -r ".sessions.\"$target_session_key\".user" "$AUTH_CONFIG" 2>/dev/null)

    print_info "Switching to context: $target_session_key (user: $target_user)"

    # Temporarily update env context
    local temp_file=$(mktemp)
    jq --arg server "$target_server" \
       --arg tenant "$target_tenant" \
       --arg user "$target_user" \
       '.current_server = $server | .current_tenant = $tenant | .current_user = $user' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

    # Execute operation with new context
    local result exit_code
    result=$("$operation_func" "${args[@]}")
    exit_code=$?

    # Restore original context

    temp_file=$(mktemp)
    jq --arg server "$original_server" \
       --arg tenant "$original_tenant" \
       --arg user "$original_user" \
       '.current_server = $server | .current_tenant = $tenant | .current_user = $user' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

    print_info "Restored context: $original_server:$original_tenant"

    echo "$result"
    return $exit_code
}

# Enhanced file API request with tenant routing support
make_file_request_with_routing() {
    local endpoint="$1"    # list, stat, retrieve, store
    local path="$2"
    local options="$3"
    local tenant_flag="$4" # Optional --tenant flag value

    local routing_info target_session_key api_path

    # Determine routing: flag takes precedence over path-based routing
    if [ -n "$tenant_flag" ]; then
        # Use --tenant flag specification
        if [[ "$tenant_flag" =~ ^([^:]+):(.+)$ ]]; then
            # Full server:tenant from flag
            target_session_key=$(resolve_session "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")
        else
            # Tenant only from flag, use current server

            target_session_key=$(resolve_session "current" "$tenant_flag")
        fi
        api_path="$path"  # Use path as-is when flag provided

    else
        # Parse path for tenant routing
        routing_info=$(parse_tenant_path "$path")
        eval "$routing_info"  # Sets server, tenant, path, tenant_routing variables

        if [ "$tenant_routing" = "true" ]; then
            target_session_key=$(resolve_session "$server" "$tenant")
            api_path="$path"  # api_path from parsing
        else
            # Standard operation with current session
            target_session_key=$(current_session_key)
            api_path="$path"
        fi
    fi

    # Validate session exists
    if ! validate_session "$target_session_key"; then
        return 1
    fi

    # Build payload
    local payload
    payload=$(build_file_payload "$api_path" "$options")

    # Execute request with appropriate context
    local current_key
    current_key=$(current_session_key 2>/dev/null)

    if [ "$target_session_key" = "$current_key" ]; then
        # Same as current context - direct execution
        make_file_request "$endpoint" "$payload"
    else
        # Different context - use temporary switching
        with_tenant_context "$target_session_key" make_file_request "$endpoint" "$payload"
    fi
}

# Validate session exists and has valid authentication
validate_session() {
    local session_key="$1"

    if [ -z "$session_key" ]; then
        return 1
    fi

    local jwt_token
    jwt_token=$(jq -r ".sessions.\"$session_key\".jwt_token" "$AUTH_CONFIG" 2>/dev/null)

    if [ -n "$jwt_token" ] && [ "$jwt_token" != "null" ]; then
        return 0
    else
        return 1
    fi
}

# Validate schema exists (best effort)
validate_schema() {
    local schema="$1"

    # Don't validate if running in non-verbose mode for speed
    if [ "$CLI_VERBOSE" != "true" ]; then
        return 0
    fi

    # Try to get schema info - if it fails, just warn but continue
    local response
    if response=$(make_request_json "GET" "/api/meta/schema" "" 2>/dev/null); then
        if echo "$response" | grep -q "\"$schema\""; then
            print_info "Schema validated: $schema"
        else
            print_warning "Schema '$schema' not found in meta API, but continuing anyway"
        fi
    else
        print_info "Could not validate schema dynamically, assuming valid: $schema"
    fi
}

# URL encode a string for safe HTTP requests
url_encode() {
    local string="$1"
    # Use python for proper URL encoding if available, otherwise basic sed
    if command -v python3 >/dev/null 2>&1; then
        python3 -c "import urllib.parse; print(urllib.parse.quote('''$string''', safe=''))"
    else
        # Fallback: basic encoding for common characters
        printf '%s' "$string" | sed \
            -e 's/ /%20/g' \
            -e 's/!/%21/g' \
            -e 's/"/%22/g' \
            -e 's/#/%23/g' \
            -e 's/\$/%24/g' \
            -e 's/%/%25/g' \
            -e 's/&/%26/g' \
            -e "s/'/%27/g"
    fi
}

# Make HTTP request to sudo API (requires sudo token from /api/auth/sudo)
make_sudo_request() {
    local method="$1"
    local endpoint="$2"  # e.g., "users", "users/:id"
    local data="$3"
    local base_url=$(get_base_url)

    # Get sudo token
    local sudo_token
    sudo_token=$(get_sudo_token)

    if [ -z "$sudo_token" ]; then
        print_error "No sudo token found or token expired"
        print_info "Use 'monk auth sudo' to acquire a sudo token first"
        exit 1
    fi

    local full_url="${base_url}/api/sudo/${endpoint}"

    print_info "Making $method request to: $full_url"

    local curl_args=(-s -X "$method")

    # Add sudo token
    curl_args+=(-H "Authorization: Bearer $sudo_token")
    print_info "Using stored sudo token"

    # Add content-type header if data provided
    if [ -n "$data" ]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi

    local response
    local http_code

    # Make request and capture both response and HTTP status code
    response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Handle HTTP errors
    case "$http_code" in
        200|201|204)
            print_success "Success ($http_code)"
            echo "$response"
            return 0
            ;;
        401)
            print_error "HTTP Error ($http_code) - Unauthorized"
            print_info "Your sudo token may have expired. Use 'monk auth sudo' to get a new token"
            echo "$response" >&2
            exit 1
            ;;
        403)
            print_error "HTTP Error ($http_code) - Forbidden"
            print_info "Sudo token required. Use 'monk auth sudo' to escalate privileges"
            echo "$response" >&2
            exit 1
            ;;
        400|404|409|500)
            print_error "HTTP Error ($http_code)"
            echo "$response" >&2
            exit 1
            ;;
        *)
            print_error "HTTP $http_code"
            echo "$response" >&2
            exit 1
            ;;
    esac
}

# Confirm destructive operation with user input
confirm_destructive_operation() {
    local operation="$1"
    local target="$2"
    local force_flag="$3"
    local confirmation_word="${4:-y}"  # Default to 'y', or use custom word like 'DELETE'

    if [[ "$force_flag" == "1" ]]; then
        return 0  # Skip confirmation if --force used
    fi

    if [[ "$confirmation_word" == "y" ]]; then
        print_warning "Are you sure you want to $operation '$target'? (y/N)"
        read -r user_input

        if echo "$user_input" | grep -E "^[Yy]$" >/dev/null 2>&1; then
            return 0
        else
            print_info "Operation cancelled"
            exit 0
        fi
    else
        print_warning "DANGER: This will $operation '$target'!"
        print_warning "Type '$confirmation_word' to confirm:"
        read -r user_input

        if [[ "$user_input" == "$confirmation_word" ]]; then
            return 0
        else
            print_info "Operation cancelled"
            exit 0
        fi
    fi
}

# Determine output format from global flags
get_output_format() {
    local default_format="$1"  # "text" or "json"

    # Check global flags
    if [[ "${args[--text]}" == "1" ]]; then
        echo "text"
    elif [[ "${args[--json]}" == "1" ]]; then
        echo "json"
    else
        echo "$default_format"
    fi
}

# Validate format compatibility and show error if incompatible
validate_output_format() {
    local requested_format="$1"
    local supported_formats="$2"  # Space-separated list: "text json"

    if [[ "$supported_formats" == *"$requested_format"* ]]; then
        return 0
    else
        print_error "Output format '$requested_format' not supported for this command"
        print_info "Supported formats: $(echo "$supported_formats" | tr ' ' ', ')"
        exit 1
    fi
}

# Convert JSON to human-readable text format
json_to_text() {
    local json_data="$1"
    local context="$2"  # Context hint for formatting (e.g., "server_list", "tenant_status")

    if [ "$JSON_PARSER" != "jq" ]; then
        print_error "jq required for text formatting"
        echo "$json_data"
        return
    fi

    case "$context" in
        "server_list")
            echo
            printf "%-15s %-30s %-8s %-8s %-12s %-20s %s\n" "Name" "Endpoint" "Status" "Auth" "Last Ping" "Added" "Description"
            echo "--------------------------------------------------------------------------------------------"
            echo "$json_data" | jq -r '.servers[]? | [.name, .endpoint, .status, (if .auth_sessions > 0 then "yes (\(.auth_sessions))" else "no" end), (.last_ping | split("T")[0]), (.added_at | split("T")[0]), .description] | @tsv' | \
            while IFS=$'\t' read -r name endpoint status auth last_ping added desc; do
                current_marker=""
                if echo "$json_data" | jq -e ".current_server == \"$name\"" >/dev/null 2>&1; then
                    current_marker=" *"
                fi
                printf "%-15s %-30s %-8s %-8s %-12s %-20s %s%s\n" "$name" "$endpoint" "$status" "$auth" "$last_ping" "$added" "$desc" "$current_marker"
            done
            echo
            ;;
        "tenant_list")
            echo
            printf "%-20s %-30s %-8s %-20s %s\n" "Name" "Display Name" "Auth" "Added" "Description"
            echo "-------------------------------------------------------------------------------------"
            echo "$json_data" | jq -r '.tenants[]? | [.name, .display_name, (if .authenticated then "yes" else "no" end), (.added_at | split("T")[0]), .description] | @tsv' | \
            while IFS=$'\t' read -r name display_name auth added desc; do
                current_marker=""
                if echo "$json_data" | jq -e ".current_tenant == \"$name\"" >/dev/null 2>&1; then
                    current_marker=" *"
                fi
                printf "%-20s %-30s %-8s %-20s %s%s\n" "$name" "$display_name" "$auth" "$added" "$desc" "$current_marker"
            done
            echo
            ;;
        "auth_status")
            if echo "$json_data" | jq -e '.authenticated' >/dev/null 2>&1; then
                local tenant=$(echo "$json_data" | jq -r '.current_context.tenant')
                local server=$(echo "$json_data" | jq -r '.current_context.server')
                local user=$(echo "$json_data" | jq -r '.current_context.user')
                local database=$(echo "$json_data" | jq -r '.token_info.database')
                local exp_date=$(echo "$json_data" | jq -r '.token_info.exp_date')

                echo "Tenant: $tenant"
                echo "Database: $database"
                echo "Expires: $exp_date"
                echo "Server: $server"
                echo "Tenant: $tenant"
                echo "User: $user"
                print_success "Authenticated"
            else
                print_error "Not authenticated"
            fi
            ;;
        "data_table")
            # Generic data table - try to format as table if array
            if echo "$json_data" | jq -e 'type == "array"' >/dev/null 2>&1; then
                if echo "$json_data" | jq -e 'length > 0' >/dev/null 2>&1; then
                    # Get column headers from first object
                    local headers=$(echo "$json_data" | jq -r '.[0] | keys_unsorted | @tsv')
                    echo "$headers" | tr '\t' '\n' | nl -w3 -s') ' -v0
                    echo "---"
                    echo "$json_data" | jq -r '.[] | [.[] | tostring] | @tsv'
                else
                    echo "No data found"
                fi
            else
                echo "$json_data" | jq '.'
            fi
            ;;
        *)
            # Default: output compact JSON for machine readability
            echo "$json_data" | jq -c '.'
            ;;
    esac
}

# Convert JSON to YAML format
json_to_yaml() {
    local json_data="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        # Use yq if available, otherwise fallback to compact JSON with warning
        if command -v yq >/dev/null 2>&1; then
            echo "$json_data" | yq -P '.'
        else
            print_warning "yq not available - outputting compact JSON instead of YAML" >&2
            echo "$json_data" | jq -c '.'
        fi
    else
        print_error "jq required for YAML conversion"
        echo "$json_data"
    fi
}

# Convert YAML to JSON format
yaml_to_json() {
    local yaml_data="$1"

    if command -v yq >/dev/null 2>&1; then
        echo "$yaml_data" | yq -o=json '.'
    else
        print_error "yq required for YAML to JSON conversion"
        echo "$yaml_data"
    fi
}

# Detect input format based on first non-whitespace character
detect_input_format() {
    local input_data="$1"

    # Get first non-whitespace character
    local first_char=$(echo "$input_data" | sed 's/^[[:space:]]*//' | cut -c1)

    if [[ "$first_char" == "{" || "$first_char" == "[" ]]; then
        echo "json"
    else
        echo "yaml"
    fi
}

# Convert JSON to YAML with graceful fallback
convert_json_to_yaml() {
    local json_data="$1"

    # Try yq first (best option)
    if command -v yq >/dev/null 2>&1; then
        echo "$json_data" | yq -P '.'
        return $?
    fi

    # Try python fallback
    if command -v python3 >/dev/null 2>&1; then
        if echo "$json_data" | python3 -c "import yaml,json,sys; print(yaml.dump(json.load(sys.stdin), default_flow_style=False).rstrip())" 2>/dev/null; then
            return 0
        fi
    fi

    # Try ruby fallback

    if command -v ruby >/dev/null 2>&1; then
        if echo "$json_data" | ruby -e "require 'yaml','json'; puts YAML.dump(JSON.parse(STDIN.read))" 2>/dev/null; then
            return 0
        fi
    fi

    return 1
}

# Convert YAML to JSON with graceful fallback
convert_yaml_to_json() {
    local yaml_data="$1"

    # Try yq first (best option)
    if command -v yq >/dev/null 2>&1; then
        echo "$yaml_data" | yq -o=json '.'
        return $?
    fi

    # Try python fallback
    if command -v python3 >/dev/null 2>&1; then
        if echo "$yaml_data" | python3 -c "import yaml,json,sys; print(json.dumps(yaml.safe_load(sys.stdin), separators=(',', ':')))" 2>/dev/null; then
            return 0
        fi
    fi

    # Try ruby fallback
    if command -v ruby >/dev/null 2>&1; then
        if echo "$yaml_data" | ruby -e "require 'yaml','json'; puts JSON.generate(YAML.load(STDIN.read))" 2>/dev/null; then
            return 0
        fi
    fi

    return 1
}

# Make HTTP request with YAML content-type and JSON/YAML autodetect
make_request_yaml_autodetect() {
    local method="$1"
    local url="$2"
    local input_data="$3"
    local input_format="$4"

    local yaml_data="$input_data"

    # Convert JSON to YAML if needed
    if [[ "$input_format" == "json" ]]; then
        print_info "Converting JSON input to YAML for API"

        yaml_data=$(convert_json_to_yaml "$input_data")
        if [[ $? -ne 0 ]]; then
            print_error "Failed to convert JSON input to YAML"
            print_info "JSON input detected but no suitable conversion tool available"
            print_info "Please install 'yq' or provide input in YAML format instead"
            print_info "Example: cat schema.yaml | monk describe select"
            exit 1
        fi
    fi

    # Make standard YAML request
    make_request_yaml "$method" "$url" "$yaml_data"
}

# Handle YAML response with JSON/YAML autodetect conversion
handle_response_yaml_autodetect() {
    local response="$1"
    local operation_type="$2"
    local original_input_format="$3"

    # Convert YAML response to JSON if original input was JSON
    if [[ "$original_input_format" == "json" && -n "$response" ]]; then
        print_info "Converting YAML response to JSON for format consistency"

        local json_response
        json_response=$(convert_yaml_to_json "$response")
        if [[ $? -eq 0 ]]; then
            # Output the JSON response (compact format)
            echo "$json_response" | jq -c '.' 2>/dev/null || echo "$json_response"
            return
        else
            print_warning "Failed to convert YAML response to JSON, outputting original YAML"
        fi
    fi

    # Default: handle as standard YAML response
    handle_response_yaml "$response" "$operation_type"
}

# Universal output handler - handles text and JSON formats
handle_output() {
    local data="$1"
    local requested_format="$2"
    local default_format="$3"
    local context="${4:-default}"
    local supported_formats="${5:-text json}"

    # Validate format is supported
    validate_output_format "$requested_format" "$supported_formats"

    # Handle JSON format - always compress to single line for machine readability
    if [[ "$requested_format" == "json" ]]; then
        if [[ "$default_format" == "json" ]]; then
            # Already JSON - compress it
            echo "$data" | jq -c '.'
        else
            print_error "Cannot convert text output to structured format"
            print_info "Text format is human-readable only"
            exit 1
        fi
        return
    fi

    # Handle text format
    if [[ "$requested_format" == "text" ]]; then
        if [[ "$default_format" == "text" ]]; then
            # Already text - output directly
            echo "$data"
        elif [[ "$default_format" == "json" ]]; then
            # Convert JSON to text
            json_to_text "$data" "$context"
        else
            print_error "Unsupported format conversion: $default_format to $requested_format"
            echo "$data"
        fi
        return
    fi

    # Fallback: output data as-is
    echo "$data"
}

# Sync Helper Functions

# Parse sync endpoint into components
# Formats supported:
#   tenant:schema                 (current server)
#   server:tenant:schema          (specific server)
#   /path/to/directory            (local filesystem)
#   ./relative/path               (local filesystem)
#
# Returns JSON object with:
#   {"type": "remote|local", "server": "...", "tenant": "...", "schema": "...", "path": "..."}
parse_sync_endpoint() {
    local endpoint="$1"

    # Check if it's a directory path
    if [[ "$endpoint" =~ ^[./] ]] || [[ "$endpoint" == /* ]]; then
        echo "{\"type\":\"local\",\"path\":\"$endpoint\"}"
        return 0
    fi

    # Count colons to determine format
    local colon_count=$(echo "$endpoint" | tr -cd ':' | wc -c | tr -d ' ')

    if [ "$colon_count" -eq 1 ]; then
        # Format: tenant:schema
        local tenant=$(echo "$endpoint" | cut -d: -f1)
        local schema=$(echo "$endpoint" | cut -d: -f2)
        local server=$(get_current_server_name)

        if [ -z "$server" ]; then
            print_error "No current server set. Use 'monk server use <name>' first."
            return 1
        fi

        echo "{\"type\":\"remote\",\"server\":\"$server\",\"tenant\":\"$tenant\",\"schema\":\"$schema\"}"
        return 0

    elif [ "$colon_count" -eq 2 ]; then
        # Format: server:tenant:schema
        local server=$(echo "$endpoint" | cut -d: -f1)
        local tenant=$(echo "$endpoint" | cut -d: -f2)
        local schema=$(echo "$endpoint" | cut -d: -f3)

        echo "{\"type\":\"remote\",\"server\":\"$server\",\"tenant\":\"$tenant\",\"schema\":\"$schema\"}"
        return 0
    else
        print_error "Invalid endpoint format: $endpoint"
        print_info "Expected: tenant:schema, server:tenant:schema, or /path/to/dir"
        return 1
    fi
}

# Fetch data from a remote endpoint
# Args: server, tenant, schema, filter_json
# Returns: JSON array of records
sync_fetch_remote() {
    local server="$1"
    local tenant="$2"
    local schema="$3"
    local filter_json="$4"

    # Save current context
    local prev_server=$(get_current_server_name)
    local prev_tenant=$(get_current_tenant_name)

    # Switch to target context
    if [ "$server" != "$prev_server" ]; then
        switch_server "$server" >/dev/null 2>&1 || {
            print_error "Failed to switch to server: $server"
            return 1
        }
    fi

    if [ "$tenant" != "$prev_tenant" ]; then
        switch_tenant "$tenant" >/dev/null 2>&1 || {
            print_error "Failed to switch to tenant: $tenant"
            # Restore previous server
            [ -n "$prev_server" ] && switch_server "$prev_server" >/dev/null 2>&1
            return 1
        }
    fi

    # Fetch data
    local response
    if [ -n "$filter_json" ] && [ "$filter_json" != "null" ]; then
        # Use find API with filter
        response=$(make_request_json "POST" "/api/find/$schema" "$filter_json")
    else
        # Use data list API
        response=$(make_request_json "GET" "/api/data/$schema" "")
    fi

    # Restore previous context
    [ -n "$prev_tenant" ] && switch_tenant "$prev_tenant" >/dev/null 2>&1
    [ -n "$prev_server" ] && switch_server "$prev_server" >/dev/null 2>&1

    # Extract data array from response
    if [ "$JSON_PARSER" = "jq" ]; then
        if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
            echo "$response" | jq -c '.data'
        else
            print_error "API request failed"
            echo "$response" | jq -r '.error // "Unknown error"' >&2
            return 1
        fi
    else
        echo "$response"
    fi
}

# Compute diff between two datasets
# Args: source_data (JSON array), dest_data (JSON array)
# Returns: JSON diff object
sync_compute_diff() {
    local source_data="$1"
    local dest_data="$2"

    if [ "$JSON_PARSER" != "jq" ]; then
        print_error "jq is required for diff computation"
        return 1
    fi

    # Compute diff using jq
    jq -n \
        --argjson source "$source_data" \
        --argjson dest "$dest_data" '
        # Build ID-keyed maps
        ($source | map({(.id): .}) | add // {}) as $src_map |
        ($dest | map({(.id): .}) | add // {}) as $dst_map |

        # Find all unique IDs
        (($src_map | keys) + ($dst_map | keys) | unique) as $all_ids |

        # Categorize operations
        {
            summary: {
                source_count: ($source | length),
                dest_count: ($dest | length),
                total_ids: ($all_ids | length)
            },
            operations: (
                $all_ids | map(
                    . as $id |
                    if ($src_map | has($id) | not) then
                        {op: "delete", id: $id, record: $dst_map[$id]}
                    elif ($dst_map | has($id) | not) then
                        {op: "insert", id: $id, record: $src_map[$id]}
                    elif ($src_map[$id] == $dst_map[$id]) then
                        {op: "unchanged", id: $id}
                    else
                        {
                            op: "update",
                            id: $id,
                            old: $dst_map[$id],
                            new: $src_map[$id]
                        }
                    end
                )
            )
        } |
        # Add operation counts to summary
        .summary += {
            unchanged: ([.operations[] | select(.op == "unchanged")] | length),
            to_insert: ([.operations[] | select(.op == "insert")] | length),
            to_update: ([.operations[] | select(.op == "update")] | length),
            to_delete: ([.operations[] | select(.op == "delete")] | length)
        }
    '
}

# Format diff output for display
# Args: diff_json, format (summary|json)
sync_format_diff() {
    local diff_json="$1"
    local format="$2"

    if [ "$format" = "json" ]; then
        echo "$diff_json" | jq '.'
        return 0
    fi

    # Summary format (default)
    local source_count=$(echo "$diff_json" | jq -r '.summary.source_count')
    local dest_count=$(echo "$diff_json" | jq -r '.summary.dest_count')
    local unchanged=$(echo "$diff_json" | jq -r '.summary.unchanged')
    local to_insert=$(echo "$diff_json" | jq -r '.summary.to_insert')
    local to_update=$(echo "$diff_json" | jq -r '.summary.to_update')
    local to_delete=$(echo "$diff_json" | jq -r '.summary.to_delete')

    local total=$((unchanged + to_insert + to_update + to_delete))

    # Calculate percentages
    local unchanged_pct=0
    local insert_pct=0
    local update_pct=0
    local delete_pct=0

    if [ "$total" -gt 0 ]; then
        unchanged_pct=$(awk "BEGIN {printf \"%.1f\", ($unchanged / $total) * 100}")
        insert_pct=$(awk "BEGIN {printf \"%.1f\", ($to_insert / $total) * 100}")
        update_pct=$(awk "BEGIN {printf \"%.1f\", ($to_update / $total) * 100}")
        delete_pct=$(awk "BEGIN {printf \"%.1f\", ($to_delete / $total) * 100}")
    fi

    # Print summary
    echo "Sync Diff Summary"
    echo ""
    echo "Source records:      $source_count"
    echo "Destination records: $dest_count"
    echo ""
    echo "Changes:"
    echo "   Unchanged:       $unchanged records (${unchanged_pct}%)"

    if [ "$to_insert" -gt 0 ]; then
        echo "  + To insert:       $to_insert records (${insert_pct}%)"
    fi

    if [ "$to_update" -gt 0 ]; then
        echo "  ~ To update:       $to_update records (${update_pct}%)"
    fi

    if [ "$to_delete" -gt 0 ]; then
        echo "  - To delete:       $to_delete records (${delete_pct}%)"
    fi

    echo ""

    # Show totals
    local changes=$((to_insert + to_update + to_delete))
    if [ "$changes" -eq 0 ]; then
        echo "No changes needed - datasets are identical"
    else
        echo "Total changes: $changes operations"
    fi
}

# :command.command_functions
# :command.function
monk_init_command() {

  # src/commands/init.sh
  #!/bin/bash

  # init_command.sh - Initialize CLI configuration directory with complete structure
  #
  # This command creates the CLI configuration directory and initializes all config files
  # for clean domain separation following the new architecture.
  #
  # Creates:
  #   ~/.config/monk/cli/server.json  - Server endpoint registry
  #   ~/.config/monk/cli/tenant.json  - Tenant registry (server-scoped)
  #   ~/.config/monk/cli/auth.json    - Authentication sessions (per server+tenant)
  #   ~/.config/monk/cli/env.json     - Current working context (server+tenant+user)

  # Get arguments from bashly
  path="${args[path]}"
  force_flag="${args[--force]}"

  # Set configuration path (respects MONK_CLI_CONFIG_DIR environment variable)
  if [[ -n "$path" ]]; then
      cli_config_dir="$path"
  else
      cli_config_dir="${MONK_CLI_CONFIG_DIR:-${HOME}/.config/monk/cli}"
  fi

  # Colors for output
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  RED='\033[0;31m'
  NC='\033[0m' # No Color

  echo -e "${BLUE}Initializing Monk CLI configuration...${NC}"
  echo "Configuration path: ${cli_config_dir}"

  # Create CLI directory if it doesn't exist
  if [[ ! -d "$cli_config_dir" ]]; then
      echo -e "${YELLOW}${NC} Creating CLI directory: ${cli_config_dir}"
      mkdir -p "$cli_config_dir"
  else
      echo -e "${GREEN}${NC} CLI directory exists: ${cli_config_dir}"
  fi

  # Initialize server.json
  server_file="${cli_config_dir}/server.json"
  if [[ ! -f "$server_file" ]] || [[ "$force_flag" = "1" ]]; then
      if [[ -f "$server_file" ]] && [[ "$force_flag" = "1" ]]; then
          echo -e "${YELLOW}${NC} Force overwriting server.json"
      else
          echo -e "${YELLOW}${NC} Creating server.json"
      fi
      cat > "$server_file" << 'EOF'
{
  "servers": {}
}
EOF
      echo -e "${GREEN}${NC} Created server.json"
  else
      echo -e "${GREEN}${NC} server.json already exists"
  fi

  # Initialize tenant.json
  tenant_file="${cli_config_dir}/tenant.json"
  if [[ ! -f "$tenant_file" ]] || [[ "$force_flag" = "1" ]]; then
      if [[ -f "$tenant_file" ]] && [[ "$force_flag" = "1" ]]; then
          echo -e "${YELLOW}${NC} Force overwriting tenant.json"
      else
          echo -e "${YELLOW}${NC} Creating tenant.json"
      fi
      cat > "$tenant_file" << 'EOF'
{
  "tenants": {}
}
EOF
      echo -e "${GREEN}${NC} Created tenant.json"
  else
      echo -e "${GREEN}${NC} tenant.json already exists"
  fi

  # Initialize auth.json
  auth_file="${cli_config_dir}/auth.json"
  if [[ ! -f "$auth_file" ]] || [[ "$force_flag" = "1" ]]; then
      if [[ -f "$auth_file" ]] && [[ "$force_flag" = "1" ]]; then
          echo -e "${YELLOW}${NC} Force overwriting auth.json"
      else
          echo -e "${YELLOW}${NC} Creating auth.json"
      fi
      cat > "$auth_file" << 'EOF'
{
  "sessions": {}
}
EOF
      chmod 600 "$auth_file"
      echo -e "${GREEN}${NC} Created auth.json (secure permissions)"
  else
      echo -e "${GREEN}${NC} auth.json already exists"
  fi

  # Initialize env.json (never force overwrite - preserve user context)
  env_file="${cli_config_dir}/env.json"
  if [[ ! -f "$env_file" ]]; then
      echo -e "${YELLOW}${NC} Creating env.json"
      cat > "$env_file" << 'EOF'
{
  "current_server": null,
  "current_tenant": null,
  "current_user": null,
  "recents": []
}
EOF
      echo -e "${GREEN}${NC} Created env.json"
  else
      echo -e "${GREEN}${NC} env.json already exists (preserved)"
      if [[ "$force_flag" = "1" ]]; then
          echo -e "${BLUE}${NC} env.json is never overwritten to preserve your context"
      fi
  fi

  echo -e "${GREEN}${NC} Monk CLI configuration initialized successfully!"
  echo
  echo "CLI configuration files created in: ${cli_config_dir}"
  echo "  - server.json: Server endpoint registry"
  echo "  - tenant.json: Tenant registry (server-scoped)"
  echo "  - auth.json: Authentication sessions per server+tenant"

  echo "  - env.json: Current working context (server+tenant+user)"
  echo
  echo "Next steps:"
  echo "  1. Add a server: monk server add <name> <hostname:port>"
  echo "  2. Add a tenant: monk tenant add <name> <display_name>"
  echo "  3. Select server: monk server use <name>"
  echo "  4. Select tenant: monk tenant use <name>"
  echo "  5. Authenticate: monk auth login <tenant> <username>"
  echo "  6. Start working: monk data select <schema>"
}

# :command.function
monk_examples_command() {

  # src/commands/examples.sh
  #!/bin/bash

  # examples_command.sh - Browse and display usage examples from GitHub

  # Check dependencies
  check_dependencies

  init_cli_configs

  # Get current CLI version
  get_current_version() {
      monk --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+'
  }

  # Get examples for current version (local first, then GitHub)
  get_examples_for_version() {
      local version=$(get_current_version)

      # First try local examples directory
      if [[ -d "examples" ]]; then
          ls -1 examples/*.md 2>/dev/null | while read -r file; do
              local name=$(basename "$file" .md)
              local url="file://$PWD/$file"
              echo "${name}|${url}"
          done
          return
      fi

      # Fall back to GitHub API
      local tag="v${version}"
      local repo="ianzepp/monk-cli"  # Discovered via git remote

      # GitHub API: Get directory contents for specific tag
      local api_url="https://api.github.com/repos/${repo}/contents/examples?ref=${tag}"

      curl -s "$api_url" | jq -r '.[] | select(.type == "file") | "\(.name)|\(.download_url)"' 2>/dev/null || echo ""
  }

  # List all available examples
  list_examples() {
      local examples=$(get_examples_for_version)

      if [[ -z "$examples" ]]; then
          print_error "No examples found for version $(get_current_version)"
          print_info "This might be an older version without examples"
          return 1
      fi

      echo "Available examples for monk $(get_current_version):"
      echo

      echo "$examples" | while IFS='|' read -r name url; do
          # Extract title from first line of markdown
          local title=$(curl -s "$url" | head -5 | grep '^# ' | sed 's/^# //' | head -1)
          if [[ -z "$title" ]]; then
              title="No title available"
          fi
          echo "  ${name%.md} - $title"
      done

      echo
      echo "Use 'monk examples <name>' to view an example"
  }

  # Show specific example
  show_example() {
      local example_name="$1"
      local version=$(get_current_version)
      local content=""

      # First try local file
      local local_file="examples/${example_name}.md"
      if [[ -f "$local_file" ]]; then
          content=$(cat "$local_file")
      else
          # Fall back to GitHub
          local tag="v${version}"
          local repo="ianzepp/monk-cli"  # Discovered via git remote

          # Direct raw URL for the file
          local raw_url="https://raw.githubusercontent.com/${repo}/${tag}/examples/${example_name}.md"

          content=$(curl -s "$raw_url")

          if [[ -z "$content" ]] || echo "$content" | grep -q "404: Not Found"; then
              print_error "Example '${example_name}' not found for version ${version}"
              print_info "Try 'monk examples list' to see available examples"
              return 1
          fi
      fi

      # Determine output format
      local output_format=$(get_output_format "glow")

      # Display content based on format and TTY
      if [[ "$output_format" == "text" ]]; then
          # Raw markdown output when --text flag is used
          echo "$content"
      elif [ -t 1 ] && command -v glow >/dev/null 2>&1; then
          # Use glow for enhanced formatting when outputting to terminal
          echo "$content" | glow --width=0 --pager -
      else
          # Fallback to raw markdown if not a TTY or glow not installed
          echo "$content"
      fi
  }

  # Main command logic
  if [[ "${args[name]}" == "list" ]] || [[ -z "${args[name]}" ]]; then
      list_examples
  else
      show_example "${args[name]}"
  fi
}

# :command.function
monk_status_command() {

  # src/commands/status.sh
  #!/bin/bash

  # status_command.sh - Show comprehensive CLI status and environment overview

  # Check dependencies
  check_dependencies

  init_cli_configs

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Get current context information
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  current_user=$(jq -r '.current_user // empty' "$ENV_CONFIG" 2>/dev/null)

  # Get server details if one is selected
  server_info=""
  server_status="No server selected"
  server_endpoint=""
  server_health=""

  if [[ -n "$current_server" ]]; then
      server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)
      if [[ -n "$server_info" ]]; then
          hostname=$(echo "$server_info" | jq -r '.hostname')
          port=$(echo "$server_info" | jq -r '.port')
          protocol=$(echo "$server_info" | jq -r '.protocol')
          server_endpoint="$protocol://$hostname:$port"

          # Check server health using /health endpoint (same as server health command)
          if curl -s --max-time 5 --fail "$server_endpoint/health" >/dev/null 2>&1; then
              server_status="Up"
              server_health=" Healthy"
          else
              server_status="Down"
              server_health=" Unreachable"
          fi
      else
          server_status="Server config missing"
      fi
  fi

  # Get authentication status
  auth_status="Not authenticated"
  user_details=""
  access_level=""

  if [[ -n "$current_server" && -n "$current_tenant" ]]; then
      # Check if we have a valid token for this server/tenant combination
      # (store_token uses server:tenant format)
      session_key="${current_server}:${current_tenant}"
      session_info=$(jq -r ".sessions.\"$session_key\"" "$AUTH_CONFIG" 2>/dev/null)

      if [[ -n "$session_info" && "$session_info" != "null" ]]; then
          token=$(echo "$session_info" | jq -r '.jwt_token // empty')

          if [[ -n "$token" ]]; then
              # Check if token is expired (same logic as auth_expired_command.sh)
              # Extract payload (second part) from JWT
              payload=$(echo "$token" | cut -d'.' -f2)

              # Add padding if needed for base64 decoding
              padding=$((4 - ${#payload} % 4))
              if [ $padding -ne 4 ]; then
                  payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
              fi

              # Decode base64 payload
              if decoded=$(echo "$payload" | base64 -d 2>/dev/null); then
                  if exp_timestamp=$(echo "$decoded" | jq -r '.exp // empty' 2>/dev/null); then
                      if [ -n "$exp_timestamp" ] && [ "$exp_timestamp" != "null" ] && [ "$exp_timestamp" != "empty" ]; then
                          current_timestamp=$(date +%s)

                          if [ "$exp_timestamp" -gt "$current_timestamp" ]; then
                              # Token is still valid
                              auth_status="Authenticated"
                              user_details="$current_user@$current_tenant"

                              # Try to get user role/access level from token
                              if command -v jq >/dev/null 2>&1; then
                                  role=$(echo "$decoded" | jq -r '.access // empty' 2>/dev/null)
                                  if [[ -n "$role" && "$role" != "null" ]]; then
                                      access_level="$role"
                                  fi
                              fi
                          else
                              # Token is expired
                              auth_status="Token expired"
                          fi
                      else
                          # No expiration found - assume expired for safety
                          auth_status="Token expired"
                      fi
                  else
                      # Failed to parse JSON - assume expired for safety
                      auth_status="Token expired"
                  fi
              else
                  # Failed to decode - assume expired for safety
                  auth_status="Token expired"
              fi
          fi
      fi
  fi

  # Get schemas if server is up and we're authenticated
  schemas=""
  schema_count=0

  if [[ "$server_status" == "Up" && "$auth_status" == "Authenticated" ]]; then
      # Try to get schemas from the API using GET /api/describe
      api_response=$(make_request_json "GET" "/api/describe" "")
      if [[ $? -eq 0 ]]; then
          # Extract the data array which contains schema names
          schemas=$(echo "$api_response" | jq -r '.data[]' 2>/dev/null | sort)
          if [[ -n "$schemas" ]]; then
              schema_count=$(echo "$schemas" | grep -c '^' | tr -d ' ')
          else
              schema_count=0
              schemas="No schemas found"
          fi
      else
          schemas="Unable to fetch schemas"
      fi
  fi

  # Build the status information
  if [[ "$output_format" == "text" ]]; then
      echo
      echo "Monk CLI Status"
      echo "==============="
      echo

      # Server Information
      echo "Server:"
      if [[ -n "$current_server" ]]; then
          echo "  Name: $current_server"
          echo "  Endpoint: ${server_endpoint:-Unknown}"
          echo "  Status: $server_status ${server_health:+($server_health)}"
      else
          echo "  No server selected (use 'monk server use <name>')"
      fi
      echo

      # Tenant Information
      echo "Tenant:"
      if [[ -n "$current_tenant" ]]; then
          echo "  Name: $current_tenant"
      else
          echo "  No tenant selected (use 'monk tenant use <name>')"
      fi
      echo

      # User Information
      echo "Authentication:"
      echo "  Status: $auth_status"
      if [[ -n "$user_details" ]]; then
          echo "  User: $user_details"
          if [[ -n "$access_level" ]]; then
              echo "  Access Level: $access_level"
          fi
      fi
      echo

      # Schemas Information
      if [[ "$server_status" == "Up" && "$auth_status" == "Authenticated" ]]; then
          echo "Available Schemas ($schema_count):"
          if [[ "$schemas" == "No schemas found" || "$schemas" == "Unable to fetch schemas" ]]; then
              echo "  $schemas"
          else
              echo "$schemas" | while read -r schema; do
                  if [[ -n "$schema" ]]; then
                      echo "   $schema"
                  fi
              done
          fi
      else
          echo "Schemas: Not available (server down or not authenticated)"
      fi

  else
      # JSON output
      status_json=$(jq -n \
          --arg server_name "$current_server" \
          --arg server_endpoint "$server_endpoint" \
          --arg server_status "$server_status" \
          --arg server_health "$server_health" \
          --arg tenant "$current_tenant" \
          --arg auth_status "$auth_status" \
          --arg user_details "$user_details" \
          --arg access_level "$access_level" \
          --arg schemas "$schemas" \
          --arg schema_count "$schema_count" \
          '{
              server: {
                  name: $server_name,
                  endpoint: $server_endpoint,
                  status: $server_status,
                  health: $server_health
              },
              tenant: $tenant,
              authentication: {
                  status: $auth_status,
                  user: $user_details,
                  access_level: $access_level
              },
              schemas: {
                  count: ($schema_count | tonumber),
                  available: ($schemas | split("\n") | map(select(. != "")))
              }
          }')

      handle_output "$status_json" "$output_format" "json" "status"
  fi
}

# :command.function
monk_curl_command() {

  # src/commands/curl.sh
  #!/bin/bash

  # curl_command.sh - Wrapper for making authenticated API requests

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  method="${args[method]}"
  path="${args[path]}"
  data_flag="${args[--data]}"
  raw_flag="${args[--raw]}"

  # Get base URL (this validates server config exists)
  base_url=$(get_base_url)
  if [ -z "$base_url" ]; then
      print_error "Could not determine server endpoint"
      print_info "Use 'monk server add <name> <endpoint>' to configure a server"
      exit 1
  fi

  # Get JWT token (this validates authentication)
  jwt_token=$(get_jwt_token)
  if [ -z "$jwt_token" ]; then
      print_error "No authentication token found"
      print_info "Use 'monk auth login <tenant> <username>' to authenticate"
      exit 1
  fi

  # Construct full URL
  # Remove trailing slash from base URL, remove leading slash from path if present
  base_url="${base_url%/}"
  path="${path#/}"
  full_url="${base_url}/${path}"

  print_info "Request: $method $full_url"

  # Determine request body source
  if [ -n "$data_flag" ]; then
      # Use --data flag
      request_body="$data_flag"
      print_info "Using data from --data flag"
  elif [ ! -t 0 ]; then
      # Read from stdin (pipe or redirect)
      request_body=$(cat)
      print_info "Using data from stdin"
  else
      # No body
      request_body=""
  fi

  # Make the request
  if [ -n "$request_body" ]; then
      # Request with body
      response=$(curl -s -X "$method" "$full_url" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer $jwt_token" \
          -d "$request_body")
  else
      # Request without body (GET, DELETE without body, etc.)
      response=$(curl -s -X "$method" "$full_url" \
          -H "Content-Type: application/json" \
          -H "Authorization: Bearer $jwt_token")
  fi

  # Check curl exit code
  curl_exit=$?
  if [ $curl_exit -ne 0 ]; then
      print_error "curl failed with exit code: $curl_exit"
      exit 1
  fi

  # Output response
  if [ "$raw_flag" = "1" ]; then
      # Raw output
      echo "$response"
  else
      # Pretty-print JSON
      if echo "$response" | jq . >/dev/null 2>&1; then
          echo "$response" | jq .

          # Show success/error status from response
          success=$(echo "$response" | jq -r '.success // empty' 2>/dev/null)
          if [ "$success" = "true" ]; then
              print_success "Request completed successfully"
          elif [ "$success" = "false" ]; then
              error_msg=$(echo "$response" | jq -r '.message // .error // "Unknown error"' 2>/dev/null)
              print_error "Request failed: $error_msg"
              exit 1
          fi
      else
          # Not JSON, output as-is
          echo "$response"
      fi
  fi

}

# :command.function
monk_server_add_command() {

  # src/commands/server/add.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"
  endpoint="${args[endpoint]}"
  description="${args[--description]}"

  init_cli_configs

  # Parse endpoint
  parsed=$(parse_endpoint "$endpoint")
  protocol=$(echo "$parsed" | cut -d'|' -f1)
  hostname=$(echo "$parsed" | cut -d'|' -f2)
  port=$(echo "$parsed" | cut -d'|' -f3)

  print_info "Adding server: $name"
  print_info "Endpoint: $protocol://$hostname:$port"
  if [ -n "$description" ]; then
      print_info "Description: $description"
  fi

  # Check if server already exists
  if command -v jq >/dev/null 2>&1; then
      if jq -e ".servers.\"$name\"" "$SERVER_CONFIG" >/dev/null 2>&1; then
          print_error "Server '$name' already exists"
          print_info "Use 'monk server delete $name' first, or choose a different name"
          exit 1
      fi
  fi

  # Test connectivity
  print_info "Testing connectivity to $protocol://$hostname:$port"
  base_url="$protocol://$hostname:$port"

  if ping_server_url "$base_url"; then
      print_success "Server is reachable"
      status="up"
  else
      print_info "Server appears to be down (this is OK, adding anyway)"
      status="down"
  fi

  # Add server to config
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  if command -v jq >/dev/null 2>&1; then
      # Use jq for JSON manipulation
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg hostname "$hostname" \
         --arg port "$port" \
         --arg protocol "$protocol" \
         --arg description "$description" \
         --arg timestamp "$timestamp" \
         --arg status "$status" \
         '.servers[$name] = {
             "hostname": $hostname,
             "port": ($port | tonumber),
             "protocol": $protocol,
             "description": $description,
             "added_at": $timestamp,
             "last_ping": $timestamp,
             "status": $status
         }' "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

      print_success "Server '$name' added successfully"

      # If this is the first server, make it current in env config
      server_count=$(jq '.servers | length' "$SERVER_CONFIG")
      if [ "$server_count" -eq 1 ]; then
          temp_file=$(mktemp)
          jq --arg name "$name" '.current_server = $name' "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
          print_info "Set as current server (first server added)"
      fi
  else
      print_error "jq is required for server management"
      print_info "Please install jq: brew install jq (macOS) or apt-get install jq (Linux)"
      exit 1
  fi
}

# :command.function
monk_server_list_command() {

  # src/commands/server/list.sh
  #!/bin/bash

  # server_list_command.sh - List all servers with universal output format support

  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  server_names=$(jq -r '.servers | keys[]' "$SERVER_CONFIG" 2>/dev/null)

  if [ -z "$server_names" ]; then
      # No servers - handle based on output format
      empty_result='{"servers": [], "current_server": null}'

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Registered Servers"
          echo
          print_info "No servers configured"
          print_info "Use 'monk server add <name> <hostname:port>' to add servers"
      else
          handle_output "$empty_result" "$output_format" "json" "server_list"
      fi
      exit 0
  fi

  # Build JSON data internally (always generate JSON first)
  servers_json=$(echo "$server_names" | while read -r name; do
      if [ -n "$name" ]; then
          server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG")

          hostname=$(echo "$server_info" | jq -r '.hostname')
          port=$(echo "$server_info" | jq -r '.port')
          protocol=$(echo "$server_info" | jq -r '.protocol')
          status=$(echo "$server_info" | jq -r '.status // "unknown"')
          last_ping=$(echo "$server_info" | jq -r '.last_ping // "never"')
          added_at=$(echo "$server_info" | jq -r '.added_at // "unknown"')
          description=$(echo "$server_info" | jq -r '.description // ""')

          endpoint="$protocol://$hostname:$port"

          # Check authentication count
          auth_count=$(jq --arg server "$name" '[.sessions | to_entries[] | select(.key | startswith($server + ":"))] | length' "$AUTH_CONFIG" 2>/dev/null || echo "0")
          is_current=$([ "$name" = "$current_server" ] && echo "true" || echo "false")

          # Create JSON object for this server
          jq -n \
              --arg name "$name" \
              --arg hostname "$hostname" \
              --argjson port "$port" \
              --arg protocol "$protocol" \
              --arg endpoint "$endpoint" \
              --arg status "$status" \
              --arg last_ping "$last_ping" \
              --arg added_at "$added_at" \
              --arg description "$description" \
              --argjson auth_sessions "$auth_count" \
              --argjson is_current "$is_current" \
              '{
                  name: $name,
                  hostname: $hostname,
                  port: $port,
                  protocol: $protocol,
                  endpoint: $endpoint,
                  status: $status,
                  last_ping: $last_ping,
                  added_at: $added_at,
                  description: $description,
                  auth_sessions: $auth_sessions,
                  is_current: $is_current
              }'
      fi
  done | jq -s --arg current_server "$current_server" \
      '{servers: ., current_server: ($current_server | if . == "" then null else . end)}')

  # Output in requested format
  if [[ "$output_format" == "text" ]]; then
      echo
      print_info "Registered Servers"
      echo

      # Build markdown table
      markdown_output=""
      markdown_output+="| NAME | ENDPOINT | STATUS | AUTH SESSIONS | ADDED | CURRENT |\n"
      markdown_output+="|------|----------|--------|---------------|-------|---------|"

      # Add data rows using process substitution to avoid subshell issues
      while IFS= read -r row; do
          if [ -n "$row" ]; then
              # Decode the row and extract fields
              decoded=$(echo "$row" | base64 -d)
              name=$(echo "$decoded" | jq -r '.name')
              endpoint=$(echo "$decoded" | jq -r '.endpoint')
              status=$(echo "$decoded" | jq -r '.status')
              auth_sessions=$(echo "$decoded" | jq -r '.auth_sessions')
              added=$(echo "$decoded" | jq -r '.added_at' | cut -d'T' -f1)
              current=$(echo "$decoded" | jq -r 'if .is_current then "*" else "" end')

              markdown_output+="\n| ${name} | ${endpoint} | ${status} | ${auth_sessions} | ${added} | ${current} |"
          fi
      done < <(echo "$servers_json" | jq -r '.servers[] | @base64')

      # Check if stdout is a TTY (interactive terminal) and glow is available
      if [ -t 1 ] && command -v glow >/dev/null 2>&1; then
          # Render with glow for interactive terminals (width=0 auto-detects terminal width)
          echo -e "$markdown_output" | glow --width=0 -
      else
          # Output raw markdown for pipes and non-interactive use
          echo -e "$markdown_output"
      fi

      echo
      if [ -n "$current_server" ]; then
          print_info "Current server: $current_server (marked with *)"
      else
          print_info "No current server selected"
          print_info "Use 'monk server use <name>' to select a server"
      fi
  else
      handle_output "$servers_json" "$output_format" "json" "server_list"
  fi
}

# :command.function
monk_server_current_command() {

  # src/commands/server/current.sh
  #!/bin/bash

  # server_current_command.sh - Show currently selected server with universal format support

  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      # No current server - generate appropriate response
      error_result='{"current_server": null, "error": "No current server selected"}'

      if [[ "$output_format" == "text" ]]; then
          print_info "No current server selected"
          print_info "Use 'monk server use <name>' to select a server"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 0
  fi

  server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      # Server not found in registry
      error_result=$(jq -n --arg server "$current_server" '{"current_server": $server, "error": "Server not found in registry"}')

      if [[ "$output_format" == "text" ]]; then
          print_error "Current server '$current_server' not found in registry"
          print_info "The server may have been deleted. Use 'monk server list' to see available servers"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  # Extract server details
  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  status=$(echo "$server_info" | jq -r '.status // "unknown"')
  description=$(echo "$server_info" | jq -r '.description // ""')
  base_url="$protocol://$hostname:$port"

  # Check authentication count
  auth_count=$(jq --arg server "$current_server" '[.sessions | to_entries[] | select(.key | startswith($server + ":"))] | length' "$AUTH_CONFIG" 2>/dev/null || echo "0")

  # Build JSON response
  server_json=$(jq -n \
      --arg name "$current_server" \
      --arg hostname "$hostname" \
      --arg port "$port" \
      --arg protocol "$protocol" \
      --arg endpoint "$base_url" \
      --arg status "$status" \
      --arg description "$description" \
      --argjson auth_count "$auth_count" \
      '{
          name: $name,
          hostname: $hostname,
          port: ($port | tonumber),
          protocol: $protocol,
          endpoint: $endpoint,
          base_url: $endpoint,
          status: $status,
          description: $description,
          auth_sessions: $auth_count
      }')

  # Handle text format with custom formatting for single server
  if [[ "$output_format" == "text" ]]; then
      echo
      print_info "Current Server"
      echo
      echo "Name: $current_server"
      echo "Endpoint: $base_url"
      echo "Status: $status"
      if [ -n "$description" ]; then
          echo "Description: $description"
      fi
      echo "Auth Sessions: $auth_count"
      echo
  else
      # Use universal handler for JSON output
      handle_output "$server_json" "$output_format" "json"
  fi
}

# :command.function
monk_server_use_command() {

  # src/commands/server/use.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # If no name provided, show current server (alias for 'current' command)
  if [ -z "$name" ]; then
      current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
          print_info "No current server selected"
          print_info "Use 'monk servers use <name>' to select a server"
          exit 0
      fi

      server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)
      if [ "$server_info" = "null" ]; then
          print_error "Current server '$current_server' not found in registry"
          print_info "The server may have been deleted. Use 'monk servers list' to see available servers"
          exit 1
      fi

      echo
      print_info "Current Server"
      echo

      hostname=$(echo "$server_info" | jq -r '.hostname')
      port=$(echo "$server_info" | jq -r '.port')
      protocol=$(echo "$server_info" | jq -r '.protocol')
      status=$(echo "$server_info" | jq -r '.status // "unknown"')
      description=$(echo "$server_info" | jq -r '.description // ""')

      echo "Name: $current_server"
      echo "Endpoint: $protocol://$hostname:$port"
      echo "Status: $status"
      if [ -n "$description" ]; then
          echo "Description: $description"
      fi

      # Show calculated base URL
      base_url="$protocol://$hostname:$port"
      echo "Base URL: $base_url"
      exit 0
  fi

  # Check if server exists
  server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  # Set as current server
  temp_file=$(mktemp)
  jq --arg name "$name" '.current_server = $name' "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

  # Get server details for confirmation
  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"

  print_success "Switched to server: $name"
  print_info "Endpoint: $base_url"
  print_info "All monk commands will now use this server"
  print_info "Base URL: $base_url"
}

# :command.function
monk_server_delete_command() {

  # src/commands/server/delete.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Check if server exists
  if ! jq -e ".servers.\"$name\"" "$SERVER_CONFIG" >/dev/null 2>&1; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  print_info "Deleting server: $name"

  # Remove server from config
  temp_file=$(mktemp)
  jq --arg name "$name" 'del(.servers[$name])' "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

  # If this was the current server, clear current
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ "$current_server" = "$name" ]; then
      jq '.current_server = null' "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
      print_info "Cleared current server (was deleted server)"
  fi

  print_success "Server '$name' deleted successfully"
}

# :command.function
monk_server_ping_command() {

  # src/commands/server/ping.sh
  #!/bin/bash

  # server_ping_command.sh - Health check server with universal format support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # If no name provided, use current server
  if [ -z "$name" ]; then
      name=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      if [ -z "$name" ] || [ "$name" = "null" ]; then
          error_result='{"error": "No server specified and no current server selected"}'

          if [[ "$output_format" == "text" ]]; then
              print_error "No server specified and no current server selected"
              print_info "Use 'monk server ping <name>' or 'monk server use <name>' first"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
      fi

      if [[ "$output_format" == "text" ]]; then
          print_info "Using current server: $name"
      fi
  fi

  # Get server info
  server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      error_result=$(jq -n --arg server_name "$name" '{"server_name": $server_name, "error": "Server not found"}')

      if [[ "$output_format" == "text" ]]; then
          print_error "Server '$name' not found"
          print_info "Use 'monk server list' to see available servers"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  if [[ "$output_format" == "text" ]]; then
      print_info "Pinging server: $name ($base_url)"
  fi

  # Test connectivity to root endpoint
  # Use curl's built-in timing to avoid bash arithmetic overflow
  if response_time_raw=$(curl -s --max-time 10 --fail -w '%{time_total}' -o /dev/null "$base_url/" 2>/dev/null); then
      # Convert seconds to milliseconds using awk
      response_time=$(echo "$response_time_raw" | awk '{printf "%.0f", $1 * 1000}')

      # Update status in config
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg timestamp "$timestamp" \
         '.servers[$name].last_ping = $timestamp | .servers[$name].status = "up"' \
         "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

      # Build success response JSON
      ping_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          --arg status "up" \
          --arg timestamp "$timestamp" \
          --argjson response_time_ms "$response_time" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              status: $status,
              timestamp: $timestamp,
              response_time_ms: $response_time_ms,
              success: true
          }')

      if [[ "$output_format" == "text" ]]; then
          print_success "Server is up and responding"
          print_info "Response time: ${response_time}ms"
      else
          handle_output "$ping_result" "$output_format" "json"
      fi
  else
      # Update status in config
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg timestamp "$timestamp" \
         '.servers[$name].last_ping = $timestamp | .servers[$name].status = "down"' \
         "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

      # Build failure response JSON
      ping_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          --arg status "down" \
          --arg timestamp "$timestamp" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              status: $status,
              timestamp: $timestamp,
              success: false,
              error: "Server is down or not responding"
          }')

      if [[ "$output_format" == "text" ]]; then
          print_error "Server is down or not responding"
      else
          handle_output "$ping_result" "$output_format" "json"
      fi
      exit 1
  fi
}

# :command.function
monk_server_ping_all_command() {

  # src/commands/server/ping-all.sh
  echo "# This file is located at 'src/commands/server/ping-all.sh'."
  echo "# It contains the implementation for the 'monk server ping-all' command."
  echo "# The code you write here will be wrapped by a function named 'monk_server_ping_all_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_server_info_command() {

  # src/commands/server/info.sh
  #!/bin/bash

  # server_info_command.sh - Show server information from API root endpoint

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # If no name provided, use current server
  if [ -z "$name" ]; then
      name=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      if [ -z "$name" ] || [ "$name" = "null" ]; then
          error_result='{"error": "No server specified and no current server selected"}'

          if [[ "$output_format" == "text" ]]; then
              print_error "No server specified and no current server selected"
              print_info "Use 'monk server info <name>' or 'monk server use <name>' first"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
      fi

      if [[ "$output_format" == "text" ]]; then
          print_info "Using current server: $name"
      fi
  fi

  # Get server info
  server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      error_result=$(jq -n --arg server_name "$name" '{"server_name": $server_name, "error": "Server not found"}')

      if [[ "$output_format" == "text" ]]; then
          print_error "Server '$name' not found"
          print_info "Use 'monk server list' to see available servers"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"

  # Fetch server info from API root endpoint
  if api_response=$(curl -s --max-time 10 --fail "$base_url/" 2>/dev/null); then
      # Parse the API response
      api_data=$(echo "$api_response" | jq -r '.data // empty' 2>/dev/null)

      if [ -z "$api_data" ] || [ "$api_data" = "null" ]; then
          error_result=$(jq -n --arg server_name "$name" --arg endpoint "$base_url" '{"server_name": $server_name, "endpoint": $endpoint, "error": "Invalid API response format"}')

          if [[ "$output_format" == "text" ]]; then
              print_error "Invalid API response format from server"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
      fi

      # Extract API information
      api_name=$(echo "$api_data" | jq -r '.name // "Unknown"')
      api_version=$(echo "$api_data" | jq -r '.version // "Unknown"')
      api_description=$(echo "$api_data" | jq -r '.description // ""')

      # Build complete info response
      info_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          --arg api_name "$api_name" \
          --arg api_version "$api_version" \
          --arg api_description "$api_description" \
          --argjson endpoints "$(echo "$api_data" | jq '.endpoints // {}')" \
          --argjson documentation "$(echo "$api_data" | jq '.documentation // null')" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              api: {
                  name: $api_name,
                  version: $api_version,
                  description: $api_description,
                  endpoints: $endpoints,
                  documentation: $documentation
              },
              status: "up",
              success: true
          }')

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Server Information: $name"
          echo
          print_info "Connection:"
          echo "  Endpoint: $base_url"
          echo "  Hostname: $hostname"
          echo "  Port: $port"
          echo "  Protocol: $protocol"
          echo
          print_info "API Details:"
          echo "  Name: $api_name"
          echo "  Version: $api_version"
          if [ -n "$api_description" ] && [ "$api_description" != "" ]; then
              echo "  Description: $api_description"
          fi
          echo
          print_info "Available Endpoints:"
          echo "$api_data" | jq -r '.endpoints | to_entries[] | "  \(.key): \(.value)"'

          # Display documentation if available
          documentation=$(echo "$api_data" | jq -r '.documentation // empty')
          if [ -n "$documentation" ] && [ "$documentation" != "null" ] && [ "$documentation" != "" ]; then
              echo
              print_info "Documentation:"

              # Show overview if available
              overview=$(echo "$api_data" | jq -r '.documentation.overview // empty')
              if [ -n "$overview" ] && [ "$overview" != "null" ] && [ "$overview" != "" ]; then
                  echo "  Overview: $overview"
              fi

              # Show API documentation if available
              apis=$(echo "$api_data" | jq -r '.documentation.apis // empty')
              if [ -n "$apis" ] && [ "$apis" != "null" ] && [ "$apis" != "" ]; then
                  echo "$api_data" | jq -r '.documentation.apis | to_entries[] | "  \(.key): \(.value)"'
              fi

              # Show errors documentation if available
              errors=$(echo "$api_data" | jq -r '.documentation.errors // empty')
              if [ -n "$errors" ] && [ "$errors" != "null" ] && [ "$errors" != "" ]; then
                  echo "  Errors: $errors"
              fi
          fi
      else
          handle_output "$info_result" "$output_format" "json"
      fi
  else
      error_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              status: "down",
              success: false,
              error: "Failed to connect to server or retrieve information"
          }')

      if [[ "$output_format" == "text" ]]; then
          print_error "Failed to connect to server '$name' at $base_url"
          print_info "Use 'monk server ping $name' to check connectivity"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi
}

# :command.function
monk_server_health_command() {

  # src/commands/server/health.sh
  #!/bin/bash

  # server_health_command.sh - Check server health status from API /health endpoint

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # If no name provided, use current server
  if [ -z "$name" ]; then
      name=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      if [ -z "$name" ] || [ "$name" = "null" ]; then
          error_result='{"error": "No server specified and no current server selected"}'

          if [[ "$output_format" == "text" ]]; then
              print_error "No server specified and no current server selected"
              print_info "Use 'monk server health <name>' or 'monk server use <name>' first"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
      fi

      if [[ "$output_format" == "text" ]]; then
          print_info "Using current server: $name"
      fi
  fi

  # Get server info (as JSON, not raw text)
  server_info=$(jq ".servers.\"$name\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ] || [ -z "$server_info" ]; then
      error_result=$(jq -n --arg server_name "$name" '{"server_name": $server_name, "error": "Server not found"}')

      if [[ "$output_format" == "text" ]]; then
          print_error "Server '$name' not found"
          print_info "Use 'monk server list' to see available servers"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  hostname=$(echo "$server_info" | jq -r '.hostname' 2>/dev/null)
  port=$(echo "$server_info" | jq -r '.port' 2>/dev/null)

  protocol=$(echo "$server_info" | jq -r '.protocol' 2>/dev/null)
  base_url="$protocol://$hostname:$port"

  # Fetch server health from API /health endpoint
  if api_response=$(curl -s --max-time 10 --fail "$base_url/health" 2>/dev/null); then
      # Parse the API response - check if there's a .data wrapper
      has_data_wrapper=$(echo "$api_response" | jq 'has("data")' 2>/dev/null)

      if [ "$has_data_wrapper" = "true" ]; then
          # Extract data from wrapper
          api_data=$(echo "$api_response" | jq '.data' 2>/dev/null)
      else
          # Use response directly if no wrapper
          api_data="$api_response"
      fi

      # Extract health information
      health_status=$(echo "$api_data" | jq -r '.status // "unknown"')
      server_version=$(echo "$api_data" | jq -r '.version // "unknown"')
      server_name_from_api=$(echo "$api_data" | jq -r '.name // "unknown"')
      uptime=$(echo "$api_data" | jq -r '.uptime // null')
      timestamp=$(echo "$api_data" | jq -r '.timestamp // null')

      # Extract database health if available
      database_status=$(echo "$api_data" | jq -r '.database // null')
      database_connected="null"

      # Extract any additional checks
      checks=$(echo "$api_data" | jq -r '.checks // {}')

      # Build health response
      health_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          --arg status "$health_status" \
          --arg version "$server_version" \
          --arg api_name "$server_name_from_api" \
          --arg uptime "$uptime" \
          --arg timestamp "$timestamp" \
          --arg database_status "$database_status" \
          --arg database_connected "$database_connected" \
          --argjson checks "$checks" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              health: {
                  status: $status,
                  version: $version,
                  name: $api_name,
                  uptime: $uptime,
                  timestamp: $timestamp,
                  database: (if $database_status != "null" then {
                      status: $database_status,
                      connected: ($database_connected | if . == "null" then null else . == "true" end)
                  } else null end),
                  checks: (if $checks != {} then $checks else null end)
              },
              success: true
          }')

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Server Health: $name"
          echo
          print_info "Connection:"
          echo "  Endpoint: $base_url/health"
          echo "  Hostname: $hostname"
          echo "  Port: $port"
          echo "  Protocol: $protocol"
          echo
          print_info "Health Status:"
          echo "  Status: $health_status"
          if [ "$server_version" != "unknown" ] && [ "$server_version" != "null" ]; then
              echo "  Version: $server_version"
          fi
          if [ "$server_name_from_api" != "unknown" ] && [ "$server_name_from_api" != "null" ]; then
              echo "  API Name: $server_name_from_api"
          fi
          if [ "$uptime" != "null" ]; then
              echo "  Uptime: $uptime"
          fi
          if [ "$timestamp" != "null" ]; then
              echo "  Timestamp: $timestamp"
          fi

          # Display database health if available
          if [ "$database_status" != "null" ]; then
              echo
              print_info "Database Health:"
              echo "  Status: $database_status"
              if [ "$database_connected" != "null" ]; then
                  echo "  Connected: $database_connected"
              fi
          fi

          # Display additional checks if available
          if [ "$(echo "$checks" | jq -r '. | length')" -gt 0 ]; then
              echo
              print_info "Additional Checks:"
              echo "$checks" | jq -r 'to_entries[] | "  \(.key): \(.value)"'
          fi

          # Overall status message
          echo
          if [ "$health_status" = "healthy" ] || [ "$health_status" = "ok" ] || [ "$health_status" = "up" ]; then
              print_success "Server is healthy and operational"
          elif [ "$health_status" = "degraded" ] || [ "$health_status" = "warning" ]; then
              print_warning "Server is operational but degraded"
          else
              print_warning "Server health status: $health_status"
          fi
      else
          handle_output "$health_result" "$output_format" "json"
      fi
  else
      error_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              health: {
                  status: "down"
              },
              success: false,
              error: "Failed to connect to server health endpoint"
          }')

      if [[ "$output_format" == "text" ]]; then
          print_error "Failed to check health of server '$name' at $base_url/health"
          print_info "The server may be down or the /health endpoint may be unavailable"
          print_info "Use 'monk server ping $name' to check basic connectivity"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi
}

# :command.function
monk_tenant_add_command() {

  # src/commands/tenant/add.sh
  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  name="${args[name]}"
  display_name="${args[display_name]}"
  description="${args[--description]}"

  # Get current server
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      print_error "No current server selected"
      print_info "Use 'monk server use <name>' to select a server first"
      exit 1
  fi

  # Validate tenant name
  if [[ ! "$name" =~ ^[a-zA-Z0-9][a-zA-Z0-9_-]*$ ]]; then
      print_error "Invalid tenant name: '$name'"
      print_info "Tenant names must start with alphanumeric character and contain only letters, numbers, hyphens, and underscores"
      exit 1
  fi

  # Check if tenant already exists for this server
  existing_tenant=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG" 2>/dev/null)
  if [ "$existing_tenant" != "null" ]; then
      existing_server=$(echo "$existing_tenant" | jq -r '.server')
      if [ "$existing_server" = "$current_server" ]; then
          print_error "Tenant '$name' already exists for server '$current_server'"
          exit 1
      elif [ "$existing_server" != "null" ]; then
          print_error "Tenant '$name' already exists for server '$existing_server'"
          print_info "Use a different tenant name or remove the existing tenant first"
          exit 1
      fi
  fi

  # Create timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  # Add tenant to config with server association
  temp_file=$(mktemp)
  jq --arg name "$name" \
     --arg display_name "$display_name" \
     --arg description "${description:-}" \
     --arg server "$current_server" \
     --arg timestamp "$timestamp" \
     '.tenants[$name] = {
         "display_name": $display_name,
         "description": $description,
         "server": $server,
         "added_at": $timestamp
     }' "$TENANT_CONFIG" > "$temp_file" && mv "$temp_file" "$TENANT_CONFIG"

  print_success "Added tenant '$name' ($display_name) for server '$current_server'"
  if [ -n "$description" ]; then
      print_info "Description: $description"
  fi
}

# :command.function
monk_tenant_list_command() {

  # src/commands/tenant/list.sh
  #!/bin/bash

  # tenant_list_command.sh - List all registered tenants with universal format support

  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  server_flag="${args[--server]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

  # Determine target server
  target_server="$server_flag"
  if [ -z "$target_server" ]; then
      target_server="$current_server"
  fi

  if [ -z "$target_server" ] || [ "$target_server" = "null" ]; then
      error_result='{"error": "No server specified and no current server selected"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "No server specified and no current server selected"
          print_info "Use 'monk server use <name>' to select a server or use --server flag"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  # Get tenant names for the target server
  tenant_names=$(jq -r --arg server "$target_server" '.tenants | to_entries[] | select(.value.server == $server) | .key' "$TENANT_CONFIG" 2>/dev/null)

  if [ -z "$tenant_names" ]; then
      empty_result=$(jq -n --arg server "$target_server" '{"tenants": [], "current_tenant": null, "server": $server}')

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Registered Tenants for Server: $target_server"
          echo
          print_info "No tenants configured for this server"
          print_info "Use 'monk tenant add <name> <display_name>' to add tenants"
      else
          handle_output "$empty_result" "$output_format" "json"
      fi
      exit 0
  fi

  # Build JSON data for all tenants
  tenants_json=$(echo "$tenant_names" | while read -r name; do
      if [ -n "$name" ]; then
          tenant_info=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG")

          display_name=$(echo "$tenant_info" | jq -r '.display_name')
          description=$(echo "$tenant_info" | jq -r '.description // ""')
          server=$(echo "$tenant_info" | jq -r '.server')
          added_at=$(echo "$tenant_info" | jq -r '.added_at // "unknown"')

          # Check authentication count for this tenant on this specific server
          session_key="${server}:${name}"
          auth_count=$(jq --arg session_key "$session_key" '.sessions | has($session_key) | if . then 1 else 0 end' "$AUTH_CONFIG" 2>/dev/null || echo "0")
          is_current=$([ "$name" = "$current_tenant" ] && [ "$server" = "$current_server" ] && echo "true" || echo "false")

          jq -n \
              --arg name "$name" \
              --arg display_name "$display_name" \
              --arg description "$description" \
              --arg server "$server" \
              --arg added_at "$added_at" \
              --argjson auth_count "$auth_count" \
              --argjson is_current "$is_current" \
              '{
                  name: $name,
                  display_name: $display_name,
                  description: $description,
                  server: $server,
                  added_at: $added_at,
                  authenticated: ($auth_count > 0),
                  is_current: $is_current
              }'
      fi
  done | jq -s --arg current_tenant "$current_tenant" \
      --arg server "$target_server" \
      '{tenants: ., current_tenant: ($current_tenant | if . == "" then null else . end), server: $server}')

  # Output in requested format
  if [[ "$output_format" == "text" ]]; then
      echo
      print_info "Registered Tenants for Server: $target_server"
      echo

      # Build markdown table
      markdown_output=""
      markdown_output+="| NAME | DISPLAY NAME | AUTH | ADDED | DESCRIPTION | CURRENT |\n"
      markdown_output+="|------|--------------|------|-------|-------------|---------|"

      # Add data rows using process substitution to avoid subshell issues
      while IFS= read -r row; do
          if [ -n "$row" ]; then
              # Decode the row and extract fields
              decoded=$(echo "$row" | base64 -d)
              name=$(echo "$decoded" | jq -r '.name')
              display_name=$(echo "$decoded" | jq -r '.display_name')
              auth=$(echo "$decoded" | jq -r 'if .authenticated then "yes" else "no" end')
              added=$(echo "$decoded" | jq -r '.added_at' | cut -d'T' -f1)
              description=$(echo "$decoded" | jq -r '.description')
              current=$(echo "$decoded" | jq -r 'if .is_current then "*" else "" end')

              markdown_output+="\n| ${name} | ${display_name} | ${auth} | ${added} | ${description} | ${current} |"
          fi
      done < <(echo "$tenants_json" | jq -r '.tenants[] | @base64')

      # Check if stdout is a TTY (interactive terminal) and glow is available
      if [ -t 1 ] && command -v glow >/dev/null 2>&1; then
          # Render with glow for interactive terminals (width=0 auto-detects terminal width)
          echo -e "$markdown_output" | glow --width=0 -
      else
          # Output raw markdown for pipes and non-interactive use
          echo -e "$markdown_output"
      fi

      echo
      if [ -n "$current_tenant" ] && [ "$target_server" = "$current_server" ]; then
          print_info "Current tenant: $current_tenant (marked with *)"
      else
          print_info "No current tenant selected for this server"
          print_info "Use 'monk tenant use <name>' to select a tenant"
      fi
  else
      handle_output "$tenants_json" "$output_format" "json"
  fi
}

# :command.function
monk_tenant_delete_command() {

  # src/commands/tenant/delete.sh
  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  name="${args[name]}"

  # Check if tenant exists
  tenant_info=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG" 2>/dev/null)
  if [ "$tenant_info" = "null" ]; then
      print_error "Tenant '$name' not found"
      exit 1
  fi

  display_name=$(echo "$tenant_info" | jq -r '.display_name')

  # Check if this is the current tenant
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ "$name" = "$current_tenant" ]; then
      print_warning "Cannot delete current tenant '$name'"
      print_info "Use 'monk tenant use <other_tenant>' to switch first"
      exit 1
  fi

  # Check for active sessions
  auth_count=$(jq --arg tenant "$name" '[.sessions | to_entries[] | select(.key | endswith(":" + $tenant))] | length' "$AUTH_CONFIG" 2>/dev/null || echo "0")
  if [ "$auth_count" -gt 0 ]; then
      print_warning "Tenant '$name' has $auth_count active sessions"
      print_info "Sessions will be removed along with tenant"
  fi

  # Confirmation
  print_warning "Are you sure you want to delete tenant '$name' ($display_name)? (y/N)"
  read -r confirmation
  if ! echo "$confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
      print_info "Operation cancelled"
      exit 0
  fi

  # Remove tenant from config
  temp_file=$(mktemp)
  jq --arg name "$name" \
     'del(.tenants[$name])' \
     "$TENANT_CONFIG" > "$temp_file" && mv "$temp_file" "$TENANT_CONFIG"

  # Remove any sessions for this tenant
  temp_file=$(mktemp)
  jq --arg tenant "$name" \
     'del(.sessions[] | select(.tenant == $tenant))' \
     "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"

  print_success "Deleted tenant '$name' ($display_name)"
  if [ "$auth_count" -gt 0 ]; then
      print_info "Removed $auth_count authentication sessions"
  fi
}

# :command.function
monk_tenant_use_command() {

  # src/commands/tenant/use.sh
  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  name="${args[name]}"

  # Get current server
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      print_error "No current server selected"
      print_info "Use 'monk server use <name>' to select a server first"
      exit 1
  fi

  # Check if tenant exists and belongs to current server
  tenant_info=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG" 2>/dev/null)
  if [ "$tenant_info" = "null" ]; then
      print_error "Tenant '$name' not found"
      print_info "Use 'monk tenant list' to see available tenants for current server"
      exit 1
  fi

  tenant_server=$(echo "$tenant_info" | jq -r '.server')
  if [ "$tenant_server" != "$current_server" ]; then
      print_error "Tenant '$name' belongs to server '$tenant_server', but current server is '$current_server'"
      print_info "Use 'monk server use $tenant_server' to switch servers first"
      exit 1
  fi

  # Update current tenant in env config
  temp_file=$(mktemp)
  jq --arg tenant "$name" \
     '.current_tenant = $tenant' \
     "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

  display_name=$(echo "$tenant_info" | jq -r '.display_name')
  print_success "Switched to tenant: $name ($display_name)"

  # Show authentication status for this tenant on current server
  session_key="${current_server}:${name}"
  if jq -e ".sessions.\"$session_key\"" "$AUTH_CONFIG" >/dev/null 2>&1; then
      user=$(jq -r ".sessions.\"$session_key\".user" "$AUTH_CONFIG" 2>/dev/null)
      print_info "Authenticated as: $user on server '$current_server'"
  else
      print_warning "Not authenticated for this tenant on server '$current_server'"
      print_info "Use 'monk auth login $name <username>' to authenticate"
  fi
}

# :command.function
monk_auth_list_command() {

  # src/commands/auth/list.sh
  #!/bin/bash

  # auth_list_command.sh - List all stored JWT tokens and sessions

  # Check dependencies
  check_dependencies

  # Initialize CLI configs
  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for token listing"
      exit 1
  fi

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Get current context information
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  current_user=$(jq -r '.current_user // empty' "$ENV_CONFIG" 2>/dev/null)

  # Get all sessions from auth config
  sessions=$(jq -r '.sessions | to_entries[] | .key' "$AUTH_CONFIG" 2>/dev/null)

  if [ -z "$sessions" ]; then
      empty_result='{"sessions": [], "current_session": null}'

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Stored JWT Tokens"
          echo
          print_info "No stored authentication sessions found"
          print_info "Use 'monk auth login TENANT USERNAME' or 'monk auth register TENANT USERNAME' to create sessions"
      else
          handle_output "$empty_result" "$output_format" "json"
      fi
      exit 0
  fi

  # Build JSON data for all sessions
  # Use array to avoid subshell issues with while loop
  sessions_array=()
  for session_key in $sessions; do
      if [ -n "$session_key" ]; then
          session_info=$(jq -r ".sessions.\"$session_key\"" "$AUTH_CONFIG")

          server=$(echo "$session_info" | jq -r '.server')
          tenant=$(echo "$session_info" | jq -r '.tenant')
          user=$(echo "$session_info" | jq -r '.user')
          created_at=$(echo "$session_info" | jq -r '.created_at // "unknown"')

          # Extract token expiration info
          token=$(echo "$session_info" | jq -r '.jwt_token')
          exp="unknown"
          exp_date="unknown"
          is_expired="unknown"

          # Try to decode JWT payload for expiration
          payload=$(echo "$token" | cut -d'.' -f2)
          case $((${#payload} % 4)) in
              2) payload="${payload}==" ;;
              3) payload="${payload}=" ;;
          esac

          if command -v base64 &> /dev/null; then
              decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
              if [ -n "$decoded" ]; then
                  exp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null || echo "unknown")

                  if [ "$exp" != "unknown" ] && [ "$exp" != "null" ]; then
                      # Check if expired
                      current_time=$(date +%s)
                      if [ "$exp" -gt "$current_time" ]; then
                          is_expired="false"
                      else
                          is_expired="true"
                      fi

                      # Format expiration date
                      if command -v date &> /dev/null; then
                          exp_date=$(date -r "$exp" 2>/dev/null || date -d "@$exp" 2>/dev/null || echo "unknown")
                      fi
                  fi
              fi
          fi

          # Check if this is the current session
          # Session key format is "server:tenant", so only check server and tenant match
          is_current="false"
          if [ "$server" = "$current_server" ] && [ "$tenant" = "$current_tenant" ]; then
              is_current="true"
          fi

          session_json=$(jq -n \
              --arg session_key "$session_key" \
              --arg server "$server" \
              --arg tenant "$tenant" \
              --arg user "$user" \
              --arg created_at "$created_at" \
              --arg exp "$exp" \
              --arg exp_date "$exp_date" \
              --arg is_expired "$is_expired" \
              --arg is_current "$is_current" \
              '{
                  session_key: $session_key,
                  server: $server,
                  tenant: $tenant,
                  user: $user,
                  created_at: $created_at,
                  expires_at: ($exp | if . == "unknown" then null else (. | tonumber) end),
                  expires_date: ($exp_date | if . == "unknown" then null else . end),
                  is_expired: ($is_expired == "true"),
                  is_current: ($is_current == "true")
              }')
          sessions_array+=("$session_json")
      fi
  done

  # Combine all sessions into final JSON
  sessions_json=$(jq -n --argjson sessions "$(printf '%s\n' "${sessions_array[@]}" | jq -s .)" '{sessions: $sessions}')

  # Find current session key
  current_session_key=""
  if [ -n "$current_server" ] && [ -n "$current_tenant" ] && [ -n "$current_user" ]; then
      current_session_key="${current_server}:${current_tenant}"
  fi

  # Add current session info to JSON
  final_json=$(echo "$sessions_json" | jq --arg current_session_key "$current_session_key" '. + {current_session: ($current_session_key | if . == "" then null else . end)}')

  # Output in requested format
  if [[ "$output_format" == "text" ]]; then
      echo
      print_info "Stored JWT Tokens"
      echo

      # Build markdown table
      markdown_output=""
      markdown_output+="| SESSION | SERVER | TENANT | USER | CREATED | EXPIRED | CURRENT |\n"
      markdown_output+="|---------|--------|--------|------|---------|---------|---------|"

      # Add data rows using process substitution to avoid subshell issues
      while IFS= read -r row; do
          if [ -n "$row" ]; then
              # Decode the row and extract fields
              decoded=$(echo "$row" | base64 -d)
              session_key=$(echo "$decoded" | jq -r '.session_key')
              server=$(echo "$decoded" | jq -r '.server')
              tenant=$(echo "$decoded" | jq -r '.tenant')
              user=$(echo "$decoded" | jq -r '.user')
              created=$(echo "$decoded" | jq -r '.created_at' | cut -d'T' -f1)
              expired=$(echo "$decoded" | jq -r 'if .is_expired then "yes" else "no" end')
              current=$(echo "$decoded" | jq -r 'if .is_current then "*" else "" end')

              markdown_output+="\n| ${session_key} | ${server} | ${tenant} | ${user} | ${created} | ${expired} | ${current} |"
          fi
      done < <(echo "$final_json" | jq -r '.sessions[] | @base64')

      # Check if stdout is a TTY (interactive terminal) and glow is available
      if [ -t 1 ] && command -v glow >/dev/null 2>&1; then
          # Render with glow for interactive terminals (width=0 auto-detects terminal width)
          echo -e "$markdown_output" | glow --width=0 -
      else
          # Output raw markdown for pipes and non-interactive use
          echo -e "$markdown_output"
      fi

      echo
      if [ -n "$current_session_key" ]; then
          print_info "Current session: $current_session_key (marked with *)"
      else
          print_info "No current session selected"
          print_info "Use 'monk tenant use <name>' to select a tenant"
      fi

      # Show expiration details for current session if available
      if [ -n "$current_session_key" ]; then
          current_session_info=$(echo "$final_json" | jq -r ".sessions[] | select(.session_key == \"$current_session_key\")")
          if [ -n "$current_session_info" ]; then
              exp_date=$(echo "$current_session_info" | jq -r '.expires_date // "unknown"')
              if [ "$exp_date" != "null" ] && [ "$exp_date" != "unknown" ]; then
                  print_info "Current session expires: $exp_date"
              fi
          fi
      fi
  else
      handle_output "$final_json" "$output_format" "json"
  fi
}

# :command.function
monk_auth_register_command() {

  # src/commands/auth/register.sh
  # Check dependencies
  check_dependencies

  # Initialize CLI configs
  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant registration"
      exit 1
  fi

  # Extract tenant and username from bashly args
  tenant="${args[tenant]}"
  username="${args[username]}"
  database="${args[--database]}"
  description="${args[--description]}"

  # Build registration request JSON
  register_data="{\"tenant\": \"$tenant\""

  # Add optional username (if provided)
  if [ -n "$username" ]; then
      register_data+=", \"username\": \"$username\""
      print_info "Registering new tenant: $tenant, username: $username"
  else
      print_info "Registering new tenant: $tenant (username will default to 'root' in personal mode)"
  fi

  # Add optional database (personal mode only)
  if [ -n "$database" ]; then
      register_data+=", \"database\": \"$database\""
      print_info "Custom database name: $database"
  fi

  # Add optional description
  if [ -n "$description" ]; then
      register_data+=", \"description\": \"$description\""
  fi

  register_data+="}"
  base_url=$(get_base_url)

  print_info "Sending registration request to: ${base_url}/auth/register"

  # Make registration request
  if response=$(make_request_json "POST" "/auth/register" "$register_data"); then
      # Extract token and registration details from response
      token=""
      database=""
      created_tenant=""
      created_username=""
      expires_in=""

      if [ "$JSON_PARSER" = "jq" ]; then
          token=$(echo "$response" | jq -r '.data.token' 2>/dev/null)
          database=$(echo "$response" | jq -r '.data.database' 2>/dev/null)
          created_tenant=$(echo "$response" | jq -r '.data.tenant' 2>/dev/null)
          created_username=$(echo "$response" | jq -r '.data.username' 2>/dev/null)
          expires_in=$(echo "$response" | jq -r '.data.expires_in' 2>/dev/null)
      elif [ "$JSON_PARSER" = "jshon" ]; then
          token=$(echo "$response" | jshon -e data -e token -u 2>/dev/null)
          database=$(echo "$response" | jshon -e data -e database -u 2>/dev/null)
          created_tenant=$(echo "$response" | jshon -e data -e tenant -u 2>/dev/null)
          created_username=$(echo "$response" | jshon -e data -e username -u 2>/dev/null)
          expires_in=$(echo "$response" | jshon -e data -e expires_in -u 2>/dev/null)
      else
          # Fallback: extract fields manually
          token=$(echo "$response" | grep -o '"token":"[^"]*"' | cut -d'"' -f4)
          database=$(echo "$response" | grep -o '"database":"[^"]*"' | cut -d'"' -f4)
          created_tenant=$(echo "$response" | grep -o '"tenant":"[^"]*"' | cut -d'"' -f4)
          created_username=$(echo "$response" | grep -o '"username":"[^"]*"' | cut -d'"' -f4)
          expires_in=$(echo "$response" | grep -o '"expires_in":[^,]*' | cut -d':' -f2)
      fi

      if [ -n "$token" ] && [ "$token" != "null" ]; then
          # Get current server for tenant registration
          current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
          if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
              print_error "No current server selected"
              print_info "Use 'monk server use <name>' to select a server first"
              exit 1
          fi

          # Add tenant to tenant registry (similar to tenant add command)
          timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          temp_file=$(mktemp)
          jq --arg name "$created_tenant" \
             --arg display_name "$created_tenant" \
             --arg description "Auto-created via auth register" \
             --arg server "$current_server" \
             --arg timestamp "$timestamp" \
             '.tenants[$name] = {
                 "display_name": $display_name,
                 "description": $description,
                 "server": $server,
                 "added_at": $timestamp
             }' "$TENANT_CONFIG" > "$temp_file" && mv "$temp_file" "$TENANT_CONFIG"

          # Store token with tenant and username
          store_token "$token" "$created_tenant" "$created_username"

          print_success "Registration successful"
          print_info_always "Tenant: $created_tenant"
          print_info_always "Database: $database"
          print_info_always "Username: $created_username"
          print_info_always "Token expires in: ${expires_in} seconds"
          print_info_always "JWT token stored for server+tenant context"
          print_info_always "Tenant added to local registry for server: $current_server"
      else
          print_error "Failed to extract registration data from response"
          print_info "Response: $response"
          exit 1
      fi
  else
      print_error "Registration failed"
      exit 1
  fi
}

# :command.function
monk_auth_login_command() {

  # src/commands/auth/login.sh
  # Check dependencies
  check_dependencies

  # Extract tenant and username from bashly args
  tenant="${args[tenant]}"
  username="${args[username]}"

  print_info "Authenticating with tenant: $tenant, username: $username"

  # Prepare authentication request
  auth_data="{\"tenant\": \"$tenant\", \"username\": \"$username\"}"
  base_url=$(get_base_url)

  print_info "Sending authentication request to: ${base_url}/auth/login"

  # Make authentication request
  if response=$(make_request_json "POST" "/auth/login" "$auth_data"); then
      # Extract token from response
      token=""
      if [ "$JSON_PARSER" = "jq" ]; then
          token=$(echo "$response" | jq -r '.data.token' 2>/dev/null)
      elif [ "$JSON_PARSER" = "jshon" ]; then
          token=$(echo "$response" | jshon -e data -e token -u 2>/dev/null)
      else
          # Fallback: extract token manually
          token=$(echo "$response" | grep -o '"token":"[^"]*"' | cut -d'"' -f4)
      fi

      if [ -n "$token" ] && [ "$token" != "null" ]; then
          # Store token with tenant and username
          store_token "$token" "$tenant" "$username"

          print_success "Authentication successful"
          print_info "JWT token stored for server+tenant context"
      else
          print_error "Failed to extract JWT token from response"
          print_info "Response: $response"
          exit 1
      fi
  else
      print_error "Authentication failed"
      exit 1
  fi
}

# :command.function
monk_auth_logout_command() {

  # src/commands/auth/logout.sh
  # Check dependencies
  check_dependencies

  # Check if we have any stored authentication
  if get_jwt_token >/dev/null 2>&1; then
      remove_stored_token
      print_success "Logged out successfully"
      print_info_always "Cleared authentication for current server+tenant context"
  else
      print_info_always "Already logged out (no active authentication found)"
  fi
}

# :command.function
monk_auth_status_command() {

  # src/commands/auth/status.sh
  #!/bin/bash

  # auth_status_command.sh - Show authentication status with universal format support

  # Check dependencies
  check_dependencies

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  token=$(get_jwt_token)

  # Get current context information
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  current_user=$(jq -r '.current_user // empty' "$ENV_CONFIG" 2>/dev/null)

  if [ -n "$token" ]; then
      # Extract token info
      tenant="unknown"
      database="unknown"
      exp="unknown"
      exp_date="unknown"

      # Try to extract domain from token (basic JWT decode)
      if [ "$JSON_PARSER" = "jq" ] || [ "$JSON_PARSER" = "jshon" ]; then
          # Decode JWT payload (basic base64 decode of middle part)
          payload=$(echo "$token" | cut -d'.' -f2)
          # Add padding if needed
          case $((${#payload} % 4)) in
              2) payload="${payload}==" ;;
              3) payload="${payload}=" ;;
          esac

          if command -v base64 &> /dev/null; then
              decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
              if [ -n "$decoded" ]; then
                  if [ "$JSON_PARSER" = "jq" ]; then
                      tenant=$(echo "$decoded" | jq -r '.tenant' 2>/dev/null || echo "unknown")
                      database=$(echo "$decoded" | jq -r '.database' 2>/dev/null || echo "unknown")
                      exp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null || echo "unknown")
                  elif [ "$JSON_PARSER" = "jshon" ]; then
                      tenant=$(echo "$decoded" | jshon -e tenant -u 2>/dev/null || echo "unknown")
                      database=$(echo "$decoded" | jshon -e database -u 2>/dev/null || echo "unknown")
                      exp=$(echo "$decoded" | jshon -e exp -u 2>/dev/null || echo "unknown")
                  fi

                  if [ "$exp" != "unknown" ] && [ "$exp" != "null" ]; then
                      if command -v date &> /dev/null; then
                          exp_date=$(date -r "$exp" 2>/dev/null || echo "unknown")
                      fi
                  fi
              fi
          fi
      fi

      # Build authenticated status JSON
      auth_status=$(jq -n \
          --arg authenticated "true" \
          --arg tenant "$tenant" \
          --arg database "$database" \
          --arg exp "$exp" \
          --arg exp_date "$exp_date" \
          --arg current_server "$current_server" \
          --arg current_tenant "$current_tenant" \
          --arg current_user "$current_user" \
          --arg has_token "true" \
          '{
              authenticated: ($authenticated == "true"),
              has_token: ($has_token == "true"),
              token_info: {
                  tenant: $tenant,
                  database: $database,
                  exp: ($exp | if . == "unknown" then null else (. | tonumber) end),
                  exp_date: ($exp_date | if . == "unknown" then null else . end)
              },
              current_context: {
                  server: ($current_server | if . == "" or . == "null" then null else . end),
                  tenant: ($current_tenant | if . == "" or . == "null" then null else . end),
                  user: ($current_user | if . == "" or . == "null" then null else . end)
              }
          }')

      if [[ "$output_format" == "text" ]]; then
          echo "Tenant: $tenant"
          echo "Database: $database"
          if [ "$exp_date" != "unknown" ]; then
              echo "Expires: $exp_date"
          fi
          echo "Server: $current_server"
          echo "Tenant: $current_tenant"
          echo "User: $current_user"
          print_success "Authenticated"
      else
          handle_output "$auth_status" "$output_format" "json"
      fi
  else
      # Build unauthenticated status JSON
      unauth_status=$(jq -n \
          --arg current_server "$current_server" \
          --arg current_tenant "$current_tenant" \
          --arg current_user "$current_user" \
          '{
              authenticated: false,
              has_token: false,
              token_info: null,
              current_context: {
                  server: ($current_server | if . == "" or . == "null" then null else . end),
                  tenant: ($current_tenant | if . == "" or . == "null" then null else . end),
                  user: ($current_user | if . == "" or . == "null" then null else . end)
              },
              message: "Not authenticated. Use monk auth login TENANT USERNAME to authenticate."
          }')

      if [[ "$output_format" == "text" ]]; then
          print_error "Not authenticated"
          print_info "Use 'monk auth login TENANT USERNAME' to authenticate"
      else
          handle_output "$unauth_status" "$output_format" "json"
      fi
  fi
}

# :command.function
monk_auth_token_command() {

  # src/commands/auth/token.sh
  token=$(get_jwt_token)

  if [ -n "$token" ]; then
      echo "$token"
  else
      print_error "No token found. Use 'monk auth login TENANT USERNAME' first"
      exit 1
  fi
}

# :command.function
monk_auth_info_command() {

  # src/commands/auth/info.sh
  #!/bin/bash

  # auth_info_command.sh - Decode and display JWT token contents with universal format support

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  token=$(get_jwt_token)

  if [ -z "$token" ]; then
      error_result='{"error": "No authentication token found", "message": "Use monk auth login TENANT USERNAME to authenticate"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "No authentication token found"
          print_info "Use 'monk auth login TENANT USERNAME' to authenticate"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  # Extract payload (second part) from JWT
  payload=$(echo "$token" | cut -d'.' -f2)

  # Add padding if needed for base64 decoding
  padding=$((4 - ${#payload} % 4))
  if [ $padding -ne 4 ]; then
      payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
  fi

  # Decode base64 payload
  if command -v base64 >/dev/null 2>&1; then
      decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
  else
      error_result='{"error": "base64 command not found"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "base64 command not found"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  if [ -n "$decoded" ]; then
      if command -v jq >/dev/null 2>&1; then
          # Add computed fields to the token payload for JSON output
          exp_timestamp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null)
          exp_date=""
          if [ "$exp_timestamp" != "null" ] && [ -n "$exp_timestamp" ]; then
              exp_date=$(date -r "$exp_timestamp" 2>/dev/null || echo 'unknown')
          fi

          # Build enhanced token info JSON
          token_info=$(echo "$decoded" | jq --arg exp_date "$exp_date" \
              '. + {
                  exp_date: (if $exp_date == "" or $exp_date == "unknown" then null else $exp_date end),
                  token_valid: true
              }')

          if [[ "$output_format" == "text" ]]; then
              # Human-readable output
              print_success "JWT Token Information:"
              echo

              # Extract key fields for display
              sub=$(echo "$decoded" | jq -r '.sub // "unknown"' 2>/dev/null)
              name=$(echo "$decoded" | jq -r '.name // "unknown"' 2>/dev/null)
              tenant=$(echo "$decoded" | jq -r '.tenant // "unknown"' 2>/dev/null)
              database=$(echo "$decoded" | jq -r '.database // "unknown"' 2>/dev/null)
              access=$(echo "$decoded" | jq -r '.access // "unknown"' 2>/dev/null)
              iat=$(echo "$decoded" | jq -r '.iat // "unknown"' 2>/dev/null)
              exp=$(echo "$decoded" | jq -r '.exp // "unknown"' 2>/dev/null)

              echo "Subject: $sub"
              echo "Name: $name"

              echo "Tenant: $tenant"
              echo "Database: $database"
              echo "Access Level: $access"

              if [ "$iat" != "unknown" ] && [ "$iat" != "null" ]; then
                  iat_date=$(date -r "$iat" 2>/dev/null || echo 'unknown')
                  echo "Issued At: $iat_date"
              fi

              if [ "$exp" != "unknown" ] && [ "$exp" != "null" ]; then
                  echo "Expires At: $exp_date"
              fi

              echo
          else
              handle_output "$token_info" "$output_format" "json"
          fi
      else
          # Fallback without jq
          fallback_result='{"error": "jq required for token parsing", "raw_payload": "'"$decoded"'"}'

          if [[ "$output_format" == "text" ]]; then
              print_error "jq required for token parsing"
              echo "Raw payload: $decoded"
          else
              handle_output "$fallback_result" "$output_format" "json"
          fi
      fi
  else
      decode_error='{"error": "Failed to decode JWT token", "message": "Token may be malformed"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "Failed to decode JWT token"
          print_info "Token may be malformed"
      else
          handle_output "$decode_error" "$output_format" "json"
      fi
      exit 1
  fi
}

# :command.function
monk_auth_ping_command() {

  # src/commands/auth/ping.sh
  #!/bin/bash

  # auth_ping_command.sh - Authenticated API health check with universal format support

  # Check dependencies
  check_dependencies

  # Get flags from bashly args
  verbose_flag="${args[--verbose]}"
  jwt_token_arg="${args[--jwt-token]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Set CLI_VERBOSE if flag is present

  if [ "$verbose_flag" = "1" ] || [ "$verbose_flag" = "true" ]; then
      CLI_VERBOSE=true
  fi

  # Make ping request
  base_url=$(get_base_url)

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Pinging server at: $base_url"
  fi

  # Prepare curl arguments
  curl_args=(-s -X GET -H "Content-Type: application/json")

  # Add JWT token (provided via -j flag or stored token)
  token_to_use="$jwt_token_arg"
  if [ -z "$token_to_use" ]; then
      token_to_use=$(get_jwt_token)
  fi

  if [ -n "$token_to_use" ]; then
      curl_args+=(-H "Authorization: Bearer $token_to_use")
      if [ "$CLI_VERBOSE" = "true" ]; then
          if [ -n "$jwt_token_arg" ]; then
              print_info "Using provided JWT token"
          else
              print_info "Using stored JWT token"
          fi
      fi
  fi

  # Make request
  full_url="${base_url}/api/auth/whoami"
  response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
  http_code=$(echo "$response" | tail -n1)
  response=$(echo "$response" | sed '$d')
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  # Handle response based on HTTP code
  case "$http_code" in
      200)
          # Success - build response JSON
          if [ "$JSON_PARSER" = "jq" ]; then
              ping_result=$(echo "$response" | jq --arg http_code "$http_code" \
                  --arg timestamp "$timestamp" \
                  --arg success "true" \
                  '. + {
                      http_code: ($http_code | tonumber),
                      timestamp: $timestamp,
                      success: ($success == "true"),
                      reachable: true
                  }')
          else
              # Fallback JSON
              ping_result='{"success": true, "reachable": true, "http_code": '"$http_code"', "timestamp": "'"$timestamp"'", "raw_response": "'"$response"'"}'
          fi

          if [[ "$output_format" == "text" ]]; then
              if [ "$CLI_VERBOSE" = "true" ]; then
                  print_success "Authentication successful (HTTP $http_code)"
                  echo "Response: $response"
              else
                  # Parse response for clean output
                  if [ "$JSON_PARSER" = "jq" ]; then
                      user_id=$(echo "$response" | jq -r '.data.id' 2>/dev/null || echo "unknown")
                      user_name=$(echo "$response" | jq -r '.data.name' 2>/dev/null || echo "unknown")
                      tenant=$(echo "$response" | jq -r '.data.tenant' 2>/dev/null || echo "null")
                      database=$(echo "$response" | jq -r '.data.database' 2>/dev/null || echo "null")
                      access=$(echo "$response" | jq -r '.data.access' 2>/dev/null || echo "null")

                      print_success "Authentication successful"
                      echo "User: $user_name"
                      echo "ID: $user_id"
                      if [ "$tenant" != "null" ] && [ "$tenant" != "" ]; then
                          echo "Tenant: $tenant"
                      fi
                      if [ "$database" != "null" ] && [ "$database" != "" ]; then
                          echo "Database: $database"
                      fi
                      if [ "$access" != "null" ] && [ "$access" != "" ]; then
                          echo "Access: $access"
                      fi
                  else
                      echo "Response: $response"
                  fi
              fi
          else
              handle_output "$ping_result" "$output_format" "json"
          fi
          ;;
      401)
          # Unauthorized
          error_result=$(jq -n \
              --arg http_code "$http_code" \
              --arg timestamp "$timestamp" \
              --arg error "Authentication failed" \
              '{
                  success: false,
                  reachable: true,
                  http_code: ($http_code | tonumber),
                  timestamp: $timestamp,
                  error: $error,
                  message: "JWT token is invalid or expired"
              }')

          if [[ "$output_format" == "text" ]]; then
              print_error "Authentication failed (HTTP $http_code)"
              print_info "JWT token is invalid or expired"
              print_info "Use 'monk auth login TENANT USERNAME' to re-authenticate"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
          ;;
      *)
          # Other HTTP error
          error_result=$(jq -n \
              --arg http_code "$http_code" \
              --arg timestamp "$timestamp" \
              --arg response "$response" \
              '{
                  success: false,
                  reachable: (if ($http_code | tonumber) == 0 then false else true end),
                  http_code: ($http_code | tonumber),
                  timestamp: $timestamp,
                  error: "HTTP error",
                  response: $response
              }')

          if [[ "$output_format" == "text" ]]; then
              print_error "HTTP error ($http_code)"
              if [ "$CLI_VERBOSE" = "true" ]; then
                  echo "Response: $response"
              fi
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
          ;;
  esac
}

# :command.function
monk_auth_import_command() {

  # src/commands/auth/import.sh
  #!/bin/bash

  # auth_import_command.sh - Import JWT token from external auth flow
  #
  # This command allows users to manually store JWT tokens obtained from external
  # authentication systems (OAuth, SSO, external tools, web UI, etc.) without
  # going through the standard login flow.
  #
  # Usage Examples:
  #   monk auth import tenant-a admin --token "eyJhbGciOiJIUzI1NiIs..."
  #   echo "eyJhbGciOiJIUzI1NiIs..." | monk auth import tenant-a admin
  #   cat jwt-token.txt | monk auth import my-tenant developer
  #
  # Input Methods:
  #   1. Via --token/-t flag: Direct token parameter
  #   2. Via stdin: Pipe token content (useful for scripting)
  #
  # Token Storage:
  #   - Stores in current server+tenant context in auth.json
  #   - Updates env.json with current tenant and user
  #   - Validates token format (basic JWT structure check)
  #   - Sets secure permissions on auth config file
  #
  # Use Cases:
  #   - OAuth/SSO authentication flows
  #   - External authentication tools
  #   - Token sharing between environments

  #   - Manual token management for automation
  #   - Development/testing with pre-generated tokens
  #
  # Requirements:
  #   - Current server must be selected (monk server use <name>)
  #   - Valid JWT token format (basic validation only)
  #   - Tenant and username must be specified

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  tenant="${args[tenant]}"
  username="${args[username]}"
  token_flag="${args[--token]}"

  print_info "Importing JWT token for tenant: $tenant, username: $username"

  # Get token from flag or stdin
  if [ -n "$token_flag" ]; then
      token="$token_flag"
      print_info "Using token from --token parameter"
  else
      # Read token from stdin
      token=$(cat)
      if [ -z "$token" ]; then
          print_error "No JWT token provided"
          print_info "Usage: monk auth import <tenant> <username> --token <jwt>"
          print_info "   or: echo '<jwt>' | monk auth import <tenant> <username>"
          exit 1
      fi
      print_info "Using token from stdin"
  fi

  # Basic JWT format validation (should have 3 parts separated by dots)
  if ! echo "$token" | grep -q '^[^.]*\.[^.]*\.[^.]*$'; then
      print_error "Invalid JWT token format"
      print_info "JWT tokens should have format: header.payload.signature"
      exit 1
  fi

  # Store the token using the same mechanism as login
  store_token "$token" "$tenant" "$username"

  print_success "JWT token imported successfully"
  print_info_always "Token stored for server+tenant context"

  # Show current context
  if [ "$CLI_VERBOSE" = "true" ]; then
      current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
      print_info "Context: server=$current_server, tenant=$tenant, user=$username"
  fi
}

# :command.function
monk_auth_expires_command() {

  # src/commands/auth/expires.sh
  #!/bin/bash

  # auth_expires_command.sh - Show JWT token expiration time
  #
  # This command extracts and displays the expiration time from the current JWT token
  # in a human-readable format.
  #
  # Usage Examples:
  #   monk auth expires                    # Show expiration time
  #   monk auth expires > expiry.txt       # Save expiration to file
  #
  # Output Format:
  #   Displays the expiration date/time in local timezone
  #   Example: "Wed Aug 28 15:30:45 PDT 2025"
  #
  # Requirements:
  #   - Active authentication (JWT token available)
  #   - base64 command for JWT decoding
  #   - date command for timestamp formatting

  # Check dependencies
  check_dependencies

  token=$(get_jwt_token)

  if [ -z "$token" ]; then
      print_error "No authentication token found"
      print_info_always "Use 'monk auth login' or 'monk auth import' to authenticate"
      exit 1
  fi

  # Extract payload (second part) from JWT
  payload=$(echo "$token" | cut -d'.' -f2)

  # Add padding if needed for base64 decoding
  padding=$((4 - ${#payload} % 4))
  if [ $padding -ne 4 ]; then
      payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
  fi

  # Decode base64 payload
  if command -v base64 >/dev/null 2>&1; then
      decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
  else
      print_error "base64 command not found"
      exit 1
  fi

  if [ -n "$decoded" ]; then
      if command -v jq >/dev/null 2>&1; then
          exp_timestamp=$(echo "$decoded" | jq -r '.exp // empty' 2>/dev/null)
          if [ -n "$exp_timestamp" ] && [ "$exp_timestamp" != "null" ] && [ "$exp_timestamp" != "empty" ]; then
              exp_date=$(date -r "$exp_timestamp" 2>/dev/null || echo 'Invalid timestamp')
              echo "$exp_date"
          else
              print_error "No expiration timestamp found in JWT token"
              exit 1
          fi
      else
          print_error "jq required for JWT token parsing"
          exit 1
      fi
  else
      print_error "Failed to decode JWT token"
      exit 1
  fi
}

# :command.function
monk_auth_expired_command() {

  # src/commands/auth/expired.sh
  #!/bin/bash

  # auth_expired_command.sh - Check if JWT token is expired (exit code based)
  #
  # This command checks if the current JWT token has expired and returns
  # appropriate exit codes for scripting and automation.
  #
  # Usage Examples:
  #   monk auth expired && echo "Token valid"
  #   if monk auth expired; then echo "Need to re-authenticate"; fi
  #   monk auth expired || monk auth login tenant user
  #
  # Exit Codes:
  #   0: Token is valid (not expired)
  #   1: Token is expired or no token found
  #   1: Error in token processing
  #
  # Output:
  #   Minimal output by design - primarily for scripting
  #   Use 'monk auth expires' for human-readable expiration time
  #
  # Requirements:
  #   - Active authentication (JWT token available)
  #   - base64 command for JWT decoding
  #   - date command for timestamp comparison

  # Check dependencies
  check_dependencies

  token=$(get_jwt_token)

  if [ -z "$token" ]; then
      # No token found
      exit 1
  fi

  # Extract payload (second part) from JWT
  payload=$(echo "$token" | cut -d'.' -f2)

  # Add padding if needed for base64 decoding
  padding=$((4 - ${#payload} % 4))
  if [ $padding -ne 4 ]; then
      payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
  fi

  # Decode base64 payload
  if command -v base64 >/dev/null 2>&1; then
      decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
  else
      # Can't decode - assume expired for safety
      exit 1
  fi

  if [ -n "$decoded" ]; then
      if command -v jq >/dev/null 2>&1; then
          exp_timestamp=$(echo "$decoded" | jq -r '.exp // empty' 2>/dev/null)
          if [ -n "$exp_timestamp" ] && [ "$exp_timestamp" != "null" ] && [ "$exp_timestamp" != "empty" ]; then
              current_timestamp=$(date +%s)

              if [ "$exp_timestamp" -gt "$current_timestamp" ]; then
                  # Token is still valid
                  exit 0
              else
                  # Token is expired
                  exit 1
              fi
          else
              # No expiration found - assume expired for safety
              exit 1
          fi
      else
          # No jq - can't parse - assume expired for safety
          exit 1
      fi
  else
      # Failed to decode - assume expired for safety
      exit 1
  fi
}

# :command.function
monk_auth_tenants_command() {

  # src/commands/auth/tenants.sh
  # Check dependencies
  check_dependencies

  # Initialize CLI configs
  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant listing"
      exit 1
  fi

  base_url=$(get_base_url)

  print_info "Fetching available tenants from: ${base_url}/auth/tenants"

  # Make request to list tenants
  if response=$(make_request_json "GET" "/auth/tenants" ""); then
      # Determine output format from global flags
      output_format=$(get_output_format "text")

      if [[ "$output_format" == "text" ]]; then
          # Human-readable table output
          tenants=$(echo "$response" | jq -r '.data')
          count=$(echo "$tenants" | jq 'length')

          echo
          print_info "Available tenants: $count"
          echo

          if [[ "$count" -gt 0 ]]; then
              printf "%-25s %-35s %-30s\n" "NAME" "DESCRIPTION" "USERS"
              echo "--------------------------------------------------------------------------------"

              echo "$tenants" | jq -r '.[] | [.name, (.description // "-"), (.users | join(", "))] | @tsv' | \
              while IFS=$'\t' read -r name description users; do
                  printf "%-25s %-35s %-30s\n" "$name" "$description" "$users"
              done
          else
              print_info "No tenants found"
          fi
          echo
      else
          # JSON output - pass through compact JSON
          handle_output "$response" "$output_format" "json"
      fi
  else
      print_error "Failed to retrieve tenants"
      print_info "This endpoint is only available when the server is running in personal mode"
      exit 1
  fi

}

# :command.function
monk_auth_sudo_command() {

  # src/commands/auth/sudo.sh
  # Check dependencies
  check_dependencies

  # Initialize CLI configs
  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for sudo token operations"
      exit 1
  fi

  # Get optional reason from flags
  reason="${args[--reason]}"

  # Prepare sudo request
  sudo_data="{}"
  if [ -n "$reason" ]; then
      sudo_data="{\"reason\": \"$reason\"}"
      print_info "Requesting sudo token with reason: $reason"
  else
      print_info "Requesting sudo token"
  fi

  # Make sudo request
  if response=$(make_request_json "POST" "/api/auth/sudo" "$sudo_data"); then
      # Extract sudo token and metadata from response
      sudo_token=""
      expires_in=""
      elevated_from=""
      warning=""

      if [ "$JSON_PARSER" = "jq" ]; then
          sudo_token=$(echo "$response" | jq -r '.data.root_token' 2>/dev/null)
          expires_in=$(echo "$response" | jq -r '.data.expires_in' 2>/dev/null)
          elevated_from=$(echo "$response" | jq -r '.data.elevated_from' 2>/dev/null)
          warning=$(echo "$response" | jq -r '.data.warning' 2>/dev/null)
      elif [ "$JSON_PARSER" = "jshon" ]; then
          sudo_token=$(echo "$response" | jshon -e data -e root_token -u 2>/dev/null)
          expires_in=$(echo "$response" | jshon -e data -e expires_in -u 2>/dev/null)
          elevated_from=$(echo "$response" | jshon -e data -e elevated_from -u 2>/dev/null)
          warning=$(echo "$response" | jshon -e data -e warning -u 2>/dev/null)
      else
          # Fallback: extract fields manually
          sudo_token=$(echo "$response" | grep -o '"root_token":"[^"]*"' | cut -d'"' -f4)
          expires_in=$(echo "$response" | grep -o '"expires_in":[^,}]*' | cut -d':' -f2)
          elevated_from=$(echo "$response" | grep -o '"elevated_from":"[^"]*"' | cut -d'"' -f4)
          warning=$(echo "$response" | grep -o '"warning":"[^"]*"' | cut -d'"' -f4)
      fi

      if [ -n "$sudo_token" ] && [ "$sudo_token" != "null" ]; then
          # Store sudo token
          store_sudo_token "$sudo_token" "$reason"

          print_success "Sudo token acquired successfully"
          print_info_always "Elevated from: $elevated_from"
          print_info_always "Expires in: ${expires_in} seconds (15 minutes)"

          if [ -n "$warning" ] && [ "$warning" != "null" ]; then
              echo
              print_warning "$warning"
          fi

          echo
          print_info_always "Use 'monk sudo users' commands to perform user management operations"
      else
          print_error "Failed to extract sudo token from response"
          print_info "Response: $response"
          exit 1
      fi
  else
      print_error "Failed to acquire sudo token"
      print_info "You must have root access level to use sudo commands"
      exit 1
  fi

}

# :command.function
monk_data_list_command() {

  # src/commands/data/list.sh
  #!/bin/bash

  # data_select_command.sh - Unified data selection with intelligent query routing
  #
  # This command handles all data selection scenarios:
  # 1. Direct ID selection for single records
  # 2. Default listing when no parameters provided

  # 3. Simple query parameters via --filter flag (limit, order, offset)
  # 4. Complex queries should use 'monk find' command directly
  #
  # Usage Examples:
  #   monk data select users 123                           # Get specific user by ID
  #   monk data select users                               # List all users (default)
  #   monk data select users --filter '{"limit": 10}'     # Limit results
  #   monk data select users --filter '{"order": "name asc"}'  # Sort by name
  #   monk data select users --filter '{"limit": 5, "offset": 10}'  # Pagination
  #
  # For complex queries with 'where' clauses, use:
  #   echo '{"where": {"status": "active"}}' | monk find users
  #
  # API Endpoints:
  #   GET /api/data/:schema/:id     (direct ID)
  #   GET /api/data/:schema         (default listing)
  #   GET /api/data/:schema?params  (with query string)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"
  filter_json="${args[--filter]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  if [ -n "$id" ]; then
      # Case 1: ID provided - direct record selection
      print_info "Selecting specific record: $id"
      response=$(make_request_json "GET" "/api/data/$schema/$id" "")
      handle_response_json "$response" "select"

  elif [ -n "$filter_json" ]; then
      # Case 2: Filter provided - parse and build query string
      print_info "Processing query filter for schema: $schema"

      # Check if this is a complex query that should use find command
      if has_complex_query "$filter_json"; then
          print_error "Complex queries with 'where' clauses should use 'monk find' command"
          print_info "Example: echo '$filter_json' | monk find $schema"
          exit 1
      fi

      # Build query string from filter parameters
      query_string=$(build_query_string "$filter_json")

      if [ -n "$query_string" ]; then
          print_info "Using query parameters: $query_string"
      else
          print_info "No valid query parameters found, using default selection"
      fi

      response=$(make_request_json "GET" "/api/data/$schema$query_string" "")
      handle_response_json "$response" "select"

  else
      # Case 3: No ID, no filter - default listing
      print_info "Selecting all records for schema: $schema"
      response=$(make_request_json "GET" "/api/data/$schema" "")
      handle_response_json "$response" "select"
  fi
}

# :command.function
monk_data_create_command() {

  # src/commands/data/create.sh
  #!/bin/bash

  # data_create_command.sh - Create records with flexible input handling
  #
  # This command creates new records in a schema with intelligent array/object handling:
  # - Single object input  wraps in array for API  unwraps response to match input
  # - Array input  sends directly to API  returns array response

  #
  # Usage Examples:
  #   echo '{"name": "John", "email": "john@example.com"}' | monk data create users
  #   cat user.json | monk data create users
  #   echo '[{"name": "Alice"}, {"name": "Bob"}]' | monk data create users  # Bulk create
  #
  # Input/Output Behavior:
  #   Object in  Object out (single record creation)
  #   Array in  Array out (bulk record creation)

  #
  # API Endpoint:
  #   POST /api/data/:schema (always expects array, handles wrapping/unwrapping)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  # Read and validate JSON input
  json_data=$(read_and_validate_json_input "creating" "$schema")

  # Process the create operation (uses handle_response_json which now outputs compact JSON)
  process_data_operation "create" "POST" "$schema" "" "$json_data"
}

# :command.function
monk_data_update_command() {

  # src/commands/data/update.sh
  #!/bin/bash

  # data_update_command.sh - Update records with flexible ID handling
  #
  # This command updates existing records with multiple input patterns:
  # - ID as parameter: uses object endpoint, removes ID from JSON payload
  # - ID extracted from JSON: uses object endpoint for single updates
  # - Array input: uses array endpoint for bulk updates
  #
  # Usage Examples:
  #   echo '{"name": "Updated Name"}' | monk data update users 123  # ID as param
  #   echo '{"id": 123, "name": "Updated Name"}' | monk data update users  # ID in JSON

  #   echo '[{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]' | monk data update users  # Bulk
  #
  # API Endpoints:
  #   PUT /api/data/:schema/:id  (single record - ID from parameter or extracted)
  #   PUT /api/data/:schema      (bulk update - array input)
  #
  # ID Handling:
  #   - Parameter ID takes precedence over JSON ID
  #   - JSON ID automatically extracted when parameter omitted
  #   - ID removed from payload for object endpoints (API requirement)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  # Read and validate JSON input
  json_data=$(read_and_validate_json_input "updating" "$schema")

  # Process the update operation
  process_data_operation "update" "PUT" "$schema" "$id" "$json_data"
}

# :command.function
monk_data_delete_command() {

  # src/commands/data/delete.sh
  #!/bin/bash

  # data_delete_command.sh - Delete records with confirmation and flexible input
  #
  # This command deletes records with multiple input patterns and safety confirmations:
  # - Direct ID deletion with optional confirmation prompts

  # - ID extracted from JSON objects for scripted deletions
  # - Bulk deletion from array input
  #
  # Usage Examples:
  #   monk data delete users 123                           # Direct ID deletion
  #   echo '{"id": 123}' | monk data delete users         # ID from JSON
  #   echo '[{"id": 1}, {"id": 2}]' | monk data delete users  # Bulk deletion
  #
  # Safety Features:
  #   - Confirmation prompts in CLI_VERBOSE mode for destructive operations
  #   - Clear error messages when ID missing from both parameter and JSON
  #
  # API Endpoints:
  #   DELETE /api/data/:schema/:id  (single record deletion)

  #   DELETE /api/data/:schema      (bulk deletion from array)
  #
  # Input Requirements:
  #   - Either ID parameter OR JSON with 'id' field(s) required
  #   - No payload sent for single deletions (just endpoint)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  if [ -n "$id" ]; then
      # ID provided - direct delete, no stdin needed
      process_data_operation "delete" "DELETE" "$schema" "$id" "" "true"
  elif [ -t 0 ]; then
      # No ID and no stdin (terminal input) - error
      print_error "No ID provided and no JSON data on stdin"
      print_info "Usage: monk data delete $schema <id> OR provide JSON with 'id' field(s) via stdin"
      exit 1
  else
      # No ID but have stdin - read and process JSON data
      json_data=$(read_and_validate_json_input "deleting" "$schema")
      process_data_operation "delete" "DELETE" "$schema" "" "$json_data" "true"
  fi
}

# :command.function
monk_data_export_command() {

  # src/commands/data/export.sh
  #!/bin/bash

  # data_export_command.sh - Export schema records to individual JSON files
  #
  # This command exports all records from a schema to separate JSON files in a directory.
  # Each record is saved as {record_id}.json with pretty-formatted JSON content.
  #
  # Usage Examples:
  #   monk data export users ./backup/users/              # Export to directory
  #   monk data export products /tmp/export-$(date +%Y%m%d)/  # Timestamped export
  #
  # Output Structure:
  #   - Creates target directory if it doesn't exist
  #   - One file per record: {directory}/{record_id}.json
  #   - Pretty-formatted JSON with 4-space indentation
  #   - Verbose progress reporting when CLI_VERBOSE=true
  #
  # Requirements:
  #   - Python3 required for JSON parsing and file operations
  #   - Records must have 'id' field for filename generation
  #   - Write permissions needed for target directory
  #
  # API Endpoint:
  #   GET /api/data/:schema (retrieves all records)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  directory="${args[dir]}"

  validate_schema "$schema"

  # Create directory if it doesn't exist
  if [ ! -d "$directory" ]; then
      print_info "Creating directory: $directory"
      mkdir -p "$directory"
  fi

  print_info "Exporting $schema records to: $directory"

  # Get all records using the API
  response=$(make_request_json "GET" "/api/data/$schema" "")

  # Check if jq is available (should be, since it's a hard dependency)
  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for export functionality"
      exit 1
  fi

  # Validate API response format
  if ! echo "$response" | jq -e '.success == true and .data' >/dev/null 2>&1; then
      print_error "Invalid API response format"
      echo "$response"
      exit 1
  fi

  # Export each record to individual JSON file
  count=0
  while IFS= read -r record; do
      # Extract ID from record
      id=$(echo "$record" | jq -r '.id // empty')

      if [ -z "$id" ] || [ "$id" = "null" ]; then
          print_warning "Skipping record without id field"
          continue
      fi

      # Write pretty-formatted JSON to file
      filename="$directory/$id.json"
      echo "$record" | jq '.' > "$filename"

      if [ $? -eq 0 ]; then
          print_info "Exported: $filename"
          count=$((count + 1))
      else
          print_error "Failed to write: $filename"
          exit 1
      fi

  done < <(echo "$response" | jq -c '.data[]')

  print_success "Successfully exported $count records to $directory"
}

# :command.function
monk_data_import_command() {

  # src/commands/data/import.sh
  #!/bin/bash

  # data_import_command.sh - Bulk import JSON files as records
  #
  # This command imports multiple JSON files from a directory as records in a schema.
  # All .json files are collected into an array and sent in a single bulk API request.
  #
  # Usage Examples:
  #   monk data import users ./backup/users/              # Import from directory
  #   monk data import products /tmp/migration/           # Migration import
  #
  # Input Structure:
  #   - Scans directory for all *.json files
  #   - Each file should contain a valid JSON object (one record)
  #   - Files processed in sorted order by filename
  #   - All records combined into array for bulk import
  #
  # Requirements:
  #   - Python3 required for JSON parsing and file operations
  #   - Directory must exist and contain .json files
  #   - Each JSON file must be valid and represent one record
  #
  # API Endpoint:

  #   PUT /api/data/:schema (bulk import with array payload)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  directory="${args[dir]}"

  validate_schema "$schema"

  if [ ! -d "$directory" ]; then
      print_error "Directory does not exist: $directory"
      exit 1
  fi

  print_info "Importing $schema records from: $directory"

  # Check if jq is available (should be, since it's a hard dependency)
  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for import functionality"
      exit 1
  fi

  # Check for JSON files in directory
  json_files=("$directory"/*.json)

  # Check if glob found any files (if not, array contains the literal pattern)
  if [ ! -f "${json_files[0]}" ]; then
      print_error "No .json files found in directory: $directory"
      exit 1
  fi

  print_info "Found ${#json_files[@]} JSON files to import"

  # Collect all JSON files into an array using jq
  records_json=$(jq -n --slurpfile records <(cat "${json_files[@]}") '$records')

  if [ -z "$records_json" ] || [ "$records_json" = "null" ]; then
      print_error "Failed to process JSON files"
      exit 1
  fi

  # Validate each file was valid JSON (jq would have failed above if not)
  count=0
  for file in "${json_files[@]}"; do
      filename=$(basename "$file")
      print_info "Loaded: $filename"
      count=$((count + 1))
  done

  print_info "Prepared $count records for import"

  # Make bulk import request
  response=$(make_request_json "PUT" "/api/data/$schema" "$records_json")

  print_success "Import completed successfully"
  handle_response_json "$response" "import"
}

# :command.function
monk_describe_list_command() {

  # src/commands/describe/list.sh
  #!/bin/bash

  # describe_list_command.sh - List all available schema names
  #
  # This command retrieves all schema names available in the current tenant.
  # Returns an array of schema names that can be queried with describe select.
  #
  # Usage Examples:
  #   monk describe list                    # List all schemas
  #   monk describe list --json             # JSON output format
  #   monk --text describe list             # Raw text output
  #
  # Output Format:
  #   - Text format: One schema name per line
  #   - JSON format: Returns full API response with schema array
  #
  # API Endpoint:
  #   GET /api/describe (returns array of schema names)

  # Check dependencies
  check_dependencies

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  print_info "Listing all available schemas"

  response=$(make_request_json "GET" "/api/describe" "")

  # Handle response based on output format
  if [[ "$output_format" == "json" ]]; then
      # JSON format - use standard handler (full response)
      handle_response_json "$response" "list"
  else
      # Text format - extract and display schema names one per line
      if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
          schema_count=$(echo "$response" | jq -r '.data | length')

          if [ "$schema_count" -eq 0 ]; then
              print_info "No schemas found"
          else
              echo "$response" | jq -r '.data[]'
          fi
      else
          handle_response_json "$response" "list"
      fi
  fi

}

# :command.function
monk_describe_select_command() {

  # src/commands/describe/select.sh
  #!/bin/bash

  # describe_select_command.sh - Retrieve specific schema definition

  #
  # This command retrieves the complete YAML schema definition for a named schema.
  # Returns the full schema specification including validation rules, properties, and metadata.
  #
  # Usage Examples:
  #   monk describe select schema users           # Get users schema definition
  #   monk describe select schema products > products.yaml  # Save schema to file
  #
  # Output Format:
  #   - Returns complete YAML schema definition
  #   - Includes JSON Schema validation rules, properties, required fields
  #   - Contains metadata like title, description, and custom attributes
  #
  # API Endpoint:
  #   GET /api/describe/:name (returns JSON schema content)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Validate schema name
  if [ -z "$schema" ]; then
      print_error "Schema name is required"
      exit 1
  fi

  print_info "Selecting schema: $schema"

  response=$(make_request_json "GET" "/api/describe/$schema" "")

  # Handle response based on output format
  if [[ "$output_format" == "json" ]]; then
      # JSON format - use standard handler (compact output)
      handle_response_json "$response" "select"
  else
      # Text format - pretty-print the schema for readability
      if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
          echo "$response" | jq -r '.data' | jq .
      else
          handle_response_json "$response" "select"
      fi
  fi

}

# :command.function
monk_describe_create_command() {

  # src/commands/describe/create.sh
  #!/bin/bash

  # describe_create_command.sh - Create new schema from JSON definition
  #
  # This command creates a new schema in the database from a JSON schema definition.
  # The schema definition includes JSON Schema validation rules and automatically
  # generates database DDL.
  #
  # Usage Examples:
  #   cat schema.json | monk describe create products    # Create from file
  #   echo '{...}' | monk describe create users          # Create from inline JSON
  #
  # Input Format:
  #   - JSON schema definition via stdin
  #   - Must include 'title' field for schema identification
  #   - Supports full JSON Schema specification (type, properties, required, etc.)
  #   - Optional metadata (description, examples)
  #
  # Schema Processing:
  #   - Validates JSON syntax and schema structure
  #   - Generates PostgreSQL table DDL automatically
  #   - Creates schema cache entry for performance
  #   - Prevents modification of system schemas
  #
  # API Endpoint:
  #   POST /api/describe/:name (Content-Type: application/json)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Validate schema name
  if [ -z "$schema" ]; then
      print_error "Schema name is required"
      exit 1
  fi

  # Read input data from stdin
  data=$(cat)

  if [ -z "$data" ]; then
      print_error "No schema data provided on stdin"
      print_info "Usage: cat schema.json | monk describe create <schema-name>"
      print_info "       echo '{...}' | monk describe create <schema-name>"
      exit 1
  fi

  # Validate JSON input
  if ! echo "$data" | jq . >/dev/null 2>&1; then
      print_error "Invalid JSON input"
      print_info "Describe create requires valid JSON schema definitions"
      exit 1
  fi

  # Validate that JSON has required title field
  if ! echo "$data" | jq -e '.title' >/dev/null 2>&1; then
      print_error "JSON schema must have a 'title' field"
      print_info "Example: {\"title\": \"$schema\", \"properties\": {...}}"
      exit 1
  fi

  print_info "Creating schema '$schema' with JSON data:"
  if [ "$CLI_VERBOSE" = "true" ]; then
      echo "$data" | jq . | sed 's/^/  /'
  fi

  response=$(make_request_json "POST" "/api/describe/$schema" "$data")
  handle_response_json "$response" "create"
}

# :command.function
monk_describe_update_command() {

  # src/commands/describe/update.sh
  #!/bin/bash

  # describe_update_command.sh - Update existing schema definition
  #
  # This command updates an existing schema with a new JSON definition.
  # Changes are applied to both the schema definition and underlying database table structure.
  # Supports additive changes safely, but breaking changes may affect existing data.
  #
  # Usage Examples:
  #   cat updated-schema.json | monk describe update users     # Update from file
  #   echo '{...}' | monk describe update products             # Update with inline JSON
  #
  # Input Format:
  #   - JSON schema definition via stdin
  #   - Must include 'title' field matching the schema name
  #   - Supports full JSON Schema specification
  #   - Additive changes (new fields) are generally safe
  #   - Breaking changes (removing required fields) may affect existing data
  #
  # Update Behavior:
  #   - Validates new schema definition
  #   - Compares with existing schema for compatibility
  #   - Updates PostgreSQL table structure (ADD/DROP columns as needed)
  #   - Preserves existing data where possible
  #   - System schemas cannot be modified
  #
  # API Endpoint:
  #   PUT /api/describe/:name (Content-Type: application/json)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Validate schema name
  if [ -z "$schema" ]; then
      print_error "Schema name is required"
      exit 1
  fi

  # Read input data from stdin
  data=$(cat)

  if [ -z "$data" ]; then
      print_error "No schema data provided on stdin"
      print_info "Usage: cat schema.json | monk describe update <schema-name>"
      print_info "       echo '{...}' | monk describe update <schema-name>"
      exit 1
  fi

  # Validate JSON input
  if ! echo "$data" | jq . >/dev/null 2>&1; then
      print_error "Invalid JSON input"
      print_info "Describe update requires valid JSON schema definitions"
      exit 1
  fi

  # Validate that JSON has required title field and it matches the schema name
  json_title=$(echo "$data" | jq -r '.title // empty')
  if [ -z "$json_title" ]; then
      print_error "JSON schema must have a 'title' field"
      print_info "Example: {\"title\": \"$schema\", \"properties\": {...}}"
      exit 1
  fi

  if [ "$json_title" != "$schema" ]; then
      print_warning "JSON title '$json_title' does not match schema name '$schema'"
      print_info "For safety, the JSON title should match the schema name being updated"
  fi

  print_info "Updating schema '$schema' with JSON data:"
  if [ "$CLI_VERBOSE" = "true" ]; then
      echo "$data" | jq . | sed 's/^/  /'
  fi

  response=$(make_request_json "PUT" "/api/describe/$schema" "$data")
  handle_response_json "$response" "update"
}

# :command.function
monk_describe_delete_command() {

  # src/commands/describe/delete.sh
  #!/bin/bash

  # describe_delete_command.sh - Delete schema definition
  #
  # This command soft deletes a schema definition. The schema is marked as deleted
  # but can be restored later. System schemas cannot be deleted.
  #
  # Usage Examples:
  #   monk describe delete test-schema          # Delete a test schema
  #   monk describe delete products             # Delete products schema
  #   monk describe delete old-users            # Delete old user schema
  #
  # Deletion Behavior:
  #   - Soft delete: Schema is marked as deleted but data remains
  #   - System schemas: Cannot be deleted (protected)
  #   - Restoration: Schemas can be restored via API (not yet in CLI)
  #
  # API Endpoint:
  #   DELETE /api/describe/:name (soft delete)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Validate schema name
  if [ -z "$schema" ]; then
      print_error "Schema name is required"
      exit 1
  fi

  print_info "Deleting schema: $schema"

  response=$(make_request_json "DELETE" "/api/describe/$schema" "")
  handle_response_json "$response" "delete"
}

# :command.function
monk_bulk_command() {

  # src/commands/bulk.sh
  #!/bin/bash

  # bulk_command.sh - Execute multiple operations in a single transaction
  #
  # This command executes an array of bulk operations in a single API transaction.
  # All operations are processed sequentially and results returned immediately.
  #
  # Usage Examples:
  #   cat operations.json | monk bulk
  #   echo '[{"operation": "create-one", "schema": "users", "data": {...}}]' | monk bulk
  #
  # Input Format - Array of operation objects:
  #   [
  #     {
  #       "operation": "create-one",    // Required: operation type (hyphenated)
  #       "schema": "users",            // Required: schema name
  #       "data": {"name": "Alice"},    // Required for mutations (object or array)
  #       "id": "user-123",             // Required for single-record operations
  #       "filter": {...},              // Required for *-any variants
  #       "aggregate": {...},           // Required for aggregate operations
  #       "groupBy": ["field"],         // Optional for aggregate
  #       "message": "Custom error"     // Optional: custom 404 message
  #     }
  #   ]
  #
  # Supported Operations:
  #   Read Helpers:
  #     - select, select-all, select-one, select-404, count, aggregate
  #   Create:
  #     - create, create-one, create-all
  #   Update:
  #     - update, update-one, update-all, update-any, update-404
  #   Delete (soft delete):
  #     - delete, delete-one, delete-all, delete-any, delete-404
  #   Access Control:
  #     - access, access-one, access-all, access-any, access-404
  #
  # API Request Format:
  #   POST /api/bulk
  #   {"operations": [...]}
  #
  # API Response Format:
  #   {"success": true, "data": [{operation result}, ...]}
  #
  # Transaction Behavior:
  #   All operations execute in a single transaction. On error, the entire
  #   transaction rolls back - no partial writes are persisted.

  # Check dependencies
  check_dependencies

  # Read and validate JSON input
  json_data=$(read_and_validate_json_input "executing bulk operations" "multiple schemas")

  # Validate that input is an array
  input_type=$(detect_input_type "$json_data")

  if [ "$input_type" != "array" ]; then
      print_error "Bulk operations require an array of operation objects"
      print_info "Usage: cat operations.json | monk bulk"
      print_info "Expected format: [{\"operation\": \"create-one\", \"schema\": \"users\", \"data\": {...}}]"
      exit 1
  fi

  # Validate basic structure of operations (best effort)
  if [ "$JSON_PARSER" = "jq" ]; then
      # Check that all items have required operation and schema fields
      missing_fields=$(echo "$json_data" | jq -r '.[] | select(.operation == null or .schema == null) | "missing operation or schema"' 2>/dev/null)

      if [ -n "$missing_fields" ]; then
          print_error "One or more operations missing required 'operation' and 'schema' fields"
          exit 1
      fi

      # Count operations for user feedback
      op_count=$(echo "$json_data" | jq 'length' 2>/dev/null || echo "unknown")
      print_info "Executing $op_count bulk operations"
  fi

  # Wrap operations array in {"operations": [...]} for new API format
  wrapped_payload=$(echo "$json_data" | jq '{operations: .}')

  # Execute bulk operations via API
  response=$(make_request_json "POST" "/api/bulk" "$wrapped_payload")

  # Handle response - extract data array from {"success": true, "data": [...]}
  if [ "$JSON_PARSER" = "jq" ]; then
      if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
          # Success - extract data array
          echo "$response" | jq '.data'
      else
          # Error - show full response
          handle_response_json "$response" "bulk"
      fi
  else
      # Fallback for non-jq parsers
      handle_response_json "$response" "bulk"
  fi
}

# :command.function
monk_fs_ls_command() {

  # src/commands/fs/ls.sh
  #!/bin/bash

  # fs_ls_command.sh - List directory contents with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  long_flag="${args[--long]}"
  all_flag="${args[--all]}"
  sort_flag="${args[--sort]:-name}"
  reverse_flag="${args[--reverse]}"
  tenant_flag="${args[--tenant]}"

  print_info "Listing directory: $path"

  # Build file options
  long_format="false"
  if [ "$long_flag" = "1" ]; then
      long_format="true"
  fi

  show_hidden="false"
  if [ "$all_flag" = "1" ]; then
      show_hidden="true"
      print_info "Showing hidden entries"
  fi

  # Determine sort order
  sort_order="asc"
  if [ "$reverse_flag" = "1" ]; then
      sort_order="desc"
      print_info "Using reverse sort order"
  fi

  # Show sort info if not default
  if [ "$sort_flag" != "name" ] || [ "$sort_order" != "asc" ]; then
      print_info "Sorting by: $sort_flag ($sort_order)"
  fi

  file_options=$(jq -n \
      --argjson long_format "$long_format" \
      --argjson show_hidden "$show_hidden" \
      --arg sort_by "$sort_flag" \
      --arg sort_order "$sort_order" \
      '{
          "show_hidden": $show_hidden,
          "recursive": false,
          "long_format": $long_format,
          "sort_by": $sort_by,
          "sort_order": $sort_order
      }')

  # Make request with tenant routing - UPDATED to use /api/file/list
  response=$(make_file_request_with_routing "list" "$path" "$file_options" "$tenant_flag")

  # Extract and format entries
  entries=$(process_file_response "$response" "entries")
  format_ls_output "$entries" "$long_format"
}

# :command.function
monk_fs_cat_command() {

  # src/commands/fs/cat.sh
  #!/bin/bash

  # fs_cat_command.sh - Display file content with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  tenant_flag="${args[--tenant]}"
  format_flag="${args[--format]:-json}"
  offset_flag="${args[--offset]}"
  max_bytes_flag="${args[--max-bytes]}"

  print_info "Reading file content: $path"

  # Build file options based on flags
  file_options_parts=()
  file_options_parts+=("\"format\": \"$format_flag\"")
  file_options_parts+=("\"binary_mode\": false")

  # Add offset if provided
  if [ -n "$offset_flag" ]; then
      file_options_parts+=("\"start_offset\": $offset_flag")
      print_info "Using byte offset: $offset_flag"
  fi

  # Add max_bytes if provided
  if [ -n "$max_bytes_flag" ]; then
      file_options_parts+=("\"max_bytes\": $max_bytes_flag")
      print_info "Limiting to max bytes: $max_bytes_flag"
  fi

  # Join options into JSON object
  file_options=$(printf '{%s}' "$(IFS=,; echo "${file_options_parts[*]}")")

  # Make request with tenant routing - UPDATED to use /api/file/retrieve
  response=$(make_file_request_with_routing "retrieve" "$path" "$file_options" "$tenant_flag")

  # Extract and display content
  content=$(process_file_response "$response" "content")

  if [ -n "$content" ] && [ "$content" != "null" ]; then
      # Handle output based on format
      if [ "$format_flag" = "raw" ]; then
          # Raw format - output as-is without quotes
          echo "$content" | jq -r .
      else
          # JSON format - pretty print JSON objects, show raw for simple values
          echo "$content" | jq . 2>/dev/null || echo "$content" | jq -r .
      fi
  else
      print_error "No content found for path: $path"
      exit 1
  fi
}

# :command.function
monk_fs_rm_command() {

  # src/commands/fs/rm.sh
  #!/bin/bash

  # fs_rm_command.sh - Remove files with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  force_flag="${args[--force]}"
  tenant_flag="${args[--tenant]}"

  print_info "Removing: $path"

  # Build file options based on flags - Using /api/file/delete endpoint
  permanent="false"
  if [ "$force_flag" = "true" ]; then
      permanent="true"
      print_warning "Permanent deletion requested (not recoverable)"
  else
      print_info "Using soft delete (recoverable)"
  fi

  file_options=$(jq -n \
      --argjson permanent "$permanent" \
      '{
          "recursive": false,
          "force": false,
          "permanent": $permanent,
          "atomic": true
      }')

  safety_checks=$(jq -n \
      '{
          "require_empty": false,
          "max_deletions": 100
      }')

  # Confirmation prompt for destructive operations
  if [ "$force_flag" = "true" ] && [ "$CLI_VERBOSE" = "true" ]; then
      print_warning "Are you sure you want to permanently delete: $path? (y/N)"
      read -r confirmation

      if ! echo "$confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
          print_info_always "Operation cancelled"
          exit 0
      fi
  fi

  # Build deletion payload with safety_checks
  deletion_payload=$(jq -n \
      --arg path "$path" \
      --argjson file_options "$file_options" \
      --argjson safety_checks "$safety_checks" \
      '{
          "path": $path,
          "file_options": $file_options,
          "safety_checks": $safety_checks
      }')

  # Make request - delete endpoint requires custom payload
  response=$(make_request_json "POST" "/api/file/delete" "$deletion_payload")

  # Process deletion result
  operation=$(process_file_response "$response" "operation")
  deleted_count=$(process_file_response "$response" "results.deleted_count")

  if [ "$permanent" = "true" ]; then
      print_success "Permanently deleted: $path"
  else
      print_success "Soft deleted: $path (recoverable)"
  fi

  # Show additional deletion details if available
  if [ -n "$deleted_count" ] && [ "$deleted_count" != "null" ] && [ "$deleted_count" != "0" ]; then
      print_info "Deleted count: $deleted_count"
  fi
}

# :command.function
monk_fs_stat_command() {

  # src/commands/fs/stat.sh
  #!/bin/bash

  # fs_stat_command.sh - Display detailed status with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly

  path="${args[path]}"
  tenant_flag="${args[--tenant]}"

  print_info "Getting status for: $path"

  # Make request with tenant routing - UPDATED to use /api/file/stat
  response=$(make_file_request_with_routing "stat" "$path" "" "$tenant_flag")

  # Extract basic information
  file_type=$(process_file_response "$response" "type")
  permissions=$(process_file_response "$response" "permissions")
  size=$(process_file_response "$response" "size")
  modified_time=$(process_file_response "$response" "modified_time")

  # Display basic stat information
  echo "  File: '$path'"
  echo "  Type: $file_type"
  echo "  Permissions: $permissions"

  echo "  Size: $size bytes"

  # Format and display timestamps
  if [ -n "$modified_time" ] && [ "$modified_time" != "null" ] && [ ${#modified_time} -eq 14 ]; then
      formatted_time=$(date -j -f "%Y%m%d%H%M%S" "$modified_time" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$modified_time")
      echo "Modified: $formatted_time"
  fi

  # Show record information if available
  record_info=$(process_file_response "$response" "record_info")
  if [ -n "$record_info" ] && [ "$record_info" != "null" ]; then
      echo
      echo "Record Information:"

      schema=$(echo "$record_info" | jq -r '.schema // "unknown"' 2>/dev/null)
      soft_deleted=$(echo "$record_info" | jq -r '.soft_deleted // false' 2>/dev/null)

      echo "  Schema: $schema"
      echo "  Soft Deleted: $soft_deleted"

      # Show access permissions if available
      access_perms=$(echo "$record_info" | jq -r '.access_permissions[]?' 2>/dev/null | tr '\n' ',' | sed 's/,$//')
      if [ -n "$access_perms" ]; then
          echo "  Access: $access_perms"
      fi
  fi

  # Show children count for directories
  children_count=$(process_file_response "$response" "children_count")
  if [ -n "$children_count" ] && [ "$children_count" != "null" ]; then
      echo
      echo "Directory contains: $children_count entries"
  fi
}

# :command.function
monk_fs_cp_command() {

  # src/commands/fs/cp.sh
  #!/usr/bin/env bash

  # fs_cp_command.sh
  # Copy records between schemas or duplicate records within the same schema

  # Check dependencies
  check_dependencies

  # Source and destination parsing
  source_path="${args[source]}"
  dest_path="${args[destination]}"
  force_flag="${args[--force]}"
  tenant_flag="${args[--tenant]}"

  print_info "Copying from: $source_path"
  print_info "Copying to: $dest_path"

  # Validate paths
  if [[ "$source_path" == "$dest_path" ]]; then
      print_error "Source and destination cannot be the same"
      exit 1
  fi

  # For now, implement single record copy only
  if [[ "$source_path" != *.json ]]; then
      print_error "Currently only single record copy is supported (must end in .json)"
      print_info "Use: monk fs cp /data/users/123.json /data/users/456.json"
      exit 1
  fi

  if [[ "$dest_path" != *.json ]]; then
      print_error "Destination must be a record file (must end in .json)"
      print_info "Use: monk fs cp /data/users/123.json /data/users/456.json"
      exit 1
  fi

  # First, get the source record
  print_info "Reading source record..."
  source_response=$(make_file_request_with_routing "retrieve" "$source_path" "" "$tenant_flag")
  source_content=$(process_file_response "$source_response" "content")

  if [ -z "$source_content" ] || [ "$source_content" = "null" ]; then
      print_error "Source record not found: $source_path"
      exit 1
  fi

  print_info "Source record loaded successfully"

  # For copy operations, we need to handle ID generation and remove system fields
  # Extract the record data without system fields
  clean_content=$(echo "$source_content" | jq 'del(.id, .created_at, .updated_at, .trashed_at, .deleted_at, .access_read, .access_edit, .access_full, .access_deny)')

  # Copy the record to destination
  print_info "Creating copy at destination..."
  copy_payload=$(jq -n \
      --arg path "$dest_path" \
      --argjson content "$clean_content" \
      '{"path": $path, "content": $content, "file_options": {"overwrite": true, "atomic": true}}')

  copy_response=$(make_request_json "POST" "/api/file/store" "$copy_payload")

  if echo "$copy_response" | jq -e '.success' > /dev/null; then
      print_success "Record copied successfully!"
      print_info "From: $source_path"
      print_info "To: $dest_path"

      # Show the new record
      dest_response=$(make_file_request_with_routing "retrieve" "$dest_path" "" "$tenant_flag")
      dest_content=$(process_file_response "$dest_response" "content")

      if [ -n "$dest_content" ] && [ "$dest_content" != "null" ]; then
          print_info "Copied record:"
          echo "$dest_content" | jq '.'
      fi
  else
      print_error "Copy failed: $(echo "$copy_response" | jq -r '.error // "Unknown error"')"
      exit 1
  fi
}

# :command.function
monk_fs_size_command() {

  # src/commands/fs/size.sh
  #!/bin/bash

  # fs_size_command.sh - Calculate storage footprint with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  tenant_flag="${args[--tenant]}"

  print_info "Getting size for: $path"

  # Make request with tenant routing - Using /api/file/size endpoint
  response=$(make_file_request_with_routing "size" "$path" "" "$tenant_flag")

  # Extract size information
  size=$(process_file_response "$response" "size")
  file_type=$(process_file_response "$response" "file_metadata.type")

  if [ -n "$size" ] && [ "$size" != "null" ]; then
      # Format size in human-readable format
      if command -v numfmt >/dev/null 2>&1; then
          human_size=$(numfmt --to=iec-i --suffix=B "$size" 2>/dev/null || echo "$size bytes")
      else
          # Fallback for macOS without numfmt
          if [ "$size" -ge 1073741824 ]; then
              human_size=$(awk "BEGIN {printf \"%.2f GiB\", $size/1073741824}")
          elif [ "$size" -ge 1048576 ]; then
              human_size=$(awk "BEGIN {printf \"%.2f MiB\", $size/1048576}")
          elif [ "$size" -ge 1024 ]; then
              human_size=$(awk "BEGIN {printf \"%.2f KiB\", $size/1024}")
          else
              human_size="$size bytes"
          fi
      fi

      echo "$human_size ($size bytes)"

      # Show additional metadata if available
      if [ -n "$file_type" ] && [ "$file_type" != "null" ]; then
          print_info "Type: $file_type"
      fi
  else
      print_error "Could not retrieve size for: $path"
      exit 1
  fi

}

# :command.function
monk_fs_mtime_command() {

  # src/commands/fs/mtime.sh
  #!/bin/bash

  # fs_mtime_command.sh - Retrieve modified timestamps with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  tenant_flag="${args[--tenant]}"

  print_info "Getting modified time for: $path"

  # Make request with tenant routing - Using /api/file/modify-time endpoint
  response=$(make_file_request_with_routing "modify-time" "$path" "" "$tenant_flag")

  # Extract timestamp information (use raw output to avoid quotes)
  modified_time=$(echo "$response" | jq -r '.data.modified_time // empty')
  iso_timestamp=$(echo "$response" | jq -r '.data.timestamp_info.iso_timestamp // empty')
  source_field=$(echo "$response" | jq -r '.data.timestamp_info.source // empty')

  if [ -n "$modified_time" ] && [ "$modified_time" != "null" ]; then
      # Display the FTP-style timestamp
      echo "Modified Time: $modified_time"

      # Display ISO format if available
      if [ -n "$iso_timestamp" ] && [ "$iso_timestamp" != "null" ]; then
          echo "ISO Format: $iso_timestamp"
      fi

      # Show source field
      if [ -n "$source_field" ] && [ "$source_field" != "null" ]; then
          print_info "Source: $source_field"
      fi

      # Try to format in human-readable local time (macOS compatible)
      if [ ${#modified_time} -eq 14 ]; then
          formatted_time=$(date -j -f "%Y%m%d%H%M%S" "$modified_time" "+%Y-%m-%d %H:%M:%S %Z" 2>/dev/null || echo "")
          if [ -n "$formatted_time" ]; then
              echo "Local Time: $formatted_time"
          fi
      fi
  else
      print_error "Could not retrieve modified time for: $path"
      exit 1
  fi

}

# :command.function
monk_fs_find_command() {

  # src/commands/fs/find.sh
  #!/bin/bash

  # fs_find_command.sh - Find files with content filtering (Unix find-like)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  where_flags=("${args[--where]}")
  type_flag="${args[--type]}"
  name_flag="${args[--name]}"
  maxdepth_flag="${args[--maxdepth]}"
  print0_flag="${args[--print0]}"
  tenant_flag="${args[--tenant]}"

  print_info "Searching: $path"

  # Build WHERE clause from multiple -w/--where flags
  where_clause="{}"

  if [ ${#where_flags[@]} -gt 0 ]; then
      for condition in "${where_flags[@]}"; do
          if [ -z "$condition" ] || [ "$condition" = "null" ]; then
              continue
          fi

          # Unescape if needed (bashly may escape JSON)
          unescaped_condition="$condition"
          if [[ "$condition" == "\\"* ]]; then
              unescaped_condition=$(echo "$condition" | sed 's/\\//g')
          fi

          if [[ "$unescaped_condition" == "{"* ]]; then
              # JSON format - merge it
              where_clause=$(echo "$where_clause" | jq --argjson new "$unescaped_condition" '. * $new')
          elif [[ "$condition" == *"="* ]]; then
              # key=value format
              key="${condition%%=*}"
              value="${condition#*=}"
              where_clause=$(echo "$where_clause" | jq --arg k "$key" --arg v "$value" '.[$k] = $v')
          else
              print_error "Invalid -where format: $condition"
              print_info "Use: -where key=value  OR  -where '{\"key\":\"value\"}'"
              exit 1
          fi
      done

      # Check if we actually have filters
      if [ "$where_clause" != "{}" ]; then
          print_info "Content filter: $(echo "$where_clause" | jq -c .)"
      fi
  fi

  # Build file options
  file_options_parts=()

  # Add recursive search (always on for find)
  file_options_parts+=("\"recursive\": true")

  # Add max_depth if specified
  if [ -n "$maxdepth_flag" ]; then
      file_options_parts+=("\"max_depth\": $maxdepth_flag")
      print_info "Max depth: $maxdepth_flag"
  fi

  # Add WHERE clause if we have one
  if [ "$where_clause" != "{}" ]; then
      where_json=$(echo "$where_clause" | jq -c .)
      file_options_parts+=("\"where\": $where_json")
  fi

  # Build complete file_options JSON
  file_options=$(printf '{%s}' "$(IFS=,; echo "${file_options_parts[*]}")")

  # Make request with tenant routing
  response=$(make_file_request_with_routing "list" "$path" "$file_options" "$tenant_flag")

  # Extract entries
  entries=$(process_file_response "$response" "entries")

  if [ -z "$entries" ] || [ "$entries" = "null" ]; then
      print_info "No matches found"
      exit 0
  fi

  # Client-side filtering (for options not supported by API yet)

  # Filter by type if specified
  if [ -n "$type_flag" ]; then
      print_info "Filtering by type: $type_flag"
      entries=$(echo "$entries" | jq --arg type "$type_flag" '[.[] | select(.file_type == $type)]')
  fi

  # Filter by name pattern if specified
  if [ -n "$name_flag" ]; then
      print_info "Filtering by name: $name_flag"
      # Convert wildcard pattern to regex
      regex_pattern=$(echo "$name_flag" | sed 's/\*/.*/' | sed 's/?/./')
      entries=$(echo "$entries" | jq --arg pattern "^${regex_pattern}$" '[.[] | select(.name | test($pattern))]')
  fi

  # Output results
  if [ "$print0_flag" = "1" ]; then
      # Null-separated output for xargs -0
      echo "$entries" | jq -r '.[].path' | tr '\n' '\0'
  else
      # Normal output (one path per line)
      echo "$entries" | jq -r '.[].path'
  fi

  # Print count if verbose
  count=$(echo "$entries" | jq 'length')
  if [ "$count" = "0" ]; then
      print_info "No matches found"
  else
      print_success "Found $count matches"
  fi

}

# :command.function
monk_find_command() {

  # src/commands/find.sh
  #!/bin/bash

  # find_command.sh - Advanced search with enterprise Filter DSL
  #
  # This command performs complex searches using the enterprise Filter DSL with support
  # for advanced filtering, nested queries, and result limiting options.
  #
  # Usage Examples:
  #   echo '{"where": {"name": {"$like": "john*"}}}' | monk find users
  #   echo '{"where": {"age": {"$gt": 25}}, "limit": 10}' | monk find users
  #   echo '{"where": {"$and": [{"status": "active"}, {"role": "admin"}]}}' | monk find users --head
  #   cat complex-query.json | monk find documents --tail
  #
  # Filter DSL Support:
  #   - Comparison operators: $eq, $ne, $gt, $gte, $lt, $lte
  #   - Array operators: $in, $nin, $any, $nany

  #   - Pattern matching: $like, $ilike (case-insensitive)
  #   - Logical operators: $and, $or, $not
  #   - Range operators: $between
  #   - Nested object queries and complex expressions
  #
  # Output Options:
  #   --head/-H: Return only the first record from results
  #   --tail/-T: Return only the last record from results
  #   (default): Return all matching records
  #
  # API Endpoint:
  #   POST /api/find/:schema (with Filter DSL JSON payload)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  head_flag="${args[--head]}"
  tail_flag="${args[--tail]}"

  validate_schema "$schema"

  # Read and validate JSON input (Filter DSL)
  json_data=$(read_and_validate_json_input "searching" "$schema")

  # Make the find request
  response=$(make_request_json "POST" "/api/find/$schema" "$json_data")

  # Process response with head/tail support
  if [ "$head_flag" = "true" ]; then
      # Extract first record from array
      print_info "Returning first record only"
      if [ "$JSON_PARSER" = "jq" ]; then
          if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
              first_record=$(echo "$response" | jq '.data[0] // null')
              echo "$response" | jq --argjson first "$first_record" '{"success": .success, "data": $first}'
          else
              echo "$response"
          fi
      else
          # Fallback for jshon or no parser
          if echo "$response" | grep -q '"success":true'; then
              first_record=$(echo "$response" | jshon -e data -e 0 2>/dev/null || echo "null")
              if [ "$first_record" != "null" ]; then
                  echo "{\"success\":true,\"data\":$first_record}"
              else
                  echo '{"success":true,"data":null}'
              fi
          else
              echo "$response"
          fi
      fi
  elif [ "$tail_flag" = "true" ]; then
      # Extract last record from array
      print_info "Returning last record only"
      if [ "$JSON_PARSER" = "jq" ]; then
          if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
              last_record=$(echo "$response" | jq '.data[-1] // null')
              echo "$response" | jq --argjson last "$last_record" '{"success": .success, "data": $last}'
          else
              echo "$response"
          fi
      else
          # Fallback for jshon or no parser
          if echo "$response" | grep -q '"success":true'; then
              array_length=$(echo "$response" | jshon -e data -l 2>/dev/null || echo "0")
              if [ "$array_length" -gt 0 ]; then
                  last_index=$((array_length - 1))
                  last_record=$(echo "$response" | jshon -e data -e "$last_index" 2>/dev/null || echo "null")
                  echo "{\"success\":true,\"data\":$last_record}"
              else
                  echo '{"success":true,"data":null}'
              fi
          else
              echo "$response"
          fi
      fi
  else
      # Use standard response handler
      handle_response_json "$response" "find"
  fi
}

# :command.function
monk_aggregate_command() {

  # src/commands/aggregate.sh
  #!/bin/bash

  # aggregate_command.sh - Aggregation queries with GROUP BY and statistics
  #
  # This command performs aggregation operations using the Aggregate API with support
  # for filtering, grouping, and statistical functions like COUNT, SUM, AVG, MIN, MAX.
  #
  # Usage Examples:
  #   echo '{"aggregate": {"total": {"$count": "*"}}}' | monk aggregate orders
  #   echo '{"where": {"status": "paid"}, "aggregate": {"total_revenue": {"$sum": "amount"}}}' | monk aggregate orders
  #   echo '{"aggregate": {"orders": {"$count": "*"}, "revenue": {"$sum": "amount"}}, "groupBy": ["country"]}' | monk aggregate orders
  #   cat aggregation-query.json | monk aggregate sales
  #
  # Aggregation Functions:
  #   - $count: Count records (use "*" for all records or field name for non-null values)
  #   - $sum: Sum numeric values
  #   - $avg: Average of numeric values
  #   - $min: Minimum value
  #   - $max: Maximum value
  #   - $distinct: Count distinct values
  #
  # Query Structure:
  #   where: Optional filter conditions (same as find command)
  #   aggregate: Required object with named aggregation functions
  #   groupBy: Optional array of field names to group results
  #
  # API Endpoint:
  #   POST /api/aggregate/:schema (with JSON payload)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  validate_schema "$schema"

  # Read and validate JSON input
  json_data=$(read_and_validate_json_input "aggregating" "$schema")

  # Make the aggregate request
  response=$(make_request_json "POST" "/api/aggregate/$schema" "$json_data")

  # Use standard response handler
  handle_response_json "$response" "aggregate"

}

# :command.function
monk_sync_pull_command() {

  # src/commands/sync/pull.sh
  #!/bin/bash

  # sync_pull_command.sh - Pull data from remote tenant to local directory
  #
  # This command fetches records from a remote tenant and saves them as individual
  # JSON files in a local directory. It's essentially a wrapper around data export
  # but with the sync endpoint format.
  #
  # Usage Examples:
  #   monk sync pull tenant-a:users ./backup/users/
  #   monk sync pull server1:tenant-a:users ./backup/
  #   monk sync pull tenant-a:orders ./backup/ --filter '{"where": {"status": "paid"}}'
  #
  # Endpoint Format:
  #   tenant:schema              - Uses current server
  #   server:tenant:schema       - Uses specific server
  #
  # Output Structure:
  #   - Creates target directory if it doesn't exist
  #   - One file per record: {directory}/{record_id}.json
  #   - Pretty-formatted JSON with indentation
  #
  # API Endpoint:
  #   GET /api/data/:schema or POST /api/find/:schema (with filter)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  source_endpoint="${args[source]}"
  directory="${args[directory]}"
  filter_json="${args[--filter]}"
  overwrite="${args[--overwrite]}"

  # Parse source endpoint
  print_info "Parsing source endpoint: $source_endpoint"
  endpoint_info=$(parse_sync_endpoint "$source_endpoint")

  if [ $? -ne 0 ]; then
      print_error "Failed to parse source endpoint"
      exit 1
  fi

  # Extract endpoint details
  endpoint_type=$(echo "$endpoint_info" | jq -r '.type')

  if [ "$endpoint_type" != "remote" ]; then
      print_error "Source must be a remote endpoint (tenant:schema or server:tenant:schema)"
      exit 1
  fi

  server=$(echo "$endpoint_info" | jq -r '.server')
  tenant=$(echo "$endpoint_info" | jq -r '.tenant')
  schema=$(echo "$endpoint_info" | jq -r '.schema')

  print_info "Source: server=$server, tenant=$tenant, schema=$schema"
  print_info "Destination: $directory"

  # Validate schema
  validate_schema "$schema"

  # Create directory if it doesn't exist
  if [ ! -d "$directory" ]; then
      print_info "Creating directory: $directory"
      mkdir -p "$directory"
  fi

  # Check for existing files
  if [ "$overwrite" != "true" ] && [ -n "$(ls -A "$directory"/*.json 2>/dev/null)" ]; then
      print_error "Directory contains existing JSON files. Use --overwrite to replace them."
      exit 1
  fi

  # Fetch data from remote
  print_info "Fetching records from $server:$tenant:$schema..."
  records_json=$(sync_fetch_remote "$server" "$tenant" "$schema" "$filter_json")

  if [ $? -ne 0 ]; then
      print_error "Failed to fetch records from remote"
      exit 1
  fi

  # Check if jq is available
  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for export functionality"
      exit 1
  fi

  # Validate that we got an array
  if ! echo "$records_json" | jq -e 'type == "array"' >/dev/null 2>&1; then
      print_error "Expected array of records from remote"
      echo "$records_json" >&2
      exit 1
  fi

  # Export each record to individual JSON file
  count=0
  while IFS= read -r record; do
      # Extract ID from record
      id=$(echo "$record" | jq -r '.id // empty')

      if [ -z "$id" ] || [ "$id" = "null" ]; then
          print_warning "Skipping record without id field"
          continue
      fi

      # Write pretty-formatted JSON to file
      filename="$directory/$id.json"
      echo "$record" | jq '.' > "$filename"

      if [ $? -eq 0 ]; then
          print_info "Pulled: $filename"
          count=$((count + 1))
      else
          print_error "Failed to write: $filename"
          exit 1
      fi

  done < <(echo "$records_json" | jq -c '.[]')

  print_success "Successfully pulled $count records to $directory"

}

# :command.function
monk_sync_push_command() {

  # src/commands/sync/push.sh
  #!/bin/bash

  # sync_push_command.sh - Push data from local directory to remote tenant
  #
  # This command reads JSON files from a local directory and imports them as records
  # into a remote tenant. It's essentially a wrapper around data import but with
  # the sync endpoint format.
  #
  # Usage Examples:
  #   monk sync push ./backup/users/ tenant-b:users
  #   monk sync push ./backup/ server2:tenant-b:users
  #   monk sync push ./backup/users/ tenant-b:users --dry-run
  #
  # Endpoint Format:
  #   tenant:schema              - Uses current server
  #   server:tenant:schema       - Uses specific server
  #
  # Input Structure:
  #   - Scans directory for all *.json files
  #   - Each file should contain a valid JSON object (one record)
  #   - Files processed in sorted order by filename
  #   - All records combined into array for bulk import
  #
  # API Endpoint:
  #   PUT /api/data/:schema (bulk import with array payload)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  directory="${args[directory]}"
  dest_endpoint="${args[destination]}"
  dry_run="${args[--dry-run]}"

  # Validate directory exists
  if [ ! -d "$directory" ]; then
      print_error "Directory does not exist: $directory"
      exit 1
  fi

  # Parse destination endpoint
  print_info "Parsing destination endpoint: $dest_endpoint"
  endpoint_info=$(parse_sync_endpoint "$dest_endpoint")

  if [ $? -ne 0 ]; then
      print_error "Failed to parse destination endpoint"
      exit 1
  fi

  # Extract endpoint details
  endpoint_type=$(echo "$endpoint_info" | jq -r '.type')

  if [ "$endpoint_type" != "remote" ]; then
      print_error "Destination must be a remote endpoint (tenant:schema or server:tenant:schema)"
      exit 1
  fi

  server=$(echo "$endpoint_info" | jq -r '.server')
  tenant=$(echo "$endpoint_info" | jq -r '.tenant')
  schema=$(echo "$endpoint_info" | jq -r '.schema')

  print_info "Source: $directory"
  print_info "Destination: server=$server, tenant=$tenant, schema=$schema"

  # Validate schema
  validate_schema "$schema"

  # Check for JSON files in directory
  json_files=("$directory"/*.json)

  # Check if glob found any files
  if [ ! -f "${json_files[0]}" ]; then
      print_error "No .json files found in directory: $directory"
      exit 1
  fi

  print_info "Found ${#json_files[@]} JSON files to push"

  # Check if jq is available
  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for import functionality"
      exit 1
  fi

  # Collect all JSON files into an array using jq
  records_json=$(jq -n --slurpfile records <(cat "${json_files[@]}") '$records')

  if [ -z "$records_json" ] || [ "$records_json" = "null" ]; then
      print_error "Failed to process JSON files"
      exit 1
  fi

  # Validate each file was valid JSON
  count=0
  for file in "${json_files[@]}"; do
      filename=$(basename "$file")
      print_info "Loaded: $filename"
      count=$((count + 1))
  done

  print_info "Prepared $count records for push"

  # Dry run mode
  if [ "$dry_run" = "true" ]; then
      print_info "DRY RUN: Would push $count records to $server:$tenant:$schema"
      echo "$records_json" | jq '.[] | {id: .id, preview: (. | keys | .[0:3])}'
      print_success "Dry run completed (no changes made)"
      exit 0
  fi

  # Save current context
  prev_server=$(get_current_server_name)
  prev_tenant=$(get_current_tenant_name)

  # Switch to target context
  if [ "$server" != "$prev_server" ]; then
      switch_server "$server" >/dev/null 2>&1 || {
          print_error "Failed to switch to server: $server"
          exit 1
      }
  fi

  if [ "$tenant" != "$prev_tenant" ]; then
      switch_tenant "$tenant" >/dev/null 2>&1 || {
          print_error "Failed to switch to tenant: $tenant"
          # Restore previous server
          [ -n "$prev_server" ] && switch_server "$prev_server" >/dev/null 2>&1
          exit 1
      }
  fi

  # Make bulk import request
  print_info "Pushing $count records to $server:$tenant:$schema..."
  response=$(make_request_json "PUT" "/api/data/$schema" "$records_json")

  # Restore previous context
  [ -n "$prev_tenant" ] && switch_tenant "$prev_tenant" >/dev/null 2>&1
  [ -n "$prev_server" ] && switch_server "$prev_server" >/dev/null 2>&1

  # Handle response
  print_success "Push completed successfully"
  handle_response_json "$response" "import"

}

# :command.function
monk_sync_diff_command() {

  # src/commands/sync/diff.sh
  #!/bin/bash

  # sync_diff_command.sh - Show differences between two endpoints
  #
  # This command compares two datasets (remote or local) and displays the differences.
  # It can show a summary, detailed view, or output JSON for scripting.
  # Optionally saves the diff as a patch file for later application.
  #
  # Usage Examples:
  #   monk sync diff tenant-a:users tenant-b:users
  #   monk sync diff tenant-a:users ./backup/users/ --format json
  #   monk sync diff server1:tenant-a:users server2:tenant-b:users --output sync.patch
  #   monk sync diff tenant-a:orders tenant-b:orders --filter '{"where": {"status": "paid"}}'
  #
  # Endpoint Formats:
  #   tenant:schema              - Uses current server
  #   server:tenant:schema       - Uses specific server
  #   /path/to/directory         - Local filesystem
  #
  # Output Formats:
  #   summary (default)          - Human-readable summary with counts and percentages
  #   json                       - Machine-readable JSON with full diff details
  #
  # Patch File:
  #   When --output is specified, creates a JSON patch file that can be applied
  #   with 'monk sync patch' command.

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  source_endpoint="${args[source]}"
  dest_endpoint="${args[destination]}"
  format="${args[--format]:-summary}"
  output_file="${args[--output]}"
  filter_json="${args[--filter]}"

  # Parse source endpoint
  print_info "Parsing source endpoint: $source_endpoint"
  source_info=$(parse_sync_endpoint "$source_endpoint")

  if [ $? -ne 0 ]; then
      print_error "Failed to parse source endpoint"
      exit 1
  fi

  # Parse destination endpoint
  print_info "Parsing destination endpoint: $dest_endpoint"
  dest_info=$(parse_sync_endpoint "$dest_endpoint")

  if [ $? -ne 0 ]; then
      print_error "Failed to parse destination endpoint"
      exit 1
  fi

  # Extract endpoint types
  source_type=$(echo "$source_info" | jq -r '.type')
  dest_type=$(echo "$dest_info" | jq -r '.type')

  # Fetch source data
  print_info "Fetching source data..."
  if [ "$source_type" = "remote" ]; then
      server=$(echo "$source_info" | jq -r '.server')
      tenant=$(echo "$source_info" | jq -r '.tenant')
      schema=$(echo "$source_info" | jq -r '.schema')
      source_data=$(sync_fetch_remote "$server" "$tenant" "$schema" "$filter_json")
  elif [ "$source_type" = "local" ]; then
      path=$(echo "$source_info" | jq -r '.path')
      if [ ! -d "$path" ]; then
          print_error "Source directory does not exist: $path"
          exit 1
      fi
      # Load all JSON files from directory
      source_data=$(jq -n --slurpfile records <(cat "$path"/*.json 2>/dev/null) '$records')
      if [ -z "$source_data" ] || [ "$source_data" = "null" ] || [ "$source_data" = "[]" ]; then
          print_error "No JSON files found in source directory: $path"
          exit 1
      fi
  fi

  if [ $? -ne 0 ] || [ -z "$source_data" ]; then
      print_error "Failed to fetch source data"
      exit 1
  fi

  # Fetch destination data
  print_info "Fetching destination data..."
  if [ "$dest_type" = "remote" ]; then
      server=$(echo "$dest_info" | jq -r '.server')
      tenant=$(echo "$dest_info" | jq -r '.tenant')
      schema=$(echo "$dest_info" | jq -r '.schema')
      dest_data=$(sync_fetch_remote "$server" "$tenant" "$schema" "$filter_json")
  elif [ "$dest_type" = "local" ]; then
      path=$(echo "$dest_info" | jq -r '.path')
      if [ ! -d "$path" ]; then
          print_error "Destination directory does not exist: $path"
          exit 1
      fi
      # Load all JSON files from directory
      dest_data=$(jq -n --slurpfile records <(cat "$path"/*.json 2>/dev/null) '$records')
      if [ -z "$dest_data" ] || [ "$dest_data" = "null" ] || [ "$dest_data" = "[]" ]; then
          # Empty destination is okay
          dest_data="[]"
      fi
  fi

  if [ $? -ne 0 ]; then
      print_error "Failed to fetch destination data"
      exit 1
  fi

  # Compute diff
  print_info "Computing diff..."
  diff_json=$(sync_compute_diff "$source_data" "$dest_data")

  if [ $? -ne 0 ]; then
      print_error "Failed to compute diff"
      exit 1
  fi

  # Add metadata to diff
  diff_with_metadata=$(echo "$diff_json" | jq \
      --arg source "$source_endpoint" \
      --arg dest "$dest_endpoint" \
      --arg created "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
      '. + {
          metadata: {
              source: $source,
              destination: $dest,
              created_at: $created,
              filter: null
          }
      }'
  )

  # Save to patch file if requested
  if [ -n "$output_file" ]; then
      echo "$diff_with_metadata" | jq '.' > "$output_file"
      print_success "Diff saved to patch file: $output_file"
  fi

  # Format and display diff
  if [ "$format" = "json" ]; then
      echo "$diff_with_metadata" | jq '.'
  else
      # Summary format
      echo ""
      sync_format_diff "$diff_json" "summary"
      echo ""

      if [ -n "$output_file" ]; then
          echo "Patch file saved: $output_file"
          echo "Apply with: monk sync patch $output_file <destination>"
      fi
  fi

}

# :command.function
monk_sync_copy_command() {

  # src/commands/sync/copy.sh
  #!/bin/bash

  # sync_copy_command.sh - Direct copy between two remote tenants (streaming)
  #
  # This command performs a direct synchronization between two remote tenants
  # without using local filesystem as intermediary. It's the most efficient
  # way to sync data between tenants, especially for large datasets.
  #
  # Usage Examples:
  #   monk sync copy tenant-a:users tenant-b:users
  #   monk sync copy server1:tenant-a:users server2:tenant-b:users
  #   monk sync copy tenant-a:orders tenant-b:orders --strategy merge
  #   monk sync copy tenant-a:users tenant-b:users --dry-run
  #   monk sync copy tenant-a:users tenant-b:users --filter '{"where": {"status": "active"}}'
  #
  # Endpoint Format:
  #   tenant:schema              - Uses current server
  #   server:tenant:schema       - Uses specific server
  #
  # Sync Strategies:
  #   replace (default)          - Delete all destination records, insert all source records
  #   merge                      - Update existing by ID, insert new ones (no deletes)
  #
  # Process:
  #   1. Fetch all records from source
  #   2. Optionally show diff
  #   3. Apply changes to destination using bulk API

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  source_endpoint="${args[source]}"
  dest_endpoint="${args[destination]}"
  filter_json="${args[--filter]}"
  dry_run="${args[--dry-run]}"
  strategy="${args[--strategy]:-replace}"

  # Parse source endpoint
  print_info "Parsing source endpoint: $source_endpoint"
  source_info=$(parse_sync_endpoint "$source_endpoint")

  if [ $? -ne 0 ]; then
      print_error "Failed to parse source endpoint"
      exit 1
  fi

  # Parse destination endpoint
  print_info "Parsing destination endpoint: $dest_endpoint"
  dest_info=$(parse_sync_endpoint "$dest_endpoint")

  if [ $? -ne 0 ]; then
      print_error "Failed to parse destination endpoint"
      exit 1
  fi

  # Validate both are remote endpoints
  source_type=$(echo "$source_info" | jq -r '.type')
  dest_type=$(echo "$dest_info" | jq -r '.type')

  if [ "$source_type" != "remote" ] || [ "$dest_type" != "remote" ]; then
      print_error "Both source and destination must be remote endpoints"
      print_info "Use 'monk sync pull' for remotelocal or 'monk sync push' for localremote"
      exit 1
  fi

  # Extract endpoint details
  src_server=$(echo "$source_info" | jq -r '.server')
  src_tenant=$(echo "$source_info" | jq -r '.tenant')
  src_schema=$(echo "$source_info" | jq -r '.schema')

  dst_server=$(echo "$dest_info" | jq -r '.server')
  dst_tenant=$(echo "$dest_info" | jq -r '.tenant')
  dst_schema=$(echo "$dest_info" | jq -r '.schema')

  print_info "Source: $src_server:$src_tenant:$src_schema"
  print_info "Destination: $dst_server:$dst_tenant:$dst_schema"
  print_info "Strategy: $strategy"

  # Validate schemas
  validate_schema "$src_schema"
  validate_schema "$dst_schema"

  # Fetch source data
  print_info "Fetching source records..."
  source_data=$(sync_fetch_remote "$src_server" "$src_tenant" "$src_schema" "$filter_json")

  if [ $? -ne 0 ] || [ -z "$source_data" ]; then
      print_error "Failed to fetch source data"
      exit 1
  fi

  source_count=$(echo "$source_data" | jq 'length')
  print_info "Found $source_count records in source"

  if [ "$source_count" -eq 0 ]; then
      print_warning "No records found in source"
      exit 0
  fi

  # Fetch destination data for diff
  print_info "Fetching destination records..."
  dest_data=$(sync_fetch_remote "$dst_server" "$dst_tenant" "$dst_schema" "")

  if [ $? -ne 0 ]; then
      print_error "Failed to fetch destination data"
      exit 1
  fi

  dest_count=$(echo "$dest_data" | jq 'length')
  print_info "Found $dest_count records in destination"

  # Compute diff
  print_info "Computing differences..."
  diff_json=$(sync_compute_diff "$source_data" "$dest_data")

  if [ $? -ne 0 ]; then
      print_error "Failed to compute diff"
      exit 1
  fi

  # Show summary
  echo ""
  sync_format_diff "$diff_json" "summary"
  echo ""

  # Extract operation counts
  to_insert=$(echo "$diff_json" | jq -r '.summary.to_insert')
  to_update=$(echo "$diff_json" | jq -r '.summary.to_update')
  to_delete=$(echo "$diff_json" | jq -r '.summary.to_delete')
  unchanged=$(echo "$diff_json" | jq -r '.summary.unchanged')

  # Calculate total changes
  total_changes=$((to_insert + to_update + to_delete))

  if [ "$total_changes" -eq 0 ]; then
      print_success "No changes needed - datasets are identical"
      exit 0
  fi

  # Dry run mode
  if [ "$dry_run" = "true" ]; then
      print_info "DRY RUN: Would apply $total_changes changes"
      print_success "Dry run completed (no changes made)"
      exit 0
  fi

  # Save current context
  prev_server=$(get_current_server_name)
  prev_tenant=$(get_current_tenant_name)

  # Switch to destination context
  if [ "$dst_server" != "$prev_server" ]; then
      switch_server "$dst_server" >/dev/null 2>&1 || {
          print_error "Failed to switch to destination server: $dst_server"
          exit 1
      }
  fi

  if [ "$dst_tenant" != "$prev_tenant" ]; then
      switch_tenant "$dst_tenant" >/dev/null 2>&1 || {
          print_error "Failed to switch to destination tenant: $dst_tenant"
          # Restore previous server
          [ -n "$prev_server" ] && switch_server "$prev_server" >/dev/null 2>&1
          exit 1
      }
  fi

  # Apply changes based on strategy
  if [ "$strategy" = "replace" ]; then
      print_info "Applying replace strategy: delete all + insert all"

      # Delete all existing records (if any)
      if [ "$dest_count" -gt 0 ]; then
          print_info "Deleting $dest_count existing records..."
          delete_response=$(make_request_json "DELETE" "/api/data/$dst_schema" '{"where": {}}')

          if ! echo "$delete_response" | jq -e '.success == true' >/dev/null 2>&1; then
              print_error "Failed to delete existing records"
              echo "$delete_response" | jq -r '.error // "Unknown error"' >&2
              # Restore context
              [ -n "$prev_tenant" ] && switch_tenant "$prev_tenant" >/dev/null 2>&1
              [ -n "$prev_server" ] && switch_server "$prev_server" >/dev/null 2>&1
              exit 1
          fi
      fi

      # Insert all source records
      print_info "Inserting $source_count records..."
      import_response=$(make_request_json "PUT" "/api/data/$dst_schema" "$source_data")

  elif [ "$strategy" = "merge" ]; then
      print_info "Applying merge strategy: upsert records"

      # Use bulk API for mixed operations
      operations="[]"

      # Add insert operations
      if [ "$to_insert" -gt 0 ]; then
          print_info "Preparing $to_insert insert operations..."
          operations=$(echo "$diff_json" | jq -c --arg schema "$dst_schema" '
              [.operations[] | select(.op == "insert") | {
                  operation: "create-one",
                  schema: $schema,
                  data: .record
              }]
          ')
      fi

      # Add update operations
      if [ "$to_update" -gt 0 ]; then
          print_info "Preparing $to_update update operations..."
          updates=$(echo "$diff_json" | jq -c --arg schema "$dst_schema" '
              [.operations[] | select(.op == "update") | {
                  operation: "update-one",
                  schema: $schema,
                  id: .id,
                  data: .new
              }]
          ')
          operations=$(jq -n --argjson ops "$operations" --argjson updates "$updates" '$ops + $updates')
      fi

      # Execute bulk operations with new API format
      if [ "$operations" != "[]" ]; then
          print_info "Executing $(echo "$operations" | jq 'length') operations via bulk API..."
          wrapped_payload=$(echo "$operations" | jq '{operations: .}')
          bulk_response=$(make_request_json "POST" "/api/bulk" "$wrapped_payload")

          # Extract data from response
          if echo "$bulk_response" | jq -e '.success == true' >/dev/null 2>&1; then
              import_response=$(echo "$bulk_response" | jq '{success: true, data: .data}')
          else
              import_response="$bulk_response"
          fi
      else
          import_response='{"success": true, "message": "No operations to perform"}'
      fi
  fi

  # Restore previous context
  [ -n "$prev_tenant" ] && switch_tenant "$prev_tenant" >/dev/null 2>&1
  [ -n "$prev_server" ] && switch_server "$prev_server" >/dev/null 2>&1

  # Check response
  if echo "$import_response" | jq -e '.success == true' >/dev/null 2>&1; then
      print_success "Sync completed successfully"
      echo "$import_response" | jq '.'
  else
      print_error "Sync failed"
      echo "$import_response" | jq '.'
      exit 1
  fi

}

# :command.function
monk_sync_patch_command() {

  # src/commands/sync/patch.sh
  #!/bin/bash

  # sync_patch_command.sh - Apply a previously generated patch file
  #
  # This command applies a patch file created by 'monk sync diff --output' to a
  # destination endpoint. The patch contains a list of operations (insert, update,
  # delete) that will be executed using the bulk API for efficiency.
  #
  # Usage Examples:
  #   monk sync patch changes.patch tenant-b:users
  #   monk sync patch migration.patch server2:tenant-b:users --dry-run
  #   monk sync patch changes.patch tenant-b:users --reverse
  #
  # Patch File Format:
  #   JSON file containing metadata and list of operations.
  #   Generated by: monk sync diff source dest --output patch.json
  #
  # Endpoint Format:
  #   tenant:schema              - Uses current server
  #   server:tenant:schema       - Uses specific server
  #
  # Options:
  #   --dry-run                  - Show what would be done without applying
  #   --reverse                  - Apply patch in reverse (undo changes)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  patch_file="${args[patch_file]}"
  dest_endpoint="${args[destination]}"
  dry_run="${args[--dry-run]}"
  reverse="${args[--reverse]}"

  # Validate patch file exists
  if [ ! -f "$patch_file" ]; then
      print_error "Patch file does not exist: $patch_file"
      exit 1
  fi

  # Check if jq is available
  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for patch operations"
      exit 1
  fi

  # Read and validate patch file
  print_info "Reading patch file: $patch_file"
  patch_json=$(cat "$patch_file")

  if ! echo "$patch_json" | jq -e '.operations' >/dev/null 2>&1; then
      print_error "Invalid patch file format: missing 'operations' field"
      exit 1
  fi

  # Extract metadata
  patch_source=$(echo "$patch_json" | jq -r '.metadata.source // "unknown"')
  patch_dest=$(echo "$patch_json" | jq -r '.metadata.destination // "unknown"')
  patch_created=$(echo "$patch_json" | jq -r '.metadata.created_at // "unknown"')

  print_info "Patch created: $patch_created"
  print_info "Original source: $patch_source"
  print_info "Original destination: $patch_dest"

  # Parse destination endpoint
  print_info "Parsing destination endpoint: $dest_endpoint"
  endpoint_info=$(parse_sync_endpoint "$dest_endpoint")

  if [ $? -ne 0 ]; then
      print_error "Failed to parse destination endpoint"
      exit 1
  fi

  # Validate it's a remote endpoint
  endpoint_type=$(echo "$endpoint_info" | jq -r '.type')

  if [ "$endpoint_type" != "remote" ]; then
      print_error "Destination must be a remote endpoint (tenant:schema or server:tenant:schema)"
      exit 1
  fi

  # Extract endpoint details
  server=$(echo "$endpoint_info" | jq -r '.server')
  tenant=$(echo "$endpoint_info" | jq -r '.tenant')
  schema=$(echo "$endpoint_info" | jq -r '.schema')

  print_info "Target: $server:$tenant:$schema"

  # Validate schema
  validate_schema "$schema"

  # Extract operations
  operations=$(echo "$patch_json" | jq '.operations')

  # Get operation counts
  total_ops=$(echo "$operations" | jq 'length')
  insert_count=$(echo "$operations" | jq '[.[] | select(.op == "insert")] | length')
  update_count=$(echo "$operations" | jq '[.[] | select(.op == "update")] | length')
  delete_count=$(echo "$operations" | jq '[.[] | select(.op == "delete")] | length')
  unchanged_count=$(echo "$operations" | jq '[.[] | select(.op == "unchanged")] | length')

  print_info "Patch contains $total_ops operations:"
  print_info "  Insert: $insert_count"
  print_info "  Update: $update_count"
  print_info "  Delete: $delete_count"
  print_info "  Unchanged: $unchanged_count (will skip)"

  # Filter out unchanged operations
  active_ops=$((insert_count + update_count + delete_count))

  if [ "$active_ops" -eq 0 ]; then
      print_success "No operations to apply - patch is empty"
      exit 0
  fi

  # Reverse mode: swap operations
  if [ "$reverse" = "true" ]; then
      print_info "REVERSE MODE: Reversing patch operations"
      operations=$(echo "$operations" | jq '
          map(
              if .op == "insert" then
                  {op: "delete", id: .id, record: .record}
              elif .op == "delete" then
                  {op: "insert", id: .id, record: .record}
              elif .op == "update" then
                  {op: "update", id: .id, old: .new, new: .old}
              else
                  .
              end
          )
      ')
  fi

  # Show summary
  echo ""
  echo "Patch Summary"
  echo ""
  if [ "$reverse" = "true" ]; then
      echo "Mode: REVERSE (undo)"
  else
      echo "Mode: FORWARD (apply)"
  fi
  echo "Target: $server:$tenant:$schema"
  echo "Operations to apply: $active_ops"
  echo ""
  echo ""

  # Dry run mode
  if [ "$dry_run" = "true" ]; then
      print_info "DRY RUN: Would apply $active_ops operations"

      # Show sample operations
      echo "$operations" | jq -r '
          .[] | select(.op != "unchanged") |

          "\(.op | ascii_upcase): \(.id)"
      ' | head -10

      if [ "$active_ops" -gt 10 ]; then
          echo "... and $((active_ops - 10)) more operations"
      fi

      print_success "Dry run completed (no changes made)"
      exit 0
  fi

  # Convert patch operations to bulk API format
  print_info "Converting patch to bulk operations..."
  bulk_operations=$(echo "$operations" | jq -c --arg schema "$schema" '
      [
          .[] |

          select(.op != "unchanged") |
          if .op == "insert" then
              {
                  operation: "create-one",
                  schema: $schema,
                  data: .record
              }
          elif .op == "update" then
              {
                  operation: "update-one",
                  schema: $schema,
                  id: .id,
                  data: .new
              }
          elif .op == "delete" then
              {
                  operation: "delete-one",
                  schema: $schema,
                  id: .id
              }
          else
              empty
          end
      ]
  ')

  # Validate bulk operations
  bulk_count=$(echo "$bulk_operations" | jq 'length')

  if [ "$bulk_count" -eq 0 ]; then
      print_success "No operations to apply"
      exit 0
  fi

  print_info "Prepared $bulk_count bulk operations"

  # Save current context
  prev_server=$(get_current_server_name)
  prev_tenant=$(get_current_tenant_name)

  # Switch to destination context
  if [ "$server" != "$prev_server" ]; then
      switch_server "$server" >/dev/null 2>&1 || {
          print_error "Failed to switch to server: $server"
          exit 1
      }
  fi

  if [ "$tenant" != "$prev_tenant" ]; then
      switch_tenant "$tenant" >/dev/null 2>&1 || {
          print_error "Failed to switch to tenant: $tenant"
          # Restore previous server
          [ -n "$prev_server" ] && switch_server "$prev_server" >/dev/null 2>&1
          exit 1
      }
  fi

  # Apply patch using bulk API with new format
  print_info "Applying patch via bulk API..."
  wrapped_payload=$(echo "$bulk_operations" | jq '{operations: .}')
  response=$(make_request_json "POST" "/api/bulk" "$wrapped_payload")

  # Restore previous context
  [ -n "$prev_tenant" ] && switch_tenant "$prev_tenant" >/dev/null 2>&1
  [ -n "$prev_server" ] && switch_server "$prev_server" >/dev/null 2>&1

  # Check response - new API format returns {"success": true, "data": [...]}
  if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
      data=$(echo "$response" | jq '.data')

      # Count successes and errors from data array
      total=$(echo "$data" | jq 'length')
      # In new format, each operation result is in the data array

      print_success "Patch applied: $total operations completed"
      echo "$data" | jq '.'
  else
      print_error "Patch application failed"
      echo "$response" | jq '.'
      exit 1
  fi

}

# :command.function
monk_docs_command() {

  # src/commands/docs.sh
  #!/bin/bash

  # docs_command.sh - Display API documentation from remote server
  #
  # This command dynamically discovers available documentation areas by querying
  # the API root endpoint, then fetches documentation for the requested area.
  #
  # Usage Examples:
  #   monk docs auth              # Display authentication API documentation
  #   monk docs data              # Display data API documentation

  #   monk docs describe          # Display schema description API documentation
  #   monk docs badarea           # Show available areas if no exact match
  #
  # Output Format:
  #   - Uses glow for enhanced markdown formatting when available
  #   - Falls back to raw markdown if glow not installed
  #   - Supports --text flag for raw markdown output
  #
  # Dynamic Discovery:
  #   - Queries GET / to get available documentation areas
  #   - Matches exact area name against documentation keys
  #   - Shows available areas if no exact match found

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  area="${args[area]}"

  # Determine output format from global flags
  output_format=$(get_output_format "glow")

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for documentation commands"
      exit 1
  fi

  # Get current server
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      print_error "No current server selected"
      print_info "Use 'monk server use <name>' to select a server first"
      exit 1
  fi

  # Get server info
  server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      print_error "Current server '$current_server' not found in registry"
      print_info "Use 'monk server list' to see available servers"
      exit 1
  fi

  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"

  print_info "Discovering available documentation areas from: $current_server"

  # Query API root to get available documentation areas
  if api_response=$(curl -s --max-time 30 --fail "$base_url/" 2>/dev/null); then
      # Extract documentation section
      if ! documentation_section=$(echo "$api_response" | jq -r '.data.documentation // empty' 2>/dev/null); then
          print_error "Failed to parse API response for documentation areas"
          exit 1
      fi

      if [ -z "$documentation_section" ] || [ "$documentation_section" = "null" ]; then
          print_error "No documentation section found in API response"
          print_info "The API may not support dynamic documentation discovery"
          exit 1
      fi

      # Get available areas (keys from documentation object)
      available_areas=$(echo "$documentation_section" | jq -r 'keys[]' 2>/dev/null)

      if [ -z "$available_areas" ]; then
          print_error "No documentation areas found"
          exit 1
      fi

      # Check if requested area exists (exact match)
      area_found=false
      area_routes=""

      for available_area in $available_areas; do
          if [ "$available_area" = "$area" ]; then
              area_found=true
              # Get the routes for this area (should be an array)
              area_routes=$(echo "$documentation_section" | jq -r ".$area[]" 2>/dev/null)
              break
          fi
      done

      if [ "$area_found" = false ]; then
          print_error "Documentation area '$area' not found"
          echo "Available documentation areas:" >&2
          for available_area in $available_areas; do
              echo "  - $available_area" >&2
          done
          exit 1
      fi

      # Use the first route for the area
      if [ -z "$area_routes" ]; then
          print_error "No documentation routes found for area '$area'"
          exit 1
      fi

      # Get the first route from the array
      first_route=$(echo "$area_routes" | head -n 1)

      if [ -z "$first_route" ]; then
          print_error "Empty documentation route for area '$area'"
          exit 1
      fi

      print_info "Fetching documentation for area '$area' from: $first_route"

      # Fetch documentation from the discovered route
      if docs_content=$(curl -s --max-time 30 --fail "$base_url$first_route" 2>/dev/null); then
          # Display content based on output format
          if [[ "$output_format" == "text" ]]; then
              # Raw markdown output when --text flag is used
              echo "$docs_content"
          elif command -v glow >/dev/null 2>&1; then
              # Use glow for enhanced formatting when available
              echo "$docs_content" | glow --width=0 --pager -
          else
              # Fallback to raw markdown if glow not installed
              echo "$docs_content"
          fi
      else
          print_error "Failed to fetch documentation from route '$first_route'"
          print_info "Ensure server is running and documentation endpoint is available"
          exit 1
      fi

  else
      print_error "Failed to query API root endpoint for documentation discovery"
      print_info "Ensure server '$current_server' is running and accessible"
      exit 1
  fi

}

# :command.function
monk_sudo_users_list_command() {

  # src/commands/sudo/users/list.sh
  #!/bin/bash

  # sudo_users_list_command.sh - List all users via /api/sudo/users

  # Check dependencies
  check_dependencies

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for user listing"
      exit 1
  fi

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Make request to sudo API
  response=$(make_sudo_request "GET" "users" "")

  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      if [[ "$output_format" == "text" ]]; then
          # Human-readable table output
          users=$(echo "$response" | jq -r '.data')
          count=$(echo "$users" | jq 'length')

          echo
          print_info "Total users: $count"
          echo

          if [[ "$count" -gt 0 ]]; then
              printf "%-36s %-30s %-30s %-10s\n" "ID" "NAME" "AUTH" "ACCESS"
              echo "--------------------------------------------------------------------------------"

              echo "$users" | jq -r '.[] | [.id, .name, .auth, .access] | @tsv' | \
              while IFS=$'\t' read -r id name auth access; do
                  printf "%-36s %-30s %-30s %-10s\n" "$id" "$name" "$auth" "$access"
              done
          else
              print_info "No users found"
          fi
          echo
      else
          # JSON output - pass through compact JSON
          handle_output "$response" "$output_format" "json"
      fi
  else
      print_error "Failed to retrieve users"
      echo "$response" >&2
      exit 1
  fi

}

# :command.function
monk_sudo_users_create_command() {

  # src/commands/sudo/users/create.sh
  #!/bin/bash

  # sudo_users_create_command.sh - Create new user via /api/sudo/users

  # Check dependencies
  check_dependencies

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for user creation"
      exit 1
  fi

  # Get arguments from bashly flags
  name="${args[--name]}"
  auth="${args[--auth]}"
  access="${args[--access]}"

  # Validate required fields
  if [ -z "$name" ]; then
      print_error "Name is required (--name)"
      exit 1
  fi

  if [ -z "$auth" ]; then
      print_error "Auth identifier is required (--auth)"
      exit 1
  fi

  if [ -z "$access" ]; then
      print_error "Access level is required (--access)"
      exit 1
  fi

  print_info "Creating user: $name ($auth) with access level: $access"

  # Build user creation JSON
  user_data=$(jq -n \
      --arg name "$name" \
      --arg auth "$auth" \
      --arg access "$access" \
      '{
          "name": $name,
          "auth": $auth,
          "access": $access,
          "access_read": [],
          "access_edit": [],
          "access_full": []
      }')

  # Make request to sudo API
  response=$(make_sudo_request "POST" "users" "$user_data")

  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      # Extract user data
      user=$(echo "$response" | jq -r '.data')
      user_id=$(echo "$user" | jq -r '.id')

      print_success "User created successfully"
      print_info_always "User ID: $user_id"
      print_info_always "Name: $name"
      print_info_always "Auth: $auth"
      print_info_always "Access: $access"
  else
      print_error "Failed to create user"
      echo "$response" >&2
      exit 1
  fi

}

# :command.function
monk_sudo_users_show_command() {

  # src/commands/sudo/users/show.sh
  #!/bin/bash

  # sudo_users_show_command.sh - Show user details via /api/sudo/users/:id

  # Check dependencies
  check_dependencies

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for user operations"
      exit 1
  fi

  # Get user ID from args
  user_id="${args[id]}"

  if [ -z "$user_id" ]; then
      print_error "User ID is required"
      exit 1
  fi

  print_info "Fetching user details for: $user_id"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Make request to sudo API
  response=$(make_sudo_request "GET" "users/${user_id}" "")

  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      if [[ "$output_format" == "text" ]]; then
          # Human-readable output
          user=$(echo "$response" | jq -r '.data')

          echo
          print_success "User Details"
          echo
          echo "ID:          $(echo "$user" | jq -r '.id')"
          echo "Name:        $(echo "$user" | jq -r '.name')"
          echo "Auth:        $(echo "$user" | jq -r '.auth')"
          echo "Access:      $(echo "$user" | jq -r '.access')"
          echo "Created:     $(echo "$user" | jq -r '.created_at')"
          echo "Updated:     $(echo "$user" | jq -r '.updated_at')"
          echo
      else
          # JSON output - pass through compact JSON
          handle_output "$response" "$output_format" "json"
      fi
  else
      print_error "Failed to retrieve user details"
      echo "$response" >&2
      exit 1
  fi

}

# :command.function
monk_sudo_users_update_command() {

  # src/commands/sudo/users/update.sh
  #!/bin/bash

  # sudo_users_update_command.sh - Update user via /api/sudo/users/:id

  # Check dependencies
  check_dependencies

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for user operations"
      exit 1
  fi

  # Get user ID from args
  user_id="${args[id]}"
  name="${args[--name]}"
  access="${args[--access]}"

  if [ -z "$user_id" ]; then
      print_error "User ID is required"
      exit 1
  fi

  # Build update JSON with only provided fields
  update_fields=()

  if [ -n "$name" ]; then
      update_fields+=("--arg name \"$name\"")
      update_fields+=('.name = $name')
  fi

  if [ -n "$access" ]; then
      update_fields+=("--arg access \"$access\"")
      update_fields+=('.access = $access')
  fi

  if [ ${#update_fields[@]} -eq 0 ]; then
      print_error "At least one field must be provided (--name or --access)"
      exit 1
  fi

  # Build jq command for partial update
  jq_args=""
  jq_filter="{"
  first=true

  i=0
  while [ $i -lt ${#update_fields[@]} ]; do
      field="${update_fields[$i]}"
      if [[ "$field" == --arg* ]]; then
          jq_args="$jq_args $field"
          i=$((i + 1))
          filter="${update_fields[$i]}"
          if [ "$first" = true ]; then
              jq_filter="$jq_filter $filter"
              first=false
          else
              jq_filter="$jq_filter, $filter"
          fi
      fi
      i=$((i + 1))
  done

  jq_filter="$jq_filter }"

  print_info "Updating user: $user_id"

  # Create update payload
  update_data=$(eval "jq -n $jq_args '$jq_filter'")

  # Make request to sudo API
  response=$(make_sudo_request "PATCH" "users/${user_id}" "$update_data")

  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      # Extract updated user data
      user=$(echo "$response" | jq -r '.data')

      print_success "User updated successfully"
      print_info_always "User ID: $user_id"

      if [ -n "$name" ]; then
          print_info_always "Name: $name"
      fi

      if [ -n "$access" ]; then
          print_info_always "Access: $access"
      fi
  else
      print_error "Failed to update user"
      echo "$response" >&2
      exit 1
  fi

}

# :command.function
monk_sudo_users_delete_command() {

  # src/commands/sudo/users/delete.sh
  #!/bin/bash

  # sudo_users_delete_command.sh - Delete user via /api/sudo/users/:id

  # Check dependencies
  check_dependencies

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for user operations"
      exit 1
  fi

  # Get user ID from args
  user_id="${args[id]}"
  force="${args[--force]}"

  if [ -z "$user_id" ]; then
      print_error "User ID is required"
      exit 1
  fi

  # Confirm deletion unless --force is used
  if [ "$force" != "1" ]; then
      echo
      print_warning "This will soft-delete the user: $user_id"
      read -p "Are you sure? (y/N): " -n 1 -r
      echo
      if [[ ! $REPLY =~ ^[Yy]$ ]]; then
          print_info "Delete cancelled"
          exit 0
      fi
  fi

  print_info "Deleting user: $user_id"

  # Make request to sudo API
  response=$(make_sudo_request "DELETE" "users/${user_id}" "")

  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      print_success "User deleted successfully"
      print_info_always "User ID: $user_id"

      # Show trashed_at if available
      trashed_at=$(echo "$response" | jq -r '.data.trashed_at // empty')
      if [ -n "$trashed_at" ]; then
          print_info_always "Trashed at: $trashed_at"
      fi
  else
      print_error "Failed to delete user"
      echo "$response" >&2
      exit 1
  fi

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        monk_usage
        exit
        ;;

      # :flag.case
      --text)

        # :flag.case_no_arg
        args['--text']=1
        shift
        ;;

      # :flag.case
      --json)

        # :flag.case_no_arg
        args['--json']=1
        shift
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("CLI_VERBOSE")
  env_var_names+=("MONK_CLI_CONFIG_DIR")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init)
      action="init"
      shift
      monk_init_parse_requirements "$@"
      shift $#
      ;;

    examples)
      action="examples"
      shift
      monk_examples_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      monk_status_parse_requirements "$@"
      shift $#
      ;;

    curl)
      action="curl"
      shift
      monk_curl_parse_requirements "$@"
      shift $#
      ;;

    server)
      action="server"
      shift
      monk_server_parse_requirements "$@"
      shift $#
      ;;

    tenant)
      action="tenant"
      shift
      monk_tenant_parse_requirements "$@"
      shift $#
      ;;

    auth)
      action="auth"
      shift
      monk_auth_parse_requirements "$@"
      shift $#
      ;;

    data)
      action="data"
      shift
      monk_data_parse_requirements "$@"
      shift $#
      ;;

    describe)
      action="describe"
      shift
      monk_describe_parse_requirements "$@"
      shift $#
      ;;

    bulk)
      action="bulk"
      shift
      monk_bulk_parse_requirements "$@"
      shift $#
      ;;

    fs)
      action="fs"
      shift
      monk_fs_parse_requirements "$@"
      shift $#
      ;;

    find)
      action="find"
      shift
      monk_find_parse_requirements "$@"
      shift $#
      ;;

    aggregate)
      action="aggregate"
      shift
      monk_aggregate_parse_requirements "$@"
      shift $#
      ;;

    sync)
      action="sync"
      shift
      monk_sync_parse_requirements "$@"
      shift $#
      ;;

    docs)
      action="docs"
      shift
      monk_docs_parse_requirements "$@"
      shift $#
      ;;

    sudo)
      action="sudo"
      shift
      monk_sudo_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_usage >&2
      exit 0
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_examples_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_examples_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="examples"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_curl_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_curl_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="curl"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --data | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--data']="$2"
          shift
          shift
        else
          printf "%s\n" "--data requires an argument: --data, -d JSON" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --raw | -r)

        # :flag.case_no_arg
        args['--raw']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['method']+x} ]]; then
          args['method']=$1
          shift
        # :argument.case
        elif [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['method']+x} ]]; then
    printf "missing required argument: METHOD\nusage: monk curl METHOD PATH [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk curl METHOD PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_server_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      monk_server_add_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_server_list_parse_requirements "$@"
      shift $#
      ;;

    current)
      action="current"
      shift
      monk_server_current_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      monk_server_use_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_server_delete_parse_requirements "$@"
      shift $#
      ;;

    ping)
      action="ping"
      shift
      monk_server_ping_parse_requirements "$@"
      shift $#
      ;;

    ping-all)
      action="ping-all"
      shift
      monk_server_ping_all_parse_requirements "$@"
      shift $#
      ;;

    info)
      action="info"
      shift
      monk_server_info_parse_requirements "$@"
      shift $#
      ;;

    health)
      action="health"
      shift
      monk_server_health_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_server_usage >&2
      exit 0
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --description)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description DESCRIPTION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        # :argument.case
        elif [[ -z ${args['endpoint']+x} ]]; then
          args['endpoint']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk server add NAME ENDPOINT [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['endpoint']+x} ]]; then
    printf "missing required argument: ENDPOINT\nusage: monk server add NAME ENDPOINT [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_server_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_current_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_current_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server current"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk server delete NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_server_ping_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_ping_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server ping"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_ping_all_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_ping_all_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server ping-all"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_info_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_info_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server info"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_health_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_health_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server health"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      monk_tenant_add_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_tenant_list_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_tenant_delete_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      monk_tenant_use_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_tenant_usage >&2
      exit 0
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --description)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description DESCRIPTION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        # :argument.case
        elif [[ -z ${args['display_name']+x} ]]; then
          args['display_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant add NAME DISPLAY_NAME [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['display_name']+x} ]]; then
    printf "missing required argument: DISPLAY_NAME\nusage: monk tenant add NAME DISPLAY_NAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_tenant_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --server)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--server']="$2"
          shift
          shift
        else
          printf "%s\n" "--server requires an argument: --server SERVER" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant delete NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_tenant_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant use NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list)
      action="list"
      shift
      monk_auth_list_parse_requirements "$@"
      shift $#
      ;;

    register)
      action="register"
      shift
      monk_auth_register_parse_requirements "$@"
      shift $#
      ;;

    login)
      action="login"
      shift
      monk_auth_login_parse_requirements "$@"
      shift $#
      ;;

    logout)
      action="logout"
      shift
      monk_auth_logout_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      monk_auth_status_parse_requirements "$@"
      shift $#
      ;;

    token)
      action="token"
      shift
      monk_auth_token_parse_requirements "$@"
      shift $#
      ;;

    info)
      action="info"
      shift
      monk_auth_info_parse_requirements "$@"
      shift $#
      ;;

    ping)
      action="ping"
      shift
      monk_auth_ping_parse_requirements "$@"
      shift $#
      ;;

    import)
      action="import"
      shift
      monk_auth_import_parse_requirements "$@"
      shift $#
      ;;

    expires)
      action="expires"
      shift
      monk_auth_expires_parse_requirements "$@"
      shift $#
      ;;

    expired)
      action="expired"
      shift
      monk_auth_expired_parse_requirements "$@"
      shift $#
      ;;

    tenants)
      action="tenants"
      shift
      monk_auth_tenants_parse_requirements "$@"
      shift $#
      ;;

    sudo)
      action="sudo"
      shift
      monk_auth_sudo_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_auth_usage >&2
      exit 0
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_register_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_register_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth register"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --database)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--database']="$2"
          shift
          shift
        else
          printf "%s\n" "--database requires an argument: --database DATABASE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --description)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description DESCRIPTION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['tenant']+x} ]]; then
          args['tenant']=$1
          shift
        # :argument.case
        elif [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tenant']+x} ]]; then
    printf "missing required argument: TENANT\nusage: monk auth register TENANT [USERNAME] [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_login_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_login_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth login"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['tenant']+x} ]]; then
          args['tenant']=$1
          shift
        # :argument.case
        elif [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tenant']+x} ]]; then
    printf "missing required argument: TENANT\nusage: monk auth login TENANT USERNAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: monk auth login TENANT USERNAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_logout_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_logout_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth logout"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_token_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_token_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth token"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_info_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_info_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth info"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_ping_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_ping_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth ping"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      # :flag.case
      --jwt-token | -j)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--jwt-token']="$2"
          shift
          shift
        else
          printf "%s\n" "--jwt-token requires an argument: --jwt-token, -j TOKEN" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_import_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_import_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth import"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --token | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--token']="$2"
          shift
          shift
        else
          printf "%s\n" "--token requires an argument: --token, -t TOKEN" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['tenant']+x} ]]; then
          args['tenant']=$1
          shift
        # :argument.case
        elif [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tenant']+x} ]]; then
    printf "missing required argument: TENANT\nusage: monk auth import TENANT USERNAME [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: monk auth import TENANT USERNAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_expires_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_expires_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth expires"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_expired_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_expired_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth expired"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_tenants_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_tenants_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth tenants"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_sudo_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_sudo_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth sudo"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --reason)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--reason']="$2"
          shift
          shift
        else
          printf "%s\n" "--reason requires an argument: --reason REASON" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_data_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list)
      action="list"
      shift
      monk_data_list_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      monk_data_create_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_data_update_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_data_delete_parse_requirements "$@"
      shift $#
      ;;

    export)
      action="export"
      shift
      monk_data_export_parse_requirements "$@"
      shift $#
      ;;

    import)
      action="import"
      shift
      monk_data_import_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_data_usage >&2
      exit 0
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_data_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --filter)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--filter']="$2"
          shift
          shift
        else
          printf "%s\n" "--filter requires an argument: --filter JSON" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data list SCHEMA [ID] [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data create SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data update SCHEMA [ID]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data delete SCHEMA [ID]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_export_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_export_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data export"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['dir']+x} ]]; then
          args['dir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data export SCHEMA DIR\n" >&2

    exit 1
  fi

  if [[ -z ${args['dir']+x} ]]; then
    printf "missing required argument: DIR\nusage: monk data export SCHEMA DIR\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_import_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_import_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data import"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['dir']+x} ]]; then
          args['dir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data import SCHEMA DIR\n" >&2

    exit 1
  fi

  if [[ -z ${args['dir']+x} ]]; then
    printf "missing required argument: DIR\nusage: monk data import SCHEMA DIR\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_describe_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list)
      action="list"
      shift
      monk_describe_list_parse_requirements "$@"
      shift $#
      ;;

    select)
      action="select"
      shift
      monk_describe_select_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      monk_describe_create_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_describe_update_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_describe_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_describe_usage >&2
      exit 0
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_describe_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="describe list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_describe_select_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_select_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="describe select"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk describe select SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_describe_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="describe create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk describe create SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_describe_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="describe update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk describe update SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_describe_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="describe delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk describe delete SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_bulk_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bulk"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_fs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    ls)
      action="ls"
      shift
      monk_fs_ls_parse_requirements "$@"
      shift $#
      ;;

    cat)
      action="cat"
      shift
      monk_fs_cat_parse_requirements "$@"
      shift $#
      ;;

    rm)
      action="rm"
      shift
      monk_fs_rm_parse_requirements "$@"
      shift $#
      ;;

    stat)
      action="stat"
      shift
      monk_fs_stat_parse_requirements "$@"
      shift $#
      ;;

    cp)
      action="cp"
      shift
      monk_fs_cp_parse_requirements "$@"
      shift $#
      ;;

    size)
      action="size"
      shift
      monk_fs_size_parse_requirements "$@"
      shift $#
      ;;

    mtime)
      action="mtime"
      shift
      monk_fs_mtime_parse_requirements "$@"
      shift $#
      ;;

    find)
      action="find"
      shift
      monk_fs_find_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_fs_usage >&2
      exit 0
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_fs_ls_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_ls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs ls"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --long | -l)

        # :flag.case_no_arg
        args['--long']=1
        shift
        ;;

      # :flag.case
      --all | -a)

        # :flag.case_no_arg
        args['--all']=1
        shift
        ;;

      # :flag.case
      --sort | -S)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--sort']="$2"
          shift
          shift
        else
          printf "%s\n" "--sort requires an argument: --sort, -S FIELD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --reverse | -r)

        # :flag.case_no_arg
        args['--reverse']=1
        shift
        ;;

      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs ls PATH [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--sort']:-} ]] || args['--sort']="name"

  # :command.whitelist_filter
  if [[ ${args['--sort']:-} ]] && [[ ! ${args['--sort']:-} =~ ^(name|size|time|type)$ ]]; then
    printf "%s\n" "--sort must be one of: name, size, time, type" >&2
    exit 1
  fi

}

# :command.parse_requirements
monk_fs_cat_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_cat_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs cat"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --format | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format, -f FORMAT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --offset | -o)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--offset']="$2"
          shift
          shift
        else
          printf "%s\n" "--offset requires an argument: --offset, -o BYTES" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --max-bytes | -m)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--max-bytes']="$2"
          shift
          shift
        else
          printf "%s\n" "--max-bytes requires an argument: --max-bytes, -m BYTES" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs cat PATH [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--format']:-} ]] || args['--format']="json"

  # :command.whitelist_filter
  if [[ ${args['--format']:-} ]] && [[ ! ${args['--format']:-} =~ ^(json|raw)$ ]]; then
    printf "%s\n" "--format must be one of: json, raw" >&2
    exit 1
  fi

}

# :command.parse_requirements
monk_fs_rm_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_rm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs rm"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs rm PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_stat_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_stat_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs stat"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs stat PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_cp_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_cp_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs cp"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --recursive | -r)

        # :flag.case_no_arg
        args['--recursive']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['source']+x} ]]; then
          args['source']=$1
          shift
        # :argument.case
        elif [[ -z ${args['destination']+x} ]]; then
          args['destination']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source']+x} ]]; then
    printf "missing required argument: SOURCE\nusage: monk fs cp SOURCE DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['destination']+x} ]]; then
    printf "missing required argument: DESTINATION\nusage: monk fs cp SOURCE DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_size_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_size_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs size"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs size PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_mtime_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_mtime_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs mtime"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs mtime PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_find_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_find_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs find"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --where | -w)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          escaped="$(printf '%q' "$2")"
          if [[ -z ${args['--where']+x} ]]; then
            args['--where']="$escaped"
          else
            args['--where']="${args['--where']} $escaped"
          fi
          shift
          shift
        else
          printf "%s\n" "--where requires an argument: --where, -w CONDITION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --type | -T)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--type']="$2"
          shift
          shift
        else
          printf "%s\n" "--type requires an argument: --type, -T TYPE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --name | -n)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name, -n PATTERN" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --maxdepth)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--maxdepth']="$2"
          shift
          shift
        else
          printf "%s\n" "--maxdepth requires an argument: --maxdepth DEPTH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --print0)

        # :flag.case_no_arg
        args['--print0']=1
        shift
        ;;

      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs find PATH [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.whitelist_filter
  if [[ ${args['--type']:-} ]] && [[ ! ${args['--type']:-} =~ ^(f|d|l)$ ]]; then
    printf "%s\n" "--type must be one of: f, d, l" >&2
    exit 1
  fi

}

# :command.parse_requirements
monk_find_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_find_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="find"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --head | -H)

        # :flag.case_no_arg
        args['--head']=1
        shift
        ;;

      # :flag.case
      --tail | -T)

        # :flag.case_no_arg
        args['--tail']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk find SCHEMA [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_aggregate_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_aggregate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="aggregate"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk aggregate SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_sync_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sync_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    pull)
      action="pull"
      shift
      monk_sync_pull_parse_requirements "$@"
      shift $#
      ;;

    push)
      action="push"
      shift
      monk_sync_push_parse_requirements "$@"
      shift $#
      ;;

    diff)
      action="diff"
      shift
      monk_sync_diff_parse_requirements "$@"
      shift $#
      ;;

    copy)
      action="copy"
      shift
      monk_sync_copy_parse_requirements "$@"
      shift $#
      ;;

    patch)
      action="patch"
      shift
      monk_sync_patch_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_sync_usage >&2
      exit 0
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_sync_pull_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sync_pull_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sync pull"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --filter | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--filter']="$2"
          shift
          shift
        else
          printf "%s\n" "--filter requires an argument: --filter, -f JSON" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --overwrite)

        # :flag.case_no_arg
        args['--overwrite']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['source']+x} ]]; then
          args['source']=$1
          shift
        # :argument.case
        elif [[ -z ${args['directory']+x} ]]; then
          args['directory']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source']+x} ]]; then
    printf "missing required argument: SOURCE\nusage: monk sync pull SOURCE DIRECTORY [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['directory']+x} ]]; then
    printf "missing required argument: DIRECTORY\nusage: monk sync pull SOURCE DIRECTORY [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_sync_push_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sync_push_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sync push"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --dry-run)

        # :flag.case_no_arg
        args['--dry-run']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['directory']+x} ]]; then
          args['directory']=$1
          shift
        # :argument.case
        elif [[ -z ${args['destination']+x} ]]; then
          args['destination']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['directory']+x} ]]; then
    printf "missing required argument: DIRECTORY\nusage: monk sync push DIRECTORY DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['destination']+x} ]]; then
    printf "missing required argument: DESTINATION\nusage: monk sync push DIRECTORY DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_sync_diff_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sync_diff_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sync diff"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --format)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--format']="$2"
          shift
          shift
        else
          printf "%s\n" "--format requires an argument: --format FORMAT" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --output | -o)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--output']="$2"
          shift
          shift
        else
          printf "%s\n" "--output requires an argument: --output, -o FILE" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --filter | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--filter']="$2"
          shift
          shift
        else
          printf "%s\n" "--filter requires an argument: --filter, -f JSON" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['source']+x} ]]; then
          args['source']=$1
          shift
        # :argument.case
        elif [[ -z ${args['destination']+x} ]]; then
          args['destination']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source']+x} ]]; then
    printf "missing required argument: SOURCE\nusage: monk sync diff SOURCE DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['destination']+x} ]]; then
    printf "missing required argument: DESTINATION\nusage: monk sync diff SOURCE DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--format']:-} ]] || args['--format']="summary"

  # :command.whitelist_filter
  if [[ ${args['--format']:-} ]] && [[ ! ${args['--format']:-} =~ ^(summary|json)$ ]]; then
    printf "%s\n" "--format must be one of: summary, json" >&2
    exit 1
  fi

}

# :command.parse_requirements
monk_sync_copy_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sync_copy_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sync copy"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --filter | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--filter']="$2"
          shift
          shift
        else
          printf "%s\n" "--filter requires an argument: --filter, -f JSON" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --dry-run)

        # :flag.case_no_arg
        args['--dry-run']=1
        shift
        ;;

      # :flag.case
      --strategy)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--strategy']="$2"
          shift
          shift
        else
          printf "%s\n" "--strategy requires an argument: --strategy STRATEGY" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['source']+x} ]]; then
          args['source']=$1
          shift
        # :argument.case
        elif [[ -z ${args['destination']+x} ]]; then
          args['destination']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source']+x} ]]; then
    printf "missing required argument: SOURCE\nusage: monk sync copy SOURCE DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['destination']+x} ]]; then
    printf "missing required argument: DESTINATION\nusage: monk sync copy SOURCE DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--strategy']:-} ]] || args['--strategy']="replace"

  # :command.whitelist_filter
  if [[ ${args['--strategy']:-} ]] && [[ ! ${args['--strategy']:-} =~ ^(replace|merge)$ ]]; then
    printf "%s\n" "--strategy must be one of: replace, merge" >&2
    exit 1
  fi

}

# :command.parse_requirements
monk_sync_patch_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sync_patch_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sync patch"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --dry-run)

        # :flag.case_no_arg
        args['--dry-run']=1
        shift
        ;;

      # :flag.case
      --reverse | -R)

        # :flag.case_no_arg
        args['--reverse']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['patch_file']+x} ]]; then
          args['patch_file']=$1
          shift
        # :argument.case
        elif [[ -z ${args['destination']+x} ]]; then
          args['destination']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['patch_file']+x} ]]; then
    printf "missing required argument: PATCH_FILE\nusage: monk sync patch PATCH_FILE DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['destination']+x} ]]; then
    printf "missing required argument: DESTINATION\nusage: monk sync patch PATCH_FILE DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_docs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_docs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="docs"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['area']+x} ]]; then
          args['area']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['area']+x} ]]; then
    printf "missing required argument: AREA\nusage: monk docs AREA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_sudo_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sudo_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    users)
      action="users"
      shift
      monk_sudo_users_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_sudo_usage >&2
      exit 0
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_sudo_users_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sudo_users_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list | ls)
      action="list"
      shift
      monk_sudo_users_list_parse_requirements "$@"
      shift $#
      ;;

    create | add)
      action="create"
      shift
      monk_sudo_users_create_parse_requirements "$@"
      shift $#
      ;;

    show | info)
      action="show"
      shift
      monk_sudo_users_show_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_sudo_users_update_parse_requirements "$@"
      shift $#
      ;;

    delete | rm)
      action="delete"
      shift
      monk_sudo_users_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_sudo_users_usage >&2
      exit 0
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_sudo_users_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sudo_users_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sudo users list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_sudo_users_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sudo_users_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sudo users create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --name)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --auth)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--auth']="$2"
          shift
          shift
        else
          printf "%s\n" "--auth requires an argument: --auth AUTH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --access)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--access']="$2"
          shift
          shift
        else
          printf "%s\n" "--access requires an argument: --access ACCESS" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--name']+x} ]]; then
    printf "missing required flag: --name NAME\n" >&2
    exit 1
  fi
  if [[ -z ${args['--auth']+x} ]]; then
    printf "missing required flag: --auth AUTH\n" >&2
    exit 1
  fi
  if [[ -z ${args['--access']+x} ]]; then
    printf "missing required flag: --access ACCESS\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
monk_sudo_users_show_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sudo_users_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sudo users show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk sudo users show ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_sudo_users_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sudo_users_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sudo users update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --name)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--name']="$2"
          shift
          shift
        else
          printf "%s\n" "--name requires an argument: --name NAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --access)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--access']="$2"
          shift
          shift
        else
          printf "%s\n" "--access requires an argument: --access ACCESS" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk sudo users update ID [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_sudo_users_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_sudo_users_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="sudo users delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk sudo users delete ID [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="2.21.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "init") monk_init_command ;;
    "examples") monk_examples_command ;;
    "status") monk_status_command ;;
    "curl") monk_curl_command ;;
    "server") monk_server_command ;;
    "server add") monk_server_add_command ;;
    "server list") monk_server_list_command ;;
    "server current") monk_server_current_command ;;
    "server use") monk_server_use_command ;;
    "server delete") monk_server_delete_command ;;
    "server ping") monk_server_ping_command ;;
    "server ping-all") monk_server_ping_all_command ;;
    "server info") monk_server_info_command ;;
    "server health") monk_server_health_command ;;
    "tenant") monk_tenant_command ;;
    "tenant add") monk_tenant_add_command ;;
    "tenant list") monk_tenant_list_command ;;
    "tenant delete") monk_tenant_delete_command ;;
    "tenant use") monk_tenant_use_command ;;
    "auth") monk_auth_command ;;
    "auth list") monk_auth_list_command ;;
    "auth register") monk_auth_register_command ;;
    "auth login") monk_auth_login_command ;;
    "auth logout") monk_auth_logout_command ;;
    "auth status") monk_auth_status_command ;;
    "auth token") monk_auth_token_command ;;
    "auth info") monk_auth_info_command ;;
    "auth ping") monk_auth_ping_command ;;
    "auth import") monk_auth_import_command ;;
    "auth expires") monk_auth_expires_command ;;
    "auth expired") monk_auth_expired_command ;;
    "auth tenants") monk_auth_tenants_command ;;
    "auth sudo") monk_auth_sudo_command ;;
    "data") monk_data_command ;;
    "data list") monk_data_list_command ;;
    "data create") monk_data_create_command ;;
    "data update") monk_data_update_command ;;
    "data delete") monk_data_delete_command ;;
    "data export") monk_data_export_command ;;
    "data import") monk_data_import_command ;;
    "describe") monk_describe_command ;;
    "describe list") monk_describe_list_command ;;
    "describe select") monk_describe_select_command ;;
    "describe create") monk_describe_create_command ;;
    "describe update") monk_describe_update_command ;;
    "describe delete") monk_describe_delete_command ;;
    "bulk") monk_bulk_command ;;
    "fs") monk_fs_command ;;
    "fs ls") monk_fs_ls_command ;;
    "fs cat") monk_fs_cat_command ;;
    "fs rm") monk_fs_rm_command ;;
    "fs stat") monk_fs_stat_command ;;
    "fs cp") monk_fs_cp_command ;;
    "fs size") monk_fs_size_command ;;
    "fs mtime") monk_fs_mtime_command ;;
    "fs find") monk_fs_find_command ;;
    "find") monk_find_command ;;
    "aggregate") monk_aggregate_command ;;
    "sync") monk_sync_command ;;
    "sync pull") monk_sync_pull_command ;;
    "sync push") monk_sync_push_command ;;
    "sync diff") monk_sync_diff_command ;;
    "sync copy") monk_sync_copy_command ;;
    "sync patch") monk_sync_patch_command ;;
    "docs") monk_docs_command ;;
    "sudo") monk_sudo_command ;;
    "sudo users") monk_sudo_users_command ;;
    "sudo users list") monk_sudo_users_list_command ;;
    "sudo users create") monk_sudo_users_create_command ;;
    "sudo users show") monk_sudo_users_show_command ;;
    "sudo users update") monk_sudo_users_update_command ;;
    "sudo users delete") monk_sudo_users_delete_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
