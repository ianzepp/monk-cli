#!/usr/bin/env bash
# This script was generated by bashly 1.3.1 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
monk_usage() {
  printf "monk - Monk CLI - Command-line interface for PaaS Backend API\n\n"

  printf "%s\n" "Usage:"
  printf "  monk [OPTIONS] COMMAND\n"
  printf "  monk [COMMAND] --help | -h\n"
  printf "  monk --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Initialize configuration directory with required files\n" "init    "
  printf "  %s   Browse interactive examples and complete workflows (start here!)\n" "examples"
  printf "  %s   Show current server, tenant, user, and available schemas\n" "status  "
  printf "  %s   Remote server management\n" "server  "
  printf "  %s   Tenant registry management\n" "tenant  "
  printf "  %s   Authentication and token management\n" "auth    "
  printf "  %s   Data operations on dynamic schemas\n" "data    "
  printf "  %s   Schema description and metadata management\n" "describe"
  printf "  %s   Bulk operations for batch processing across multiple schemas\n" "bulk    "
  printf "  %s   Filesystem-like operations for API data exploration via File API\n" "fs      "
  printf "  %s   Advanced search with enterprise Filter DSL via JSON input\n" "find    "
  printf "  %s   Project management for simplified tenant creation and workflow\n" "project "
  printf "  %s   View API documentation from remote server\n" "docs    "
  printf "  %s   Administrative operations for tenant management (localhost development only)\n" "root    "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Global Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--text"
    printf "    Output in human-readable text format\n"
    echo

    # :flag.usage
    printf "  %s\n" "--json"
    printf "    Output in JSON format\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "CLI_VERBOSE"
    printf "    Enable verbose output for all commands\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "MONK_CLI_CONFIG_DIR"
    printf "    Custom directory for CLI configuration files (default: ~/.config/monk/cli)\n"
    echo

  fi
}

# :command.usage
monk_init_usage() {
  printf "monk init - Initialize configuration directory with required files\n\n"

  printf "%s\n" "Usage:"
  printf "  monk init [PATH] [OPTIONS]\n"
  printf "  monk init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force"
    printf "    Force reinitialization by overwriting existing config files (preserves\n    env.json)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    Custom path for configuration directory (default: ~/.config/monk/cli)\n"
    echo

  fi
}

# :command.usage
monk_examples_usage() {
  printf "monk examples - Browse interactive examples and complete workflows (start here!)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk examples [NAME]\n"
  printf "  monk examples --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Example name to display (omit to list all examples)\n"
    echo

  fi
}

# :command.usage
monk_status_usage() {
  printf "monk status - Show current server, tenant, user, and available schemas\n\n"

  printf "%s\n" "Usage:"
  printf "  monk status\n"
  printf "  monk status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_usage() {
  printf "monk server - Remote server management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server COMMAND\n"
  printf "  monk server [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Register remote server\n" "add     "
  printf "  %s   List all servers with health status\n" "list    "
  printf "  %s   Show currently selected server\n" "current "
  printf "  %s   Switch to server (persistent selection) or show current server\n" "use     "
  printf "  %s   Remove server from registry\n" "delete  "
  printf "  %s   Health check specific server (defaults to current server)\n" "ping    "
  printf "  %s   Health check all registered servers\n" "ping-all"
  printf "  %s   Show server information from API root endpoint\n" "info    "
  printf "  %s   Check server health status from API /health endpoint\n" "health  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_add_usage() {
  printf "monk server add - Register remote server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server add NAME ENDPOINT [OPTIONS]\n"
  printf "  monk server add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--description DESCRIPTION"
    printf "    Optional server description\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ENDPOINT"
    printf "    Server endpoint (host:port)\n"
    echo

  fi
}

# :command.usage
monk_server_list_usage() {
  printf "monk server list - List all servers with health status\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server list\n"
  printf "  monk server list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_current_usage() {
  printf "monk server current - Show currently selected server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server current\n"
  printf "  monk server current --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_use_usage() {
  printf "monk server use - Switch to server (persistent selection) or show current server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server use [NAME]\n"
  printf "  monk server use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to switch to (omit to show current server)\n"
    echo

  fi
}

# :command.usage
monk_server_delete_usage() {
  printf "monk server delete - Remove server from registry\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server delete NAME\n"
  printf "  monk server delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to delete\n"
    echo

  fi
}

# :command.usage
monk_server_ping_usage() {
  printf "monk server ping - Health check specific server (defaults to current server)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server ping [NAME]\n"
  printf "  monk server ping --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to ping (optional, defaults to current server)\n"
    echo

  fi
}

# :command.usage
monk_server_ping_all_usage() {
  printf "monk server ping-all - Health check all registered servers\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server ping-all\n"
  printf "  monk server ping-all --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_server_info_usage() {
  printf "monk server info - Show server information from API root endpoint\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server info [NAME]\n"
  printf "  monk server info --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to query (optional, defaults to current server)\n"
    echo

  fi
}

# :command.usage
monk_server_health_usage() {
  printf "monk server health - Check server health status from API /health endpoint\n\n"

  printf "%s\n" "Usage:"
  printf "  monk server health [NAME]\n"
  printf "  monk server health --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to check (optional, defaults to current server)\n"
    echo

  fi
}

# :command.usage
monk_tenant_usage() {
  printf "monk tenant - Tenant registry management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant COMMAND\n"
  printf "  monk tenant [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Register new tenant\n" "add   "
  printf "  %s   List all registered tenants\n" "list  "
  printf "  %s   Remove tenant from registry\n" "delete"
  printf "  %s   Switch to tenant (persistent selection)\n" "use   "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_add_usage() {
  printf "monk tenant add - Register new tenant\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant add NAME DISPLAY_NAME [OPTIONS]\n"
  printf "  monk tenant add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--description DESCRIPTION"
    printf "    Optional tenant description\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant identifier name\n"
    echo

    # :argument.usage
    printf "  %s\n" "DISPLAY_NAME"
    printf "    Human-readable tenant name\n"
    echo

  fi
}

# :command.usage
monk_tenant_list_usage() {
  printf "monk tenant list - List all registered tenants\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant list [OPTIONS]\n"
  printf "  monk tenant list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--server SERVER"
    printf "    Target server (defaults to current server)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_delete_usage() {
  printf "monk tenant delete - Remove tenant from registry\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant delete NAME\n"
  printf "  monk tenant delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name to delete\n"
    echo

  fi
}

# :command.usage
monk_tenant_use_usage() {
  printf "monk tenant use - Switch to tenant (persistent selection)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant use NAME\n"
  printf "  monk tenant use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name to switch to\n"
    echo

  fi
}

# :command.usage
monk_auth_usage() {
  printf "monk auth - Authentication and token management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth COMMAND\n"
  printf "  monk auth [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all stored JWT tokens and sessions\n" "list    "
  printf "  %s   Register new tenant and user (creates both and stores JWT)\n" "register"
  printf "  %s   Authenticate with tenant and username\n" "login   "
  printf "  %s   Clear stored JWT token\n" "logout  "
  printf "  %s   Show authentication status\n" "status  "
  printf "  %s   Display current JWT token\n" "token   "
  printf "  %s   Decode and display JWT token contents\n" "info    "
  printf "  %s   Authenticated API health check\n" "ping    "
  printf "  %s   Import JWT token from external auth flow\n" "import  "
  printf "  %s   Show JWT token expiration time\n" "expires "
  printf "  %s   Check if JWT token is expired (exit code 0=valid, 1=expired)\n" "expired "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_list_usage() {
  printf "monk auth list - List all stored JWT tokens and sessions\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth list\n"
  printf "  monk auth list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_register_usage() {
  printf "monk auth register - Register new tenant and user (creates both and stores JWT)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth register TENANT USERNAME\n"
  printf "  monk auth register --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TENANT"
    printf "    Tenant name to register\n"
    echo

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    Username to register\n"
    echo

  fi
}

# :command.usage
monk_auth_login_usage() {
  printf "monk auth login - Authenticate with tenant and username\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth login TENANT USERNAME\n"
  printf "  monk auth login --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TENANT"
    printf "    Tenant name for authentication\n"
    echo

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    Username for authentication\n"
    echo

  fi
}

# :command.usage
monk_auth_logout_usage() {
  printf "monk auth logout - Clear stored JWT token\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth logout\n"
  printf "  monk auth logout --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_status_usage() {
  printf "monk auth status - Show authentication status\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth status\n"
  printf "  monk auth status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_token_usage() {
  printf "monk auth token - Display current JWT token\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth token\n"
  printf "  monk auth token --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_info_usage() {
  printf "monk auth info - Decode and display JWT token contents\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth info\n"
  printf "  monk auth info --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_ping_usage() {
  printf "monk auth ping - Authenticated API health check\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth ping [OPTIONS]\n"
  printf "  monk auth ping --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Verbose server information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--jwt-token, -j TOKEN"
    printf "    Include JWT token in request\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_import_usage() {
  printf "monk auth import - Import JWT token from external auth flow\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth import TENANT USERNAME [OPTIONS]\n"
  printf "  monk auth import --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--token, -t TOKEN"
    printf "    JWT token to import (or provide via stdin)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TENANT"
    printf "    Tenant name for this JWT token\n"
    echo

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    Username for this JWT token\n"
    echo

  fi
}

# :command.usage
monk_auth_expires_usage() {
  printf "monk auth expires - Show JWT token expiration time\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth expires\n"
  printf "  monk auth expires --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_expired_usage() {
  printf "monk auth expired - Check if JWT token is expired (exit code 0=valid, 1=expired)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth expired\n"
  printf "  monk auth expired --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_data_usage() {
  printf "monk data - Data operations on dynamic schemas\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data COMMAND\n"
  printf "  monk data [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Select record(s) with flexible query support\n" "select"
  printf "  %s   Create record from stdin\n" "create"
  printf "  %s   Update record(s) from stdin\n" "update"
  printf "  %s   Delete record(s)\n" "delete"
  printf "  %s   Export records to JSON files\n" "export"
  printf "  %s   Import JSON files as records\n" "import"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_data_select_usage() {
  printf "monk data select - Select record(s) with flexible query support\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data select SCHEMA [ID] [OPTIONS]\n"
  printf "  monk data select --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--filter JSON"
    printf "    JSON filter for query parameters (limit, offset, order)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to retrieve (optional)\n"
    echo

  fi
}

# :command.usage
monk_data_create_usage() {
  printf "monk data create - Create record from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data create SCHEMA\n"
  printf "  monk data create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to create record in\n"
    echo

  fi
}

# :command.usage
monk_data_update_usage() {
  printf "monk data update - Update record(s) from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data update SCHEMA [ID]\n"
  printf "  monk data update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to update (optional if ID in JSON)\n"
    echo

  fi
}

# :command.usage
monk_data_delete_usage() {
  printf "monk data delete - Delete record(s)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data delete SCHEMA [ID]\n"
  printf "  monk data delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to delete (optional if ID in JSON or using stdin)\n"
    echo

  fi
}

# :command.usage
monk_data_export_usage() {
  printf "monk data export - Export records to JSON files\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data export SCHEMA DIR\n"
  printf "  monk data export --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to export\n"
    echo

    # :argument.usage
    printf "  %s\n" "DIR"
    printf "    Directory to export to\n"
    echo

  fi
}

# :command.usage
monk_data_import_usage() {
  printf "monk data import - Import JSON files as records\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data import SCHEMA DIR\n"
  printf "  monk data import --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to import into\n"
    echo

    # :argument.usage
    printf "  %s\n" "DIR"
    printf "    Directory to import from\n"
    echo

  fi
}

# :command.usage
monk_describe_usage() {
  printf "monk describe - Schema description and metadata management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe COMMAND\n"
  printf "  monk describe [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all available schema names in the current tenant\n" "list  "
  printf "  %s   Select specific schema definition\n" "select"
  printf "  %s   Create new schema from JSON definition\n" "create"
  printf "  %s   Update existing schema from JSON definition\n" "update"
  printf "  %s   Delete schema definition (soft delete)\n" "delete"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_describe_list_usage() {
  printf "monk describe list - List all available schema names in the current tenant\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe list\n"
  printf "  monk describe list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_describe_select_usage() {
  printf "monk describe select - Select specific schema definition\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe select SCHEMA\n"
  printf "  monk describe select --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to retrieve\n"
    echo

  fi
}

# :command.usage
monk_describe_create_usage() {
  printf "monk describe create - Create new schema from JSON definition\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe create SCHEMA\n"
  printf "  monk describe create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to create\n"
    echo

  fi
}

# :command.usage
monk_describe_update_usage() {
  printf "monk describe update - Update existing schema from JSON definition\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe update SCHEMA\n"
  printf "  monk describe update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to update\n"
    echo

  fi
}

# :command.usage
monk_describe_delete_usage() {
  printf "monk describe delete - Delete schema definition (soft delete)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk describe delete SCHEMA\n"
  printf "  monk describe delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to delete\n"
    echo

  fi
}

# :command.usage
monk_bulk_usage() {
  printf "monk bulk - Bulk operations for batch processing across multiple schemas\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk COMMAND\n"
  printf "  monk bulk [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Execute bulk operations immediately (synchronous)\n" "raw   "
  printf "  %s   Submit bulk operations for async processing (future feature)\n" "submit"
  printf "  %s   Check status of async bulk operation (future feature)\n" "status"
  printf "  %s   Download results of completed bulk operation (future feature)\n" "result"
  printf "  %s   Cancel pending bulk operation (future feature)\n" "cancel"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_bulk_raw_usage() {
  printf "monk bulk raw - Execute bulk operations immediately (synchronous)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk raw\n"
  printf "  monk bulk raw --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_bulk_submit_usage() {
  printf "monk bulk submit - Submit bulk operations for async processing (future feature)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk submit\n"
  printf "  monk bulk submit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_bulk_status_usage() {
  printf "monk bulk status - Check status of async bulk operation (future feature)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk status OPERATION_ID\n"
  printf "  monk bulk status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "OPERATION_ID"
    printf "    Bulk operation ID from submit command\n"
    echo

  fi
}

# :command.usage
monk_bulk_result_usage() {
  printf "monk bulk result - Download results of completed bulk operation (future feature)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk result OPERATION_ID\n"
  printf "  monk bulk result --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "OPERATION_ID"
    printf "    Bulk operation ID from submit command\n"
    echo

  fi
}

# :command.usage
monk_bulk_cancel_usage() {
  printf "monk bulk cancel - Cancel pending bulk operation (future feature)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk bulk cancel OPERATION_ID\n"
  printf "  monk bulk cancel --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "OPERATION_ID"
    printf "    Bulk operation ID to cancel\n"
    echo

  fi
}

# :command.usage
monk_fs_usage() {
  printf "monk fs - Filesystem-like operations for API data exploration via File API\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs COMMAND\n"
  printf "  monk fs [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List directory contents with wildcard support\n" "ls  "
  printf "  %s   Display file content or record data\n" "cat "
  printf "  %s   Remove files, records, or fields\n" "rm  "
  printf "  %s   Display detailed file/directory status and schema information\n" "stat"
  printf "  %s   Copy records between schemas or duplicate records\n" "cp  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_fs_ls_usage() {
  printf "monk fs ls - List directory contents with wildcard support\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs ls PATH [OPTIONS]\n"
  printf "  monk fs ls --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--long, -l"
    printf "    Use long listing format with detailed information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    File path (e.g., /data/users/, /tenant/tenant-a/data/users/)\n"
    echo

  fi
}

# :command.usage
monk_fs_cat_usage() {
  printf "monk fs cat - Display file content or record data\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs cat PATH [OPTIONS]\n"
  printf "  monk fs cat --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    File path to file or record (e.g., /data/users/user-123.json,\n    /tenant/tenant-a/data/users/user-123.json)\n"
    echo

  fi
}

# :command.usage
monk_fs_rm_usage() {
  printf "monk fs rm - Remove files, records, or fields\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs rm PATH [OPTIONS]\n"
  printf "  monk fs rm --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Force permanent deletion (default is soft delete)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    File path to delete (e.g., /data/users/user-123,\n    /tenant/tenant-a/data/users/user-123)\n"
    echo

  fi
}

# :command.usage
monk_fs_stat_usage() {
  printf "monk fs stat - Display detailed file/directory status and schema information\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs stat PATH [OPTIONS]\n"
  printf "  monk fs stat --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATH"
    printf "    File path for status information (e.g., /data/users/,\n    /tenant/tenant-a/meta/schema/)\n"
    echo

  fi
}

# :command.usage
monk_fs_cp_usage() {
  printf "monk fs cp - Copy records between schemas or duplicate records\n\n"

  printf "%s\n" "Usage:"
  printf "  monk fs cp SOURCE DESTINATION [OPTIONS]\n"
  printf "  monk fs cp --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--recursive, -r"
    printf "    Copy directory contents recursively\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Force overwrite and allow cross-tenant operations\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tenant, -t TENANT"
    printf "    Target tenant (tenant-name or server:tenant-name)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SOURCE"
    printf "    Source path (e.g., /data/users/123.json, /data/users/)\n"
    echo

    # :argument.usage
    printf "  %s\n" "DESTINATION"
    printf "    Destination path (e.g., /data/users/456.json, /data/backup/users/)\n"
    echo

  fi
}

# :command.usage
monk_find_usage() {
  printf "monk find - Advanced search with enterprise Filter DSL via JSON input\n\n"

  printf "%s\n" "Usage:"
  printf "  monk find SCHEMA [OPTIONS]\n"
  printf "  monk find --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--head, -H"
    printf "    Return only first record from results\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tail, -T"
    printf "    Return only last record from results\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema to search\n"
    echo

  fi
}

# :command.usage
monk_project_usage() {
  printf "monk project - Project management for simplified tenant creation and workflow\n\n"

  printf "%s\n" "Usage:"
  printf "  monk project COMMAND\n"
  printf "  monk project [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Initialize new project with automatic tenant creation\n" "init  "
  printf "  %s   List all projects (tenants)\n" "list  "
  printf "  %s   Show project details\n" "show  "
  printf "  %s   Switch to project context\n" "use   "
  printf "  %s   Delete project (soft delete by default)\n" "delete"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_project_init_usage() {
  printf "monk project init - Initialize new project with automatic tenant creation\n\n"

  printf "%s\n" "Usage:"
  printf "  monk project init NAME [OPTIONS]\n"
  printf "  monk project init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--description DESCRIPTION"
    printf "    Optional project description\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tags TAGS"
    printf "    Comma-separated project tags\n"
    echo

    # :flag.usage
    printf "  %s\n" "--create-user USERNAME"
    printf "    Create initial user with specified username\n"
    echo

    # :flag.usage
    printf "  %s\n" "--auto-login"
    printf "    Automatically login as created user\n"
    echo

    # :flag.usage
    printf "  %s\n" "--host HOSTNAME"
    printf "    Database host (default: localhost)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Project name (will be used as tenant name)\n"
    echo

  fi
}

# :command.usage
monk_project_list_usage() {
  printf "monk project list - List all projects (tenants)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk project list [OPTIONS]\n"
  printf "  monk project list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--include-trashed"
    printf "    Include soft-deleted projects\n"
    echo

    # :flag.usage
    printf "  %s\n" "--include-deleted"
    printf "    Include hard-deleted projects\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_project_show_usage() {
  printf "monk project show - Show project details\n\n"
  printf "Alias: info\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk project show NAME\n"
  printf "  monk project show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Project name\n"
    echo

  fi
}

# :command.usage
monk_project_use_usage() {
  printf "monk project use - Switch to project context\n\n"

  printf "%s\n" "Usage:"
  printf "  monk project use NAME\n"
  printf "  monk project use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Project name to switch to\n"
    echo

  fi
}

# :command.usage
monk_project_delete_usage() {
  printf "monk project delete - Delete project (soft delete by default)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk project delete NAME [OPTIONS]\n"
  printf "  monk project delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force"
    printf "    Skip confirmation\n"
    echo

    # :flag.usage
    printf "  %s\n" "--permanent"
    printf "    Permanent deletion (hard delete)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Project name to delete\n"
    echo

  fi
}

# :command.usage
monk_docs_usage() {
  printf "monk docs - View API documentation from remote server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk docs AREA\n"
  printf "  monk docs --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "AREA"
    printf "    Documentation area to view (e.g., auth, data, meta, find, bulk, file, acls,\n    root)\n"
    echo

  fi
}

# :command.usage
monk_root_usage() {
  printf "monk root - Administrative operations for tenant management (localhost development only)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root COMMAND\n"
  printf "  monk root [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Tenant management operations\n" "tenant"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_usage() {
  printf "monk root tenant - Tenant management operations\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root tenant COMMAND\n"
  printf "  monk root tenant [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all tenants\n" "list   "
  printf "  %s   Create new tenant\n" "create "
  printf "  %s   Show tenant details\n" "show   "
  printf "  %s   Soft delete tenant (set trashed_at)\n" "trash  "
  printf "  %s   Restore soft deleted tenant\n" "restore"
  printf "  %s   Hard delete tenant (permanent)\n" "delete "
  printf "  %s   Check tenant database health\n" "health "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_list_usage() {
  printf "monk root tenant list - List all tenants\n\n"
  printf "Alias: ls\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk root tenant list [OPTIONS]\n"
  printf "  monk root tenant list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--include-trashed"
    printf "    Include soft-deleted tenants\n"
    echo

    # :flag.usage
    printf "  %s\n" "--include-deleted"
    printf "    Include hard-deleted tenants\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_create_usage() {
  printf "monk root tenant create - Create new tenant\n\n"
  printf "Alias: add\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk root tenant create NAME [OPTIONS]\n"
  printf "  monk root tenant create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--host HOSTNAME"
    printf "    Database host (default: localhost)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force"
    printf "    Force creation even if exists\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_show_usage() {
  printf "monk root tenant show - Show tenant details\n\n"
  printf "Alias: info\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk root tenant show NAME\n"
  printf "  monk root tenant show --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_trash_usage() {
  printf "monk root tenant trash - Soft delete tenant (set trashed_at)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root tenant trash NAME\n"
  printf "  monk root tenant trash --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_restore_usage() {
  printf "monk root tenant restore - Restore soft deleted tenant\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root tenant restore NAME\n"
  printf "  monk root tenant restore --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_delete_usage() {
  printf "monk root tenant delete - Hard delete tenant (permanent)\n\n"
  printf "Alias: purge\n"
  echo

  printf "%s\n" "Usage:"
  printf "  monk root tenant delete NAME [OPTIONS]\n"
  printf "  monk root tenant delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--force"
    printf "    Skip confirmation\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.usage
monk_root_tenant_health_usage() {
  printf "monk root tenant health - Check tenant database health\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root tenant health NAME\n"
  printf "  monk root tenant health --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Tenant name\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/common.sh
#!/bin/bash

# Common functions for bashly CLI commands
# Clean rewrite to eliminate syntax errors and improve maintainability

# Clean separation of concerns:
# - server.json: Infrastructure endpoints

# - auth.json: Authentication sessions per server+tenant
# - env.json: Current working context (server+tenant selection)

# CLI configuration files

CLI_CONFIG_DIR="${MONK_CLI_CONFIG_DIR:-${HOME}/.config/monk/cli}"
SERVER_CONFIG="${CLI_CONFIG_DIR}/server.json"
TENANT_CONFIG="${CLI_CONFIG_DIR}/tenant.json"
AUTH_CONFIG="${CLI_CONFIG_DIR}/auth.json"
ENV_CONFIG="${CLI_CONFIG_DIR}/env.json"

# Legacy config file (for migration)
LEGACY_SERVERS_CONFIG="${HOME}/.config/monk/servers.json"

# Default configuration
DEFAULT_BASE_URL="http://localhost:3000"
DEFAULT_LIMIT=50
DEFAULT_FORMAT="raw"

# Colors for output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output - all go to stderr to avoid interfering with data pipes
print_error() {
    echo -e "${RED} $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN} $1${NC}" >&2
}

print_info() {
    # Only print if CLI_VERBOSE is true
    if [ "$CLI_VERBOSE" = "true" ]; then
        echo -e "${YELLOW} $1${NC}" >&2
    fi
}

print_info_always() {
    # Always print info messages (ignores CLI_VERBOSE)
    echo -e "${YELLOW} $1${NC}" >&2
}

print_warning() {
    echo -e "${YELLOW} $1${NC}" >&2
}

# Initialize CLI config directory and files
init_cli_configs() {
    # Ensure CLI config directory exists
    mkdir -p "$CLI_CONFIG_DIR"

    # Initialize individual config files
    init_server_config
    init_tenant_config
    init_auth_config

    init_env_config
}

# Initialize server config if it doesn't exist
init_server_config() {
    if [ ! -f "$SERVER_CONFIG" ]; then
        mkdir -p "$(dirname "$SERVER_CONFIG")"
        cat > "$SERVER_CONFIG" << 'EOF'
{
  "servers": {}
}
EOF
    fi
}

# Initialize tenant config if it doesn't exist
init_tenant_config() {
    if [ ! -f "$TENANT_CONFIG" ]; then
        mkdir -p "$(dirname "$TENANT_CONFIG")"
        cat > "$TENANT_CONFIG" << 'EOF'
{
  "tenants": {}
}
EOF
    fi
}

# Initialize auth config if it doesn't exist

init_auth_config() {
    if [ ! -f "$AUTH_CONFIG" ]; then
        mkdir -p "$(dirname "$AUTH_CONFIG")"
        cat > "$AUTH_CONFIG" << 'EOF'
{
  "sessions": {}
}
EOF
    fi
}

# Initialize env config if it doesn't exist
init_env_config() {
    if [ ! -f "$ENV_CONFIG" ]; then
        mkdir -p "$(dirname "$ENV_CONFIG")"
        cat > "$ENV_CONFIG" << 'EOF'
{
  "current_server": null,
  "current_tenant": null,
  "current_user": null,
  "recents": []
}
EOF
    fi
}

# Migrate from legacy servers.json to new CLI config structure
migrate_legacy_config() {
    # Only migrate if legacy file exists and new structure doesn't
    if [[ -f "$LEGACY_SERVERS_CONFIG" && ! -f "$SERVER_CONFIG" ]]; then
        print_info "Migrating legacy configuration to new CLI structure..."

        # Ensure new config directory exists
        mkdir -p "$CLI_CONFIG_DIR"

        # Extract server info and current server from legacy config
        local servers_data current_server
        servers_data=$(jq '.servers' "$LEGACY_SERVERS_CONFIG" 2>/dev/null)
        current_server=$(jq -r '.current_server // empty' "$LEGACY_SERVERS_CONFIG" 2>/dev/null)

        # Create new server.json (infrastructure only)
        echo "{\"servers\": $servers_data}" > "$SERVER_CONFIG"

        # Create env.json with current server selection
        cat > "$ENV_CONFIG" << EOF
{
  "current_server": "$current_server",
  "current_tenant": null,
  "current_user": null,
  "recents": []
}
EOF

        # Create empty auth.json (tokens will be re-established)
        cat > "$AUTH_CONFIG" << 'EOF'
{
  "sessions": {}
}
EOF

        print_success "Configuration migrated to ~/.config/monk/cli/"
        print_warning "JWT tokens were not migrated - please re-authenticate with 'monk auth login'"
    fi
}

# Get base URL from server config - fail if not configured
get_base_url() {
    migrate_legacy_config

    # Check if jq is available
    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for server configuration" >&2
        echo "Install jq to use server configuration" >&2
        exit 1
    fi

    # Check if config file exists
    if [[ ! -f "$SERVER_CONFIG" ]]; then
        echo "Error: No server configuration found" >&2
        echo "Use 'monk server add <name> <hostname:port>' to add a server" >&2
        exit 1
    fi

    # Get current server from env config
    init_env_config
    local current_server
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

    if [[ -z "$current_server" || "$current_server" == "null" ]]; then
        echo "Error: No current server selected" >&2
        echo "Use 'monk server use <name>' to select a server" >&2
        exit 1
    fi

    # Get server info from server config
    local server_info
    server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)

    if [[ "$server_info" == "null" ]]; then
        echo "Error: Current server '$current_server' not found in configuration" >&2
        echo "Use 'monk server list' to see available servers" >&2
        exit 1
    fi

    # Extract connection details
    local hostname=$(echo "$server_info" | jq -r '.hostname')
    local port=$(echo "$server_info" | jq -r '.port')
    local protocol=$(echo "$server_info" | jq -r '.protocol')

    # Validate required fields
    if [[ "$hostname" == "null" || "$port" == "null" || "$protocol" == "null" ]]; then
        echo "Error: Invalid server configuration for '$current_server'" >&2
        echo "Server configuration is missing required fields (hostname, port, protocol)" >&2
        exit 1
    fi

    echo "$protocol://$hostname:$port"
}

# Get stored JWT token for current server+tenant context
get_jwt_token() {
    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for JWT token management" >&2
        return 1
    fi

    # Get current context
    local current_server current_tenant
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        # No current server selected
        return 1
    fi

    if [ -z "$current_tenant" ] || [ "$current_tenant" = "null" ]; then
        # No current tenant selected
        return 1
    fi

    # Get session-specific token using server:tenant key
    local session_key="${current_server}:${current_tenant}"
    local token
    token=$(jq -r ".sessions.\"$session_key\".jwt_token // empty" "$AUTH_CONFIG" 2>/dev/null)

    if [ -n "$token" ] && [ "$token" != "null" ]; then
        echo "$token"
    else
        return 1
    fi
}

# Store JWT token for current server+tenant context
store_token() {
    local token="$1"
    local tenant="$2"
    local user="$3"

    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for JWT token management" >&2
        return 1
    fi

    # Get current server from env config
    local current_server
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        echo "Error: No current server selected. Use 'monk server use <name>' first" >&2
        return 1
    fi

    # Update env config with current tenant and user
    local temp_file=$(mktemp)
    jq --arg tenant "$tenant" \
       --arg user "$user" \
       '.current_tenant = $tenant | .current_user = $user' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

    # Store token in auth config using server:tenant key
    local session_key="${current_server}:${tenant}"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    temp_file=$(mktemp)
    jq --arg session_key "$session_key" \
       --arg token "$token" \
       --arg tenant "$tenant" \
       --arg user "$user" \
       --arg server "$current_server" \
       --arg timestamp "$timestamp" \
       '.sessions[$session_key] = {
           "jwt_token": $token,
           "tenant": $tenant,
           "user": $user,

           "server": $server,
           "created_at": $timestamp
       }' "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"

    # Set secure permissions on auth file
    chmod 600 "$AUTH_CONFIG"
}

# Remove stored JWT token for current server+tenant context
remove_stored_token() {
    init_cli_configs

    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for JWT token management" >&2
        return 1
    fi

    # Get current context
    local current_server current_tenant
    current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        echo "Error: No current server selected" >&2
        return 1
    fi

    if [ -z "$current_tenant" ] || [ "$current_tenant" = "null" ]; then
        # Clear all tenant info from env
        local temp_file=$(mktemp)
        jq '.current_tenant = null | .current_user = null' \
           "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
        return 0
    fi

    # Remove session from auth config
    local session_key="${current_server}:${current_tenant}"
    local temp_file=$(mktemp)
    jq --arg session_key "$session_key" \
       'del(.sessions[$session_key])' \
       "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"

    # Clear current tenant from env config
    temp_file=$(mktemp)
    jq '.current_tenant = null | .current_user = null' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
}

# Make HTTP request with JSON content-type - programmatic by default
make_request_json() {
    local method="$1"
    local url="$2"
    local data="$3"
    local base_url=$(get_base_url)
    local full_url="${base_url}${url}"

    print_info "Making $method request to: $full_url"

    local curl_args=(-s -X "$method" -H "Content-Type: application/json")

    # Add JWT token if available (unless it's an auth request)
    if [[ "$url" != "/auth/"* ]]; then
        local jwt_token
        jwt_token=$(get_jwt_token)
        if [ -n "$jwt_token" ]; then
            curl_args+=(-H "Authorization: Bearer $jwt_token")
            print_info "Using stored JWT token"
        fi
    fi

    if [ -n "$data" ]; then
        curl_args+=(-d "$data")
    fi

    local response
    local http_code

    # Make request and capture both response and HTTP status code
    response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Handle HTTP errors
    case "$http_code" in
        200|201)
            print_success "Success ($http_code)"
            # Return response without formatting - let caller handle it
            echo "$response"
            return 0
            ;;
        400|404|500)
            print_error "HTTP Error ($http_code)"
            echo "$response" >&2
            exit 1
            ;;
        *)
            print_error "HTTP $http_code"
            echo "$response" >&2
            exit 1
            ;;
    esac
}

# Handle response based on CLI flags - optimized for testing
handle_response_json() {
    local response="$1"
    local operation_type="$2"  # "list", "create", "select", etc.

    # Exit code only mode - no output, just exit status
    if [ "$CLI_EXIT_CODE_ONLY" = "true" ]; then
        if echo "$response" | grep -q '"success":true'; then
            exit 0
        else
            exit 1
        fi
    fi

    # Count mode for list operations
    if [ "$CLI_COUNT_MODE" = "true" ] && [ "$operation_type" = "list" ]; then
        if [ "$JSON_PARSER" = "jq" ]; then
            echo "$response" | jq '.data | length' 2>/dev/null || echo "0"
        elif [ "$JSON_PARSER" = "jshon" ]; then
            echo "$response" | jshon -e data -l 2>/dev/null || echo "0"
        else
            echo "$response"
        fi
        return
    fi

    # Field extraction mode
    if [ -n "$CLI_FORMAT" ]; then
        if [ "$JSON_PARSER" = "jq" ]; then
            # Handle both single objects and arrays
            if echo "$response" | jq -e '.data | type == "array"' >/dev/null 2>&1; then
                # Array case - extract field from each item
                echo "$response" | jq -r ".data[].${CLI_FORMAT}" 2>/dev/null || {
                    print_error "Failed to extract field: $CLI_FORMAT"
                    exit 1
                }
            else
                # Single object case - extract field directly
                echo "$response" | jq -r ".data.${CLI_FORMAT}" 2>/dev/null || {
                    print_error "Failed to extract field: $CLI_FORMAT"
                    exit 1
                }
            fi
        elif [ "$JSON_PARSER" = "jshon" ]; then
            echo "$response" | jshon -e data -e "$CLI_FORMAT" -u 2>/dev/null || {
                print_error "Failed to extract field: $CLI_FORMAT"
                exit 1
            }
        else
            print_error "jq or jshon required for field extraction"
            exit 1
        fi
        return
    fi

    # Default: auto-extract 'data' property and output as compact JSON
    if [ "$JSON_PARSER" = "jq" ]; then
        # Check if response has success:true and extract data
        if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
            if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
                # Success response - extract data as compact JSON
                echo "$response" | jq -c '.data'
            else
                # Error response - show full response for debugging as compact JSON
                echo "$response" | jq -c '.'
            fi
        else
            # Not a standard API response - show raw as compact JSON
            echo "$response" | jq -c '.'
        fi
    elif [ "$JSON_PARSER" = "jshon" ]; then
        # Check if response has success:true and extract data
        if echo "$response" | jshon -e success -u 2>/dev/null | grep -q "true"; then
            echo "$response" | jshon -e data 2>/dev/null || echo "$response"
        else
            echo "$response"
        fi
    else
        # No JSON parser - raw output
        echo "$response"
    fi
}

# Validate required arguments
require_args() {
    local required_count="$1"
    local actual_count="$2"
    local usage="$3"

    if [ "$actual_count" -lt "$required_count" ]; then
        print_error "Missing required arguments"
        print_info "Usage: $usage"
        exit 1
    fi
}

# Check dependencies - keep it simple
check_dependencies() {
    if ! command -v curl &> /dev/null; then
        print_error "curl is required but not installed."
        exit 1
    fi

    # Check for JSON parser for extraction operations (prefer jq over jshon)
    if command -v jq &> /dev/null; then
        export JSON_PARSER="jq"
    elif command -v jshon &> /dev/null; then
        export JSON_PARSER="jshon"
    else
        export JSON_PARSER="none"
    fi
}

# Legacy function - kept for compatibility
init_servers_config() {
    # Redirect to new CLI config initialization
    init_cli_configs
}

# Parse hostname:port into components
parse_endpoint() {
    local endpoint="$1"
    local hostname=""
    local port=""
    local protocol=""

    # Handle protocol prefixes
    if echo "$endpoint" | grep -q "^https://"; then
        protocol="https"
        endpoint=$(echo "$endpoint" | sed 's|^https://||')
    elif echo "$endpoint" | grep -q "^http://"; then
        protocol="http"
        endpoint=$(echo "$endpoint" | sed 's|^http://||')
    fi

    # Parse hostname:port
    if echo "$endpoint" | grep -q ":"; then
        hostname=$(echo "$endpoint" | cut -d':' -f1)
        port=$(echo "$endpoint" | cut -d':' -f2)
    else
        hostname="$endpoint"
        port="80"
    fi

    # Auto-detect protocol if not specified
    if [ -z "$protocol" ]; then
        if [ "$port" = "443" ]; then
            protocol="https"
        else
            protocol="http"
        fi
    fi

    echo "$protocol|$hostname|$port"
}

# Health check a server URL
ping_server_url() {
    local base_url="$1"
    local timeout="${2:-5}"

    # Try to ping the /ping endpoint with a short timeout
    if curl -s --max-time "$timeout" --fail "$base_url/ping" >/dev/null 2>&1; then
        return 0
    elif curl -s --max-time "$timeout" --fail "$base_url/" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Initialize tenant database schema
init_tenant_schema() {
    local tenant_name="$1"
    local db_user="${2:-$(whoami)}"

    # Find the schema file relative to the CLI root
    local schema_file=""

    # Try different possible locations for the schema file
    if [ -f "../sql/init-tenant.sql" ]; then
        schema_file="../sql/init-tenant.sql"
    elif [ -f "../../sql/init-tenant.sql" ]; then
        schema_file="../../sql/init-tenant.sql"
    elif [ -f "sql/init-tenant.sql" ]; then
        schema_file="sql/init-tenant.sql"
    else
        print_error "Schema file not found: init-tenant.sql"
        return 1
    fi

    print_info "Initializing tenant database schema..."
    if psql -U "$db_user" -d "$tenant_name" -f "$schema_file" >/dev/null 2>&1; then
        print_success "Tenant database schema initialized"
        return 0
    else
        print_error "Failed to initialize tenant database schema"
        return 1
    fi
}

# Make HTTP request with YAML content-type for meta API
make_request_yaml() {
    local method="$1"
    local url="$2"
    local data="$3"
    local base_url=$(get_base_url)
    local full_url="${base_url}${url}"

    print_info "Making $method request to: $full_url with YAML content-type"

    local curl_args=(-s -X "$method" -H "Content-Type: text/yaml")

    # Add JWT token if available (unless it's an auth request)
    if [[ "$url" != "/auth/"* ]]; then
        local jwt_token
        jwt_token=$(get_jwt_token)
        if [ -n "$jwt_token" ]; then
            curl_args+=(-H "Authorization: Bearer $jwt_token")
            print_info "Using stored JWT token"
        fi
    fi

    if [ -n "$data" ]; then
        curl_args+=(-d "$data")
    fi

    local response
    local http_code

    # Make request and capture both response and HTTP status code
    response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Handle HTTP errors
    case "$http_code" in
        200|201|204)
            print_success "Success ($http_code)"
            # Return response directly (YAML format)
            echo "$response"
            return 0
            ;;
        400|404|500)
            print_error "HTTP Error ($http_code)"
            echo "$response" >&2
            exit 1
            ;;
        *)
            print_error "HTTP $http_code"
            echo "$response" >&2
            exit 1
            ;;
    esac
}

# Handle YAML response - much simpler than JSON
handle_response_yaml() {
    local response="$1"
    local operation_type="$2"  # "create", "select", "update", "delete"

    # Exit code only mode - check if response is not empty for success
    if [ "$CLI_EXIT_CODE_ONLY" = "true" ]; then
        if [ -n "$response" ] || [ "$operation_type" = "delete" ]; then
            exit 0
        else
            exit 1
        fi
    fi

    # For YAML responses, just output directly
    echo "$response"
}

# Detect if input is array or object
detect_input_type() {
    local input="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        if echo "$input" | jq -e 'type == "array"' >/dev/null 2>&1; then
            echo "array"
        else
            echo "object"
        fi
    else
        # Fallback detection - check first non-whitespace character
        first_char=$(echo "$input" | sed 's/^[[:space:]]*//' | cut -c1)
        if [ "$first_char" = "[" ]; then
            echo "array"
        else
            echo "object"
        fi
    fi
}

# Extract ID from object
extract_id_from_object() {
    local input="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        echo "$input" | jq -r '.id // empty'
    elif [ "$JSON_PARSER" = "jshon" ]; then
        echo "$input" | jshon -e id -u 2>/dev/null || echo ""
    else
        # Fallback extraction
        echo "$input" | grep -o '"id"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | head -1
    fi
}

# Remove ID from object (for update operations)
remove_id_from_object() {
    local input="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        echo "$input" | jq 'del(.id)'
    elif [ "$JSON_PARSER" = "jshon" ]; then
        echo "$input" | jshon -d id 2>/dev/null || echo "$input"
    else
        # Fallback - remove id field (basic regex)
        echo "$input" | sed 's/"id"[[:space:]]*:[[:space:]]*"[^"]*"[[:space:]]*,\?//g' | sed 's/,[[:space:]]*}/}/g'
    fi
}

# Read and validate JSON input from stdin
read_and_validate_json_input() {
    local operation="$1"
    local schema="$2"

    # Read JSON data from stdin
    local json_data
    json_data=$(cat)

    if [ -z "$json_data" ]; then
        print_error "No JSON data provided on stdin"
        exit 1
    fi

    print_info "${operation^} $schema record(s) with data:"
    if [ "$CLI_VERBOSE" = "true" ]; then
        echo "$json_data" | sed 's/^/  /' >&2
    fi

    echo "$json_data"
}

# Process data operations with flexible input handling
process_data_operation() {
    local operation="$1"      # create/update/delete
    local http_method="$2"    # POST/PUT/DELETE
    local schema="$3"
    local id="$4"            # optional
    local json_data="$5"
    local confirmation="${6:-false}"  # require confirmation for destructive ops

    # Special case: DELETE with ID but no JSON data
    if [ "$operation" = "delete" ] && [ -n "$id" ] && [ -z "$json_data" ]; then
        if [ "$confirmation" = "true" ] && [ "$CLI_VERBOSE" = "true" ]; then
            print_warning "Are you sure you want to delete $schema record: $id? (y/N)"
            read -r user_confirmation

            if ! echo "$user_confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
                print_info "Operation cancelled"
                exit 0
            fi
        fi

        response=$(make_request_json "$http_method" "/api/data/$schema/$id" "")
        handle_response_json "$response" "$operation"
        return
    fi

    # All other cases require JSON data
    if [ -z "$json_data" ]; then
        print_error "No JSON data provided"
        exit 1
    fi

    # Detect input type and handle accordingly
    input_type=$(detect_input_type "$json_data")

    if [ -n "$id" ]; then
        # ID provided as parameter - use object endpoint
        print_info "Using provided ID: $id"

        # For object endpoint, remove ID from payload if present (API doesn't expect it)
        local clean_data
        if [ "$operation" = "update" ]; then
            clean_data=$(remove_id_from_object "$json_data")
        else
            clean_data="$json_data"
        fi

        response=$(make_request_json "$http_method" "/api/data/$schema/$id" "$clean_data")
        handle_response_json "$response" "$operation"

    elif [ "$input_type" = "array" ]; then
        # Array input  Bulk operation via array endpoint
        print_info "Processing array input for bulk $operation"
        response=$(make_request_json "$http_method" "/api/data/$schema" "$json_data")
        handle_response_json "$response" "$operation"

    elif [ "$operation" = "create" ]; then
        # CREATE: Object input  Array API  Object output (unwrap)
        print_info "Processing single object input"
        array_data="[$json_data]"
        response=$(make_request_json "$http_method" "/api/data/$schema" "$array_data")

        # Extract single object from array response to match input format
        if [ "$JSON_PARSER" = "jq" ]; then
            single_response=$(echo "$response" | jq '{"success": .success, "data": .data[0], "error": .error, "error_code": .error_code}' 2>/dev/null || echo "$response")
            handle_response_json "$single_response" "$operation"
        else
            handle_response_json "$response" "$operation"
        fi

    else
        # UPDATE/DELETE: Object input, no ID param  Extract ID from object, use object endpoint
        extracted_id=$(extract_id_from_object "$json_data")

        if [ -z "$extracted_id" ] || [ "$extracted_id" = "null" ]; then
            print_error "No ID provided as parameter and no 'id' field found in JSON object"
            print_info "Usage: monk data $operation $schema <id> OR provide JSON with 'id' field"
            exit 1
        fi

        print_info "Extracted ID from object: $extracted_id"

        # Confirmation for extracted ID delete operations
        if [ "$operation" = "delete" ] && [ "$confirmation" = "true" ] && [ "$CLI_VERBOSE" = "true" ]; then
            print_warning "Are you sure you want to delete $schema record: $extracted_id? (y/N)"
            read -r user_confirmation

            if ! echo "$user_confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
                print_info "Operation cancelled"
                exit 0
            fi
        fi

        # Remove ID from payload for object endpoint (UPDATE only)
        local clean_data
        if [ "$operation" = "update" ]; then
            clean_data=$(remove_id_from_object "$json_data")
        else
            clean_data=""  # DELETE doesn't need payload
        fi

        response=$(make_request_json "$http_method" "/api/data/$schema/$extracted_id" "$clean_data")
        handle_response_json "$response" "$operation"
    fi
}

# Check if JSON has complex where clause (indicating need for find command)
has_complex_query() {
    local json_data="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        # Check if 'where' field exists
        echo "$json_data" | jq -e '.where' >/dev/null 2>&1
    elif [ "$JSON_PARSER" = "jshon" ]; then
        echo "$json_data" | jshon -e where >/dev/null 2>&1
    else
        # Fallback: basic grep for "where" key
        echo "$json_data" | grep -q '"where"[[:space:]]*:'
    fi
}

# Build query string from JSON parameters (excluding 'where')
build_query_string() {
    local json_data="$1"
    local query_params=""

    if [ "$JSON_PARSER" = "jq" ]; then
        # Extract all keys except 'where' and build query string
        local keys
        keys=$(echo "$json_data" | jq -r 'del(.where) | to_entries[] | "\(.key)=\(.value)"' 2>/dev/null)

        if [ -n "$keys" ]; then
            # URL encode and join with &
            query_params=$(echo "$keys" | sed 's/ /+/g' | tr '\n' '&' | sed 's/&$//')
        fi
    elif [ "$JSON_PARSER" = "jshon" ]; then
        # Basic jshon parsing (limited functionality)
        local limit offset order
        limit=$(echo "$json_data" | jshon -e limit -u 2>/dev/null || echo "")
        offset=$(echo "$json_data" | jshon -e offset -u 2>/dev/null || echo "")
        order=$(echo "$json_data" | jshon -e order -u 2>/dev/null || echo "")

        local params=""
        [ -n "$limit" ] && params="${params}limit=${limit}&"
        [ -n "$offset" ] && params="${params}offset=${offset}&"
        [ -n "$order" ] && params="${params}order=$(echo "$order" | sed 's/ /+/g')&"

        query_params="${params%&}"  # Remove trailing &
    else
        # Fallback: basic regex extraction for common parameters
        local limit offset order
        limit=$(echo "$json_data" | grep -o '"limit"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*//')
        offset=$(echo "$json_data" | grep -o '"offset"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*//')
        order=$(echo "$json_data" | grep -o '"order"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*:[[:space:]]*"\([^"]*\)".*/\1/' | sed 's/ /+/g')

        local params=""
        [ -n "$limit" ] && params="${params}limit=${limit}&"
        [ -n "$offset" ] && params="${params}offset=${offset}&"
        [ -n "$order" ] && params="${params}order=${order}&"

        query_params="${params%&}"  # Remove trailing &
    fi

    if [ -n "$query_params" ]; then
        echo "?${query_params}"
    fi
}

# Redirect to find command with JSON input
redirect_to_find() {
    local schema="$1"
    local json_data="$2"

    print_info "Complex query detected, redirecting to 'monk find $schema'"

    # Execute find command with the JSON data
    echo "$json_data" | "${BASH_SOURCE[0]%/*}/find_command.sh" "$schema"
}

# Build file API request payload with path and options
build_file_payload() {
    local path="$1"
    local options="$2"

    if [ -n "$options" ]; then
        jq -n --arg path "$path" --argjson options "$options" \
           '{"path": $path, "file_options": $options}'
    else
        jq -n --arg path "$path" '{"path": $path}'
    fi
}

# Process file API response and extract specific field - UPDATED for new API format
process_file_response() {
    local response="$1"
    local extract_field="$2"  # "content", "data", "entries", etc. (optional)

    if [ "$JSON_PARSER" = "jq" ]; then
        if [ -n "$extract_field" ]; then
            # Handle nested data structure in new API format
            echo "$response" | jq ".data.$extract_field" 2>/dev/null
        else
            echo "$response"
        fi
    else
        print_error "jq required for file operations"
        exit 1
    fi
}

# Make file API request with standard error handling - UPDATED to use /api/file endpoints
make_file_request() {
    local endpoint="$1"    # list, retrieve, store, stat
    local payload="$2"

    local response
    response=$(make_request_json "POST" "/api/file/$endpoint" "$payload")

    # Check for file-specific error handling if needed
    echo "$response"
}

# Format ls-style output from FTP list entries - UPDATED for new API format
format_ls_output() {
    local entries="$1"
    local long_format="${2:-false}"

    if [ "$long_format" = "true" ]; then
        # Long format shows detailed information - use printf for formatting
        echo "$entries" | jq -r '.[] | "\(.file_permissions) \(.file_size | tostring) \(.file_modified) \(.name)"' | \
        while IFS=' ' read -r permissions size modified name; do
            printf "%-10s %8s %s %s\n" "$permissions" "$size" "$modified" "$name"
        done
    else
        # Simple format shows just names
        echo "$entries" | jq -r '.[] | .name'
    fi
}

# Parse tenant path and extract routing information
parse_tenant_path() {
    local path="$1"

    if [[ "$path" =~ ^/tenant/([^/]+)/(.*) ]]; then
        local tenant_spec="${BASH_REMATCH[1]}"
        local api_path="/${BASH_REMATCH[2]}"

        # Parse tenant specification (server:tenant or just tenant)
        if [[ "$tenant_spec" =~ ^([^:]+):(.+)$ ]]; then
            # Full server:tenant specification
            echo "server=${BASH_REMATCH[1]};tenant=${BASH_REMATCH[2]};path=$api_path;tenant_routing=true"
        else
            # Tenant only, use current server
            echo "server=current;tenant=$tenant_spec;path=$api_path;tenant_routing=true"
        fi
    else
        # Standard path, use current session
        echo "server=current;tenant=current;path=$path;tenant_routing=false"
    fi
}

# Get current session key (server:tenant)
current_session_key() {
    local current_server current_tenant
    current_server=$(jq -r '.current_server' "$ENV_CONFIG" 2>/dev/null)
    current_tenant=$(jq -r '.current_tenant' "$ENV_CONFIG" 2>/dev/null)

    if [ -n "$current_server" ] && [ "$current_server" != "null" ] &&

       [ -n "$current_tenant" ] && [ "$current_tenant" != "null" ]; then
        echo "${current_server}:${current_tenant}"
    else
        return 1
    fi
}

# Resolve session key from server and tenant specifications
resolve_session() {
    local server="$1"
    local tenant="$2"

    # Handle "current" values
    if [ "$server" = "current" ]; then
        server=$(jq -r '.current_server' "$ENV_CONFIG" 2>/dev/null)
    fi
    if [ "$tenant" = "current" ]; then
        tenant=$(jq -r '.current_tenant' "$ENV_CONFIG" 2>/dev/null)
    fi

    # Validate inputs
    if [ -z "$server" ] || [ "$server" = "null" ]; then
        print_error "No server specified and no current server selected"
        return 1
    fi
    if [ -z "$tenant" ] || [ "$tenant" = "null" ]; then
        print_error "No tenant specified and no current tenant selected"

        return 1
    fi

    # Build and validate session key
    local session_key="${server}:${tenant}"

    if jq -e ".sessions.\"$session_key\"" "$AUTH_CONFIG" >/dev/null 2>&1; then
        echo "$session_key"
    else
        print_error "No authentication found for $session_key"
        print_info_always "Use 'monk auth login $tenant <username>' on server '$server' to authenticate"
        return 1
    fi
}

# Temporarily switch context for single operation
with_tenant_context() {
    local target_session_key="$1"
    local operation_func="$2"
    shift 2
    local args=("$@")

    # Save current context
    local original_server original_tenant original_user
    original_server=$(jq -r '.current_server' "$ENV_CONFIG" 2>/dev/null)
    original_tenant=$(jq -r '.current_tenant' "$ENV_CONFIG" 2>/dev/null)

    original_user=$(jq -r '.current_user' "$ENV_CONFIG" 2>/dev/null)

    # Parse target session
    local target_server target_tenant
    target_server=$(echo "$target_session_key" | cut -d':' -f1)
    target_tenant=$(echo "$target_session_key" | cut -d':' -f2)

    # Get user from session
    local target_user
    target_user=$(jq -r ".sessions.\"$target_session_key\".user" "$AUTH_CONFIG" 2>/dev/null)

    print_info "Switching to context: $target_session_key (user: $target_user)"

    # Temporarily update env context
    local temp_file=$(mktemp)
    jq --arg server "$target_server" \
       --arg tenant "$target_tenant" \
       --arg user "$target_user" \
       '.current_server = $server | .current_tenant = $tenant | .current_user = $user' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

    # Execute operation with new context
    local result exit_code
    result=$("$operation_func" "${args[@]}")
    exit_code=$?

    # Restore original context

    temp_file=$(mktemp)
    jq --arg server "$original_server" \
       --arg tenant "$original_tenant" \
       --arg user "$original_user" \
       '.current_server = $server | .current_tenant = $tenant | .current_user = $user' \
       "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

    print_info "Restored context: $original_server:$original_tenant"

    echo "$result"
    return $exit_code
}

# Enhanced file API request with tenant routing support
make_file_request_with_routing() {
    local endpoint="$1"    # list, stat, retrieve, store
    local path="$2"
    local options="$3"
    local tenant_flag="$4" # Optional --tenant flag value

    local routing_info target_session_key api_path

    # Determine routing: flag takes precedence over path-based routing
    if [ -n "$tenant_flag" ]; then
        # Use --tenant flag specification
        if [[ "$tenant_flag" =~ ^([^:]+):(.+)$ ]]; then
            # Full server:tenant from flag
            target_session_key=$(resolve_session "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}")
        else
            # Tenant only from flag, use current server

            target_session_key=$(resolve_session "current" "$tenant_flag")
        fi
        api_path="$path"  # Use path as-is when flag provided

    else
        # Parse path for tenant routing
        routing_info=$(parse_tenant_path "$path")
        eval "$routing_info"  # Sets server, tenant, path, tenant_routing variables

        if [ "$tenant_routing" = "true" ]; then
            target_session_key=$(resolve_session "$server" "$tenant")
            api_path="$path"  # api_path from parsing
        else
            # Standard operation with current session
            target_session_key=$(current_session_key)
            api_path="$path"
        fi
    fi

    # Validate session exists
    if ! validate_session "$target_session_key"; then
        return 1
    fi

    # Build payload
    local payload
    payload=$(build_file_payload "$api_path" "$options")

    # Execute request with appropriate context
    local current_key
    current_key=$(current_session_key 2>/dev/null)

    if [ "$target_session_key" = "$current_key" ]; then
        # Same as current context - direct execution
        make_file_request "$endpoint" "$payload"
    else
        # Different context - use temporary switching
        with_tenant_context "$target_session_key" make_file_request "$endpoint" "$payload"
    fi
}

# Validate session exists and has valid authentication
validate_session() {
    local session_key="$1"

    if [ -z "$session_key" ]; then
        return 1
    fi

    local jwt_token
    jwt_token=$(jq -r ".sessions.\"$session_key\".jwt_token" "$AUTH_CONFIG" 2>/dev/null)

    if [ -n "$jwt_token" ] && [ "$jwt_token" != "null" ]; then
        return 0
    else
        return 1
    fi
}

# Validate schema exists (best effort)
validate_schema() {
    local schema="$1"

    # Don't validate if running in non-verbose mode for speed
    if [ "$CLI_VERBOSE" != "true" ]; then
        return 0
    fi

    # Try to get schema info - if it fails, just warn but continue
    local response
    if response=$(make_request_json "GET" "/api/meta/schema" "" 2>/dev/null); then
        if echo "$response" | grep -q "\"$schema\""; then
            print_info "Schema validated: $schema"
        else
            print_warning "Schema '$schema' not found in meta API, but continuing anyway"
        fi
    else
        print_info "Could not validate schema dynamically, assuming valid: $schema"
    fi
}

# URL encode a string for safe HTTP requests
url_encode() {
    local string="$1"
    # Use python for proper URL encoding if available, otherwise basic sed
    if command -v python3 >/dev/null 2>&1; then
        python3 -c "import urllib.parse; print(urllib.parse.quote('''$string''', safe=''))"
    else
        # Fallback: basic encoding for common characters
        printf '%s' "$string" | sed \
            -e 's/ /%20/g' \
            -e 's/!/%21/g' \
            -e 's/"/%22/g' \
            -e 's/#/%23/g' \
            -e 's/\$/%24/g' \
            -e 's/%/%25/g' \
            -e 's/&/%26/g' \
            -e "s/'/%27/g"
    fi
}

# Make HTTP request to root API (requires authentication and root privileges)
make_root_request() {
    local method="$1"
    local endpoint="$2"  # e.g., "tenant", "tenant/my_app"
    local data="$3"
    local base_url=$(get_base_url)

    # URL encode tenant names in endpoints for proper HTTP handling
    if [[ "$endpoint" == tenant/* ]]; then
        local tenant_path="${endpoint#tenant/}"
        # Split on additional path segments (e.g., tenant/name/health)
        if [[ "$tenant_path" == */* ]]; then
            local tenant_name="${tenant_path%%/*}"
            local remaining_path="${tenant_path#*/}"
            local encoded_name=$(url_encode "$tenant_name")
            endpoint="tenant/${encoded_name}/${remaining_path}"
        else
            local encoded_name=$(url_encode "$tenant_path")
            endpoint="tenant/${encoded_name}"
        fi
    fi

    local full_url="${base_url}/api/root/${endpoint}"

    print_info "Making $method request to: $full_url"

    local curl_args=(-s -X "$method")

    # Add JWT token if available
    local jwt_token
    jwt_token=$(get_jwt_token)
    if [ -n "$jwt_token" ]; then
        curl_args+=(-H "Authorization: Bearer $jwt_token")
        print_info "Using stored JWT token"
    fi

    # Add content-type header if data provided
    if [ -n "$data" ]; then
        curl_args+=(-H "Content-Type: application/json" -d "$data")
    fi

    local response
    local http_code

    # Make request and capture both response and HTTP status code
    response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Handle HTTP errors
    case "$http_code" in
        200|201|204)
            print_success "Success ($http_code)"
            echo "$response"
            return 0
            ;;
        400|404|500)
            print_error "HTTP Error ($http_code)"
            echo "$response" >&2
            exit 1
            ;;
        *)
            print_error "HTTP $http_code"
            echo "$response" >&2
            exit 1
            ;;
    esac
}

# Format tenant data for table output
format_tenant_table() {
    local tenants="$1"
    local include_trashed="$2"
    local include_deleted="$3"

    if [ "$JSON_PARSER" != "jq" ]; then
        print_error "jq required for tenant table formatting"
        exit 1
    fi

    local count
    count=$(echo "$tenants" | jq 'length')

    echo
    print_info "Total tenants: $count"
    echo

    if [[ "$count" -gt 0 ]]; then
        printf "%-20s %-10s %-20s %-20s %-20s\n" "NAME" "STATUS" "DATABASE" "HOST" "CREATED"
        echo "--------------------------------------------------------------------------------"

        echo "$tenants" | jq -r '.[] | [.name, .status, .database, .host, (.created_at | split("T")[0])] | @tsv' | \
        while IFS=$'\t' read -r name status database host created; do
            printf "%-20s %-10s %-20s %-20s %-20s\n" "$name" "$status" "$database" "$host" "$created"
        done
    else
        print_info "No tenants found"
    fi
    echo
}

# Confirm destructive operation with user input
confirm_destructive_operation() {
    local operation="$1"
    local target="$2"
    local force_flag="$3"
    local confirmation_word="${4:-y}"  # Default to 'y', or use custom word like 'DELETE'

    if [[ "$force_flag" == "1" ]]; then
        return 0  # Skip confirmation if --force used
    fi

    if [[ "$confirmation_word" == "y" ]]; then
        print_warning "Are you sure you want to $operation '$target'? (y/N)"
        read -r user_input

        if echo "$user_input" | grep -E "^[Yy]$" >/dev/null 2>&1; then
            return 0
        else
            print_info "Operation cancelled"
            exit 0
        fi
    else
        print_warning "DANGER: This will $operation '$target'!"
        print_warning "Type '$confirmation_word' to confirm:"
        read -r user_input

        if [[ "$user_input" == "$confirmation_word" ]]; then
            return 0
        else
            print_info "Operation cancelled"
            exit 0
        fi
    fi
}

# Determine output format from global flags
get_output_format() {
    local default_format="$1"  # "text" or "json"

    # Check global flags
    if [[ "${args[--text]}" == "1" ]]; then
        echo "text"
    elif [[ "${args[--json]}" == "1" ]]; then
        echo "json"
    else
        echo "$default_format"
    fi
}

# Validate format compatibility and show error if incompatible
validate_output_format() {
    local requested_format="$1"
    local supported_formats="$2"  # Space-separated list: "text json"

    if [[ "$supported_formats" == *"$requested_format"* ]]; then
        return 0
    else
        print_error "Output format '$requested_format' not supported for this command"
        print_info "Supported formats: $(echo "$supported_formats" | tr ' ' ', ')"
        exit 1
    fi
}

# Convert JSON to human-readable text format
json_to_text() {
    local json_data="$1"
    local context="$2"  # Context hint for formatting (e.g., "server_list", "tenant_status")

    if [ "$JSON_PARSER" != "jq" ]; then
        print_error "jq required for text formatting"
        echo "$json_data"
        return
    fi

    case "$context" in
        "server_list")
            echo
            printf "%-15s %-30s %-8s %-8s %-12s %-20s %s\n" "Name" "Endpoint" "Status" "Auth" "Last Ping" "Added" "Description"
            echo "--------------------------------------------------------------------------------------------"
            echo "$json_data" | jq -r '.servers[]? | [.name, .endpoint, .status, (if .auth_sessions > 0 then "yes (\(.auth_sessions))" else "no" end), (.last_ping | split("T")[0]), (.added_at | split("T")[0]), .description] | @tsv' | \
            while IFS=$'\t' read -r name endpoint status auth last_ping added desc; do
                current_marker=""
                if echo "$json_data" | jq -e ".current_server == \"$name\"" >/dev/null 2>&1; then
                    current_marker=" *"
                fi
                printf "%-15s %-30s %-8s %-8s %-12s %-20s %s%s\n" "$name" "$endpoint" "$status" "$auth" "$last_ping" "$added" "$desc" "$current_marker"
            done
            echo
            ;;
        "tenant_list")
            echo
            printf "%-20s %-30s %-8s %-20s %s\n" "Name" "Display Name" "Auth" "Added" "Description"
            echo "-------------------------------------------------------------------------------------"
            echo "$json_data" | jq -r '.tenants[]? | [.name, .display_name, (if .authenticated then "yes" else "no" end), (.added_at | split("T")[0]), .description] | @tsv' | \
            while IFS=$'\t' read -r name display_name auth added desc; do
                current_marker=""
                if echo "$json_data" | jq -e ".current_tenant == \"$name\"" >/dev/null 2>&1; then
                    current_marker=" *"
                fi
                printf "%-20s %-30s %-8s %-20s %s%s\n" "$name" "$display_name" "$auth" "$added" "$desc" "$current_marker"
            done
            echo
            ;;
        "auth_status")
            if echo "$json_data" | jq -e '.authenticated' >/dev/null 2>&1; then
                local tenant=$(echo "$json_data" | jq -r '.current_context.tenant')
                local server=$(echo "$json_data" | jq -r '.current_context.server')
                local user=$(echo "$json_data" | jq -r '.current_context.user')
                local database=$(echo "$json_data" | jq -r '.token_info.database')
                local exp_date=$(echo "$json_data" | jq -r '.token_info.exp_date')

                echo "Tenant: $tenant"
                echo "Database: $database"
                echo "Expires: $exp_date"
                echo "Server: $server"
                echo "Tenant: $tenant"
                echo "User: $user"
                print_success "Authenticated"
            else
                print_error "Not authenticated"
            fi
            ;;
        "data_table")
            # Generic data table - try to format as table if array
            if echo "$json_data" | jq -e 'type == "array"' >/dev/null 2>&1; then
                if echo "$json_data" | jq -e 'length > 0' >/dev/null 2>&1; then
                    # Get column headers from first object
                    local headers=$(echo "$json_data" | jq -r '.[0] | keys_unsorted | @tsv')
                    echo "$headers" | tr '\t' '\n' | nl -w3 -s') ' -v0
                    echo "---"
                    echo "$json_data" | jq -r '.[] | [.[] | tostring] | @tsv'
                else
                    echo "No data found"
                fi
            else
                echo "$json_data" | jq '.'
            fi
            ;;
        *)
            # Default: output compact JSON for machine readability
            echo "$json_data" | jq -c '.'
            ;;
    esac
}

# Convert JSON to YAML format
json_to_yaml() {
    local json_data="$1"

    if [ "$JSON_PARSER" = "jq" ]; then
        # Use yq if available, otherwise fallback to compact JSON with warning
        if command -v yq >/dev/null 2>&1; then
            echo "$json_data" | yq -P '.'
        else
            print_warning "yq not available - outputting compact JSON instead of YAML" >&2
            echo "$json_data" | jq -c '.'
        fi
    else
        print_error "jq required for YAML conversion"
        echo "$json_data"
    fi
}

# Convert YAML to JSON format
yaml_to_json() {
    local yaml_data="$1"

    if command -v yq >/dev/null 2>&1; then
        echo "$yaml_data" | yq -o=json '.'
    else
        print_error "yq required for YAML to JSON conversion"
        echo "$yaml_data"
    fi
}

# Detect input format based on first non-whitespace character
detect_input_format() {
    local input_data="$1"

    # Get first non-whitespace character
    local first_char=$(echo "$input_data" | sed 's/^[[:space:]]*//' | cut -c1)

    if [[ "$first_char" == "{" || "$first_char" == "[" ]]; then
        echo "json"
    else
        echo "yaml"
    fi
}

# Convert JSON to YAML with graceful fallback
convert_json_to_yaml() {
    local json_data="$1"

    # Try yq first (best option)
    if command -v yq >/dev/null 2>&1; then
        echo "$json_data" | yq -P '.'
        return $?
    fi

    # Try python fallback
    if command -v python3 >/dev/null 2>&1; then
        if echo "$json_data" | python3 -c "import yaml,json,sys; print(yaml.dump(json.load(sys.stdin), default_flow_style=False).rstrip())" 2>/dev/null; then
            return 0
        fi
    fi

    # Try ruby fallback

    if command -v ruby >/dev/null 2>&1; then
        if echo "$json_data" | ruby -e "require 'yaml','json'; puts YAML.dump(JSON.parse(STDIN.read))" 2>/dev/null; then
            return 0
        fi
    fi

    return 1
}

# Convert YAML to JSON with graceful fallback
convert_yaml_to_json() {
    local yaml_data="$1"

    # Try yq first (best option)
    if command -v yq >/dev/null 2>&1; then
        echo "$yaml_data" | yq -o=json '.'
        return $?
    fi

    # Try python fallback
    if command -v python3 >/dev/null 2>&1; then
        if echo "$yaml_data" | python3 -c "import yaml,json,sys; print(json.dumps(yaml.safe_load(sys.stdin), separators=(',', ':')))" 2>/dev/null; then
            return 0
        fi
    fi

    # Try ruby fallback
    if command -v ruby >/dev/null 2>&1; then
        if echo "$yaml_data" | ruby -e "require 'yaml','json'; puts JSON.generate(YAML.load(STDIN.read))" 2>/dev/null; then
            return 0
        fi
    fi

    return 1
}

# Make HTTP request with YAML content-type and JSON/YAML autodetect
make_request_yaml_autodetect() {
    local method="$1"
    local url="$2"
    local input_data="$3"
    local input_format="$4"

    local yaml_data="$input_data"

    # Convert JSON to YAML if needed
    if [[ "$input_format" == "json" ]]; then
        print_info "Converting JSON input to YAML for API"

        yaml_data=$(convert_json_to_yaml "$input_data")
        if [[ $? -ne 0 ]]; then
            print_error "Failed to convert JSON input to YAML"
            print_info "JSON input detected but no suitable conversion tool available"
            print_info "Please install 'yq' or provide input in YAML format instead"
            print_info "Example: cat schema.yaml | monk describe select"
            exit 1
        fi
    fi

    # Make standard YAML request
    make_request_yaml "$method" "$url" "$yaml_data"
}

# Handle YAML response with JSON/YAML autodetect conversion
handle_response_yaml_autodetect() {
    local response="$1"
    local operation_type="$2"
    local original_input_format="$3"

    # Convert YAML response to JSON if original input was JSON
    if [[ "$original_input_format" == "json" && -n "$response" ]]; then
        print_info "Converting YAML response to JSON for format consistency"

        local json_response
        json_response=$(convert_yaml_to_json "$response")
        if [[ $? -eq 0 ]]; then
            # Output the JSON response (compact format)
            echo "$json_response" | jq -c '.' 2>/dev/null || echo "$json_response"
            return
        else
            print_warning "Failed to convert YAML response to JSON, outputting original YAML"
        fi
    fi

    # Default: handle as standard YAML response
    handle_response_yaml "$response" "$operation_type"
}

# Universal output handler - handles text and JSON formats
handle_output() {
    local data="$1"
    local requested_format="$2"
    local default_format="$3"
    local context="${4:-default}"
    local supported_formats="${5:-text json}"

    # Validate format is supported
    validate_output_format "$requested_format" "$supported_formats"

    # Handle JSON format - always compress to single line for machine readability
    if [[ "$requested_format" == "json" ]]; then
        if [[ "$default_format" == "json" ]]; then
            # Already JSON - compress it
            echo "$data" | jq -c '.'
        else
            print_error "Cannot convert text output to structured format"
            print_info "Text format is human-readable only"
            exit 1
        fi
        return
    fi

    # Handle text format
    if [[ "$requested_format" == "text" ]]; then
        if [[ "$default_format" == "text" ]]; then
            # Already text - output directly
            echo "$data"
        elif [[ "$default_format" == "json" ]]; then
            # Convert JSON to text
            json_to_text "$data" "$context"
        else
            print_error "Unsupported format conversion: $default_format to $requested_format"
            echo "$data"
        fi
        return
    fi

    # Fallback: output data as-is
    echo "$data"
}

# :command.command_functions
# :command.function
monk_init_command() {

  # src/commands/init.sh
  #!/bin/bash

  # init_command.sh - Initialize CLI configuration directory with complete structure
  #
  # This command creates the CLI configuration directory and initializes all config files
  # for clean domain separation following the new architecture.
  #
  # Creates:
  #   ~/.config/monk/cli/server.json  - Server endpoint registry
  #   ~/.config/monk/cli/tenant.json  - Tenant registry (server-scoped)
  #   ~/.config/monk/cli/auth.json    - Authentication sessions (per server+tenant)
  #   ~/.config/monk/cli/env.json     - Current working context (server+tenant+user)

  # Get arguments from bashly
  path="${args[path]}"
  force_flag="${args[--force]}"

  # Set configuration path (respects MONK_CLI_CONFIG_DIR environment variable)
  if [[ -n "$path" ]]; then
      cli_config_dir="$path"
  else
      cli_config_dir="${MONK_CLI_CONFIG_DIR:-${HOME}/.config/monk/cli}"
  fi

  # Colors for output
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  RED='\033[0;31m'
  NC='\033[0m' # No Color

  echo -e "${BLUE}Initializing Monk CLI configuration...${NC}"
  echo "Configuration path: ${cli_config_dir}"

  # Create CLI directory if it doesn't exist
  if [[ ! -d "$cli_config_dir" ]]; then
      echo -e "${YELLOW}${NC} Creating CLI directory: ${cli_config_dir}"
      mkdir -p "$cli_config_dir"
  else
      echo -e "${GREEN}${NC} CLI directory exists: ${cli_config_dir}"
  fi

  # Initialize server.json
  server_file="${cli_config_dir}/server.json"
  if [[ ! -f "$server_file" ]] || [[ "$force_flag" = "1" ]]; then
      if [[ -f "$server_file" ]] && [[ "$force_flag" = "1" ]]; then
          echo -e "${YELLOW}${NC} Force overwriting server.json"
      else
          echo -e "${YELLOW}${NC} Creating server.json"
      fi
      cat > "$server_file" << 'EOF'
{
  "servers": {}
}
EOF
      echo -e "${GREEN}${NC} Created server.json"
  else
      echo -e "${GREEN}${NC} server.json already exists"
  fi

  # Initialize tenant.json
  tenant_file="${cli_config_dir}/tenant.json"
  if [[ ! -f "$tenant_file" ]] || [[ "$force_flag" = "1" ]]; then
      if [[ -f "$tenant_file" ]] && [[ "$force_flag" = "1" ]]; then
          echo -e "${YELLOW}${NC} Force overwriting tenant.json"
      else
          echo -e "${YELLOW}${NC} Creating tenant.json"
      fi
      cat > "$tenant_file" << 'EOF'
{
  "tenants": {}
}
EOF
      echo -e "${GREEN}${NC} Created tenant.json"
  else
      echo -e "${GREEN}${NC} tenant.json already exists"
  fi

  # Initialize auth.json
  auth_file="${cli_config_dir}/auth.json"
  if [[ ! -f "$auth_file" ]] || [[ "$force_flag" = "1" ]]; then
      if [[ -f "$auth_file" ]] && [[ "$force_flag" = "1" ]]; then
          echo -e "${YELLOW}${NC} Force overwriting auth.json"
      else
          echo -e "${YELLOW}${NC} Creating auth.json"
      fi
      cat > "$auth_file" << 'EOF'
{
  "sessions": {}
}
EOF
      chmod 600 "$auth_file"
      echo -e "${GREEN}${NC} Created auth.json (secure permissions)"
  else
      echo -e "${GREEN}${NC} auth.json already exists"
  fi

  # Initialize env.json (never force overwrite - preserve user context)
  env_file="${cli_config_dir}/env.json"
  if [[ ! -f "$env_file" ]]; then
      echo -e "${YELLOW}${NC} Creating env.json"
      cat > "$env_file" << 'EOF'
{
  "current_server": null,
  "current_tenant": null,
  "current_user": null,
  "recents": []
}
EOF
      echo -e "${GREEN}${NC} Created env.json"
  else
      echo -e "${GREEN}${NC} env.json already exists (preserved)"
      if [[ "$force_flag" = "1" ]]; then
          echo -e "${BLUE}${NC} env.json is never overwritten to preserve your context"
      fi
  fi

  echo -e "${GREEN}${NC} Monk CLI configuration initialized successfully!"
  echo
  echo "CLI configuration files created in: ${cli_config_dir}"
  echo "  - server.json: Server endpoint registry"
  echo "  - tenant.json: Tenant registry (server-scoped)"
  echo "  - auth.json: Authentication sessions per server+tenant"

  echo "  - env.json: Current working context (server+tenant+user)"
  echo
  echo "Next steps:"
  echo "  1. Add a server: monk server add <name> <hostname:port>"
  echo "  2. Add a tenant: monk tenant add <name> <display_name>"
  echo "  3. Select server: monk server use <name>"
  echo "  4. Select tenant: monk tenant use <name>"
  echo "  5. Authenticate: monk auth login <tenant> <username>"
  echo "  6. Start working: monk data select <schema>"
}

# :command.function
monk_examples_command() {

  # src/commands/examples.sh
  #!/bin/bash

  # examples_command.sh - Browse and display usage examples from GitHub

  # Check dependencies
  check_dependencies

  init_cli_configs

  # Get current CLI version
  get_current_version() {
      monk --version | grep -oE '[0-9]+\.[0-9]+\.[0-9]+'
  }

  # Get examples for current version (local first, then GitHub)
  get_examples_for_version() {
      local version=$(get_current_version)

      # First try local examples directory
      if [[ -d "examples" ]]; then
          ls -1 examples/*.md 2>/dev/null | while read -r file; do
              local name=$(basename "$file" .md)
              local url="file://$PWD/$file"
              echo "${name}|${url}"
          done
          return
      fi

      # Fall back to GitHub API
      local tag="v${version}"
      local repo="ianzepp/monk-cli"  # Discovered via git remote

      # GitHub API: Get directory contents for specific tag
      local api_url="https://api.github.com/repos/${repo}/contents/examples?ref=${tag}"

      curl -s "$api_url" | jq -r '.[] | select(.type == "file") | "\(.name)|\(.download_url)"' 2>/dev/null || echo ""
  }

  # List all available examples
  list_examples() {
      local examples=$(get_examples_for_version)

      if [[ -z "$examples" ]]; then
          print_error "No examples found for version $(get_current_version)"
          print_info "This might be an older version without examples"
          return 1
      fi

      echo "Available examples for monk $(get_current_version):"
      echo

      echo "$examples" | while IFS='|' read -r name url; do
          # Extract title from first line of markdown
          local title=$(curl -s "$url" | head -5 | grep '^# ' | sed 's/^# //' | head -1)
          if [[ -z "$title" ]]; then
              title="No title available"
          fi
          echo "  ${name%.md} - $title"
      done

      echo
      echo "Use 'monk examples show <name>' to view an example"
  }

  # Show specific example
  show_example() {
      local example_name="$1"
      local version=$(get_current_version)

      # First try local file
      local local_file="examples/${example_name}.md"
      if [[ -f "$local_file" ]]; then
          cat "$local_file"
          return
      fi

      # Fall back to GitHub
      local tag="v${version}"
      local repo="ianzepp/monk-cli"  # Discovered via git remote

      # Direct raw URL for the file
      local raw_url="https://raw.githubusercontent.com/${repo}/${tag}/examples/${example_name}.md"

      local content=$(curl -s "$raw_url")

      if [[ -z "$content" ]] || echo "$content" | grep -q "404: Not Found"; then
          print_error "Example '${example_name}' not found for version ${version}"
          print_info "Try 'monk examples list' to see available examples"
          return 1
      fi

      echo "$content"
  }

  # Main command logic
  if [[ "${args[name]}" == "list" ]] || [[ -z "${args[name]}" ]]; then
      list_examples
  else
      show_example "${args[name]}"
  fi
}

# :command.function
monk_status_command() {

  # src/commands/status.sh
  #!/bin/bash

  # status_command.sh - Show comprehensive CLI status and environment overview

  # Check dependencies
  check_dependencies

  init_cli_configs

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Get current context information
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  current_user=$(jq -r '.current_user // empty' "$ENV_CONFIG" 2>/dev/null)

  # Get server details if one is selected
  server_info=""
  server_status="No server selected"
  server_endpoint=""
  server_health=""

  if [[ -n "$current_server" ]]; then
      server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)
      if [[ -n "$server_info" ]]; then
          hostname=$(echo "$server_info" | jq -r '.hostname')
          port=$(echo "$server_info" | jq -r '.port')
          protocol=$(echo "$server_info" | jq -r '.protocol')
          server_endpoint="$protocol://$hostname:$port"

          # Check server health using /health endpoint (same as server health command)
          if curl -s --max-time 5 --fail "$server_endpoint/health" >/dev/null 2>&1; then
              server_status="Up"
              server_health=" Healthy"
          else
              server_status="Down"
              server_health=" Unreachable"
          fi
      else
          server_status="Server config missing"
      fi
  fi

  # Get authentication status
  auth_status="Not authenticated"
  user_details=""
  access_level=""

  if [[ -n "$current_server" && -n "$current_tenant" ]]; then
      # Check if we have a valid token for this server/tenant combination
      # (store_token uses server:tenant format)
      session_key="${current_server}:${current_tenant}"
      session_info=$(jq -r ".sessions.\"$session_key\"" "$AUTH_CONFIG" 2>/dev/null)

      if [[ -n "$session_info" && "$session_info" != "null" ]]; then
          token=$(echo "$session_info" | jq -r '.jwt_token // empty')

          if [[ -n "$token" ]]; then
              # Check if token is expired (same logic as auth_expired_command.sh)
              # Extract payload (second part) from JWT
              payload=$(echo "$token" | cut -d'.' -f2)

              # Add padding if needed for base64 decoding
              padding=$((4 - ${#payload} % 4))
              if [ $padding -ne 4 ]; then
                  payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
              fi

              # Decode base64 payload
              if decoded=$(echo "$payload" | base64 -d 2>/dev/null); then
                  if exp_timestamp=$(echo "$decoded" | jq -r '.exp // empty' 2>/dev/null); then
                      if [ -n "$exp_timestamp" ] && [ "$exp_timestamp" != "null" ] && [ "$exp_timestamp" != "empty" ]; then
                          current_timestamp=$(date +%s)

                          if [ "$exp_timestamp" -gt "$current_timestamp" ]; then
                              # Token is still valid
                              auth_status="Authenticated"
                              user_details="$current_user@$current_tenant"

                              # Try to get user role/access level from token
                              if command -v jq >/dev/null 2>&1; then
                                  role=$(echo "$decoded" | jq -r '.access // empty' 2>/dev/null)
                                  if [[ -n "$role" && "$role" != "null" ]]; then
                                      access_level="$role"
                                  fi
                              fi
                          else
                              # Token is expired
                              auth_status="Token expired"
                          fi
                      else
                          # No expiration found - assume expired for safety
                          auth_status="Token expired"
                      fi
                  else
                      # Failed to parse JSON - assume expired for safety
                      auth_status="Token expired"
                  fi
              else
                  # Failed to decode - assume expired for safety
                  auth_status="Token expired"
              fi
          fi
      fi
  fi

  # Get schemas if server is up and we're authenticated
  schemas=""
  schema_count=0

  if [[ "$server_status" == "Up" && "$auth_status" == "Authenticated" ]]; then
      # Try to get schemas from the API using GET /api/describe
      api_response=$(make_request_json "GET" "/api/describe" "")
      if [[ $? -eq 0 ]]; then
          # Extract the data array which contains schema names
          schemas=$(echo "$api_response" | jq -r '.data[]' 2>/dev/null | sort)
          if [[ -n "$schemas" ]]; then
              schema_count=$(echo "$schemas" | grep -c '^' | tr -d ' ')
          else
              schema_count=0
              schemas="No schemas found"
          fi
      else
          schemas="Unable to fetch schemas"
      fi
  fi

  # Build the status information
  if [[ "$output_format" == "text" ]]; then
      echo
      echo "Monk CLI Status"
      echo "==============="
      echo

      # Server Information
      echo "Server:"
      if [[ -n "$current_server" ]]; then
          echo "  Name: $current_server"
          echo "  Endpoint: ${server_endpoint:-Unknown}"
          echo "  Status: $server_status ${server_health:+($server_health)}"
      else
          echo "  No server selected (use 'monk server use <name>')"
      fi
      echo

      # Tenant Information
      echo "Tenant:"
      if [[ -n "$current_tenant" ]]; then
          echo "  Name: $current_tenant"
      else
          echo "  No tenant selected (use 'monk tenant use <name>')"
      fi
      echo

      # User Information
      echo "Authentication:"
      echo "  Status: $auth_status"
      if [[ -n "$user_details" ]]; then
          echo "  User: $user_details"
          if [[ -n "$access_level" ]]; then
              echo "  Access Level: $access_level"
          fi
      fi
      echo

      # Schemas Information
      if [[ "$server_status" == "Up" && "$auth_status" == "Authenticated" ]]; then
          echo "Available Schemas ($schema_count):"
          if [[ "$schemas" == "No schemas found" || "$schemas" == "Unable to fetch schemas" ]]; then
              echo "  $schemas"
          else
              echo "$schemas" | while read -r schema; do
                  if [[ -n "$schema" ]]; then
                      echo "   $schema"
                  fi
              done
          fi
      else
          echo "Schemas: Not available (server down or not authenticated)"
      fi

  else
      # JSON output
      status_json=$(jq -n \
          --arg server_name "$current_server" \
          --arg server_endpoint "$server_endpoint" \
          --arg server_status "$server_status" \
          --arg server_health "$server_health" \
          --arg tenant "$current_tenant" \
          --arg auth_status "$auth_status" \
          --arg user_details "$user_details" \
          --arg access_level "$access_level" \
          --arg schemas "$schemas" \
          --arg schema_count "$schema_count" \
          '{
              server: {
                  name: $server_name,
                  endpoint: $server_endpoint,
                  status: $server_status,
                  health: $server_health
              },
              tenant: $tenant,
              authentication: {
                  status: $auth_status,
                  user: $user_details,
                  access_level: $access_level
              },
              schemas: {
                  count: ($schema_count | tonumber),
                  available: ($schemas | split("\n") | map(select(. != "")))
              }
          }')

      handle_output "$status_json" "$output_format" "json" "status"
  fi
}

# :command.function
monk_server_add_command() {

  # src/commands/server/add.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"
  endpoint="${args[endpoint]}"
  description="${args[--description]}"

  init_cli_configs

  # Parse endpoint
  parsed=$(parse_endpoint "$endpoint")
  protocol=$(echo "$parsed" | cut -d'|' -f1)
  hostname=$(echo "$parsed" | cut -d'|' -f2)
  port=$(echo "$parsed" | cut -d'|' -f3)

  print_info "Adding server: $name"
  print_info "Endpoint: $protocol://$hostname:$port"
  if [ -n "$description" ]; then
      print_info "Description: $description"
  fi

  # Check if server already exists
  if command -v jq >/dev/null 2>&1; then
      if jq -e ".servers.\"$name\"" "$SERVER_CONFIG" >/dev/null 2>&1; then
          print_error "Server '$name' already exists"
          print_info "Use 'monk server delete $name' first, or choose a different name"
          exit 1
      fi
  fi

  # Test connectivity
  print_info "Testing connectivity to $protocol://$hostname:$port"
  base_url="$protocol://$hostname:$port"

  if ping_server_url "$base_url"; then
      print_success "Server is reachable"
      status="up"
  else
      print_info "Server appears to be down (this is OK, adding anyway)"
      status="down"
  fi

  # Add server to config
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  if command -v jq >/dev/null 2>&1; then
      # Use jq for JSON manipulation
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg hostname "$hostname" \
         --arg port "$port" \
         --arg protocol "$protocol" \
         --arg description "$description" \
         --arg timestamp "$timestamp" \
         --arg status "$status" \
         '.servers[$name] = {
             "hostname": $hostname,
             "port": ($port | tonumber),
             "protocol": $protocol,
             "description": $description,
             "added_at": $timestamp,
             "last_ping": $timestamp,
             "status": $status
         }' "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

      print_success "Server '$name' added successfully"

      # If this is the first server, make it current in env config
      server_count=$(jq '.servers | length' "$SERVER_CONFIG")
      if [ "$server_count" -eq 1 ]; then
          temp_file=$(mktemp)
          jq --arg name "$name" '.current_server = $name' "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
          print_info "Set as current server (first server added)"
      fi
  else
      print_error "jq is required for server management"
      print_info "Please install jq: brew install jq (macOS) or apt-get install jq (Linux)"
      exit 1
  fi
}

# :command.function
monk_server_list_command() {

  # src/commands/server/list.sh
  #!/bin/bash

  # server_list_command.sh - List all servers with universal output format support

  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  server_names=$(jq -r '.servers | keys[]' "$SERVER_CONFIG" 2>/dev/null)

  if [ -z "$server_names" ]; then
      # No servers - handle based on output format
      empty_result='{"servers": [], "current_server": null}'

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Registered Servers"
          echo
          print_info "No servers configured"
          print_info "Use 'monk server add <name> <hostname:port>' to add servers"
      else
          handle_output "$empty_result" "$output_format" "json" "server_list"
      fi
      exit 0
  fi

  # Build JSON data internally (always generate JSON first)
  servers_json=$(echo "$server_names" | while read -r name; do
      if [ -n "$name" ]; then
          server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG")

          hostname=$(echo "$server_info" | jq -r '.hostname')
          port=$(echo "$server_info" | jq -r '.port')
          protocol=$(echo "$server_info" | jq -r '.protocol')
          status=$(echo "$server_info" | jq -r '.status // "unknown"')
          last_ping=$(echo "$server_info" | jq -r '.last_ping // "never"')
          added_at=$(echo "$server_info" | jq -r '.added_at // "unknown"')
          description=$(echo "$server_info" | jq -r '.description // ""')

          endpoint="$protocol://$hostname:$port"

          # Check authentication count
          auth_count=$(jq --arg server "$name" '[.sessions | to_entries[] | select(.key | startswith($server + ":"))] | length' "$AUTH_CONFIG" 2>/dev/null || echo "0")
          is_current=$([ "$name" = "$current_server" ] && echo "true" || echo "false")

          # Create JSON object for this server
          jq -n \
              --arg name "$name" \
              --arg hostname "$hostname" \
              --argjson port "$port" \
              --arg protocol "$protocol" \
              --arg endpoint "$endpoint" \
              --arg status "$status" \
              --arg last_ping "$last_ping" \
              --arg added_at "$added_at" \
              --arg description "$description" \
              --argjson auth_sessions "$auth_count" \
              --argjson is_current "$is_current" \
              '{
                  name: $name,
                  hostname: $hostname,
                  port: $port,
                  protocol: $protocol,
                  endpoint: $endpoint,
                  status: $status,
                  last_ping: $last_ping,
                  added_at: $added_at,
                  description: $description,
                  auth_sessions: $auth_sessions,
                  is_current: $is_current
              }'
      fi
  done | jq -s --arg current_server "$current_server" \
      '{servers: ., current_server: ($current_server | if . == "" then null else . end)}')

  # Output in requested format
  if [[ "$output_format" == "text" ]]; then
      echo
      print_info "Registered Servers"
      echo

      # Build markdown table
      markdown_output=""
      markdown_output+="| NAME | ENDPOINT | STATUS | AUTH SESSIONS | ADDED | CURRENT |\n"
      markdown_output+="|------|----------|--------|---------------|-------|---------|"

      # Add data rows using process substitution to avoid subshell issues
      while IFS= read -r row; do
          if [ -n "$row" ]; then
              # Decode the row and extract fields
              decoded=$(echo "$row" | base64 -d)
              name=$(echo "$decoded" | jq -r '.name')
              endpoint=$(echo "$decoded" | jq -r '.endpoint')
              status=$(echo "$decoded" | jq -r '.status')
              auth_sessions=$(echo "$decoded" | jq -r '.auth_sessions')
              added=$(echo "$decoded" | jq -r '.added_at' | cut -d'T' -f1)
              current=$(echo "$decoded" | jq -r 'if .is_current then "*" else "" end')

              markdown_output+="\n| ${name} | ${endpoint} | ${status} | ${auth_sessions} | ${added} | ${current} |"
          fi
      done < <(echo "$servers_json" | jq -r '.servers[] | @base64')

      # Check if stdout is a TTY (interactive terminal) and glow is available
      if [ -t 1 ] && command -v glow >/dev/null 2>&1; then
          # Render with glow for interactive terminals (width=0 auto-detects terminal width)
          echo -e "$markdown_output" | glow --width=0 -
      else
          # Output raw markdown for pipes and non-interactive use
          echo -e "$markdown_output"
      fi

      echo
      if [ -n "$current_server" ]; then
          print_info "Current server: $current_server (marked with *)"
      else
          print_info "No current server selected"
          print_info "Use 'monk server use <name>' to select a server"
      fi
  else
      handle_output "$servers_json" "$output_format" "json" "server_list"
  fi
}

# :command.function
monk_server_current_command() {

  # src/commands/server/current.sh
  #!/bin/bash

  # server_current_command.sh - Show currently selected server with universal format support

  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      # No current server - generate appropriate response
      error_result='{"current_server": null, "error": "No current server selected"}'

      if [[ "$output_format" == "text" ]]; then
          print_info "No current server selected"
          print_info "Use 'monk server use <name>' to select a server"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 0
  fi

  server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      # Server not found in registry
      error_result=$(jq -n --arg server "$current_server" '{"current_server": $server, "error": "Server not found in registry"}')

      if [[ "$output_format" == "text" ]]; then
          print_error "Current server '$current_server' not found in registry"
          print_info "The server may have been deleted. Use 'monk server list' to see available servers"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  # Extract server details
  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  status=$(echo "$server_info" | jq -r '.status // "unknown"')
  description=$(echo "$server_info" | jq -r '.description // ""')
  base_url="$protocol://$hostname:$port"

  # Check authentication count
  auth_count=$(jq --arg server "$current_server" '[.sessions | to_entries[] | select(.key | startswith($server + ":"))] | length' "$AUTH_CONFIG" 2>/dev/null || echo "0")

  # Build JSON response
  server_json=$(jq -n \
      --arg name "$current_server" \
      --arg hostname "$hostname" \
      --arg port "$port" \
      --arg protocol "$protocol" \
      --arg endpoint "$base_url" \
      --arg status "$status" \
      --arg description "$description" \
      --argjson auth_count "$auth_count" \
      '{
          name: $name,
          hostname: $hostname,
          port: ($port | tonumber),
          protocol: $protocol,
          endpoint: $endpoint,
          base_url: $endpoint,
          status: $status,
          description: $description,
          auth_sessions: $auth_count
      }')

  # Handle text format with custom formatting for single server
  if [[ "$output_format" == "text" ]]; then
      echo
      print_info "Current Server"
      echo
      echo "Name: $current_server"
      echo "Endpoint: $base_url"
      echo "Status: $status"
      if [ -n "$description" ]; then
          echo "Description: $description"
      fi
      echo "Auth Sessions: $auth_count"
      echo
  else
      # Use universal handler for JSON output
      handle_output "$server_json" "$output_format" "json"
  fi
}

# :command.function
monk_server_use_command() {

  # src/commands/server/use.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # If no name provided, show current server (alias for 'current' command)
  if [ -z "$name" ]; then
      current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
          print_info "No current server selected"
          print_info "Use 'monk servers use <name>' to select a server"
          exit 0
      fi

      server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)
      if [ "$server_info" = "null" ]; then
          print_error "Current server '$current_server' not found in registry"
          print_info "The server may have been deleted. Use 'monk servers list' to see available servers"
          exit 1
      fi

      echo
      print_info "Current Server"
      echo

      hostname=$(echo "$server_info" | jq -r '.hostname')
      port=$(echo "$server_info" | jq -r '.port')
      protocol=$(echo "$server_info" | jq -r '.protocol')
      status=$(echo "$server_info" | jq -r '.status // "unknown"')
      description=$(echo "$server_info" | jq -r '.description // ""')

      echo "Name: $current_server"
      echo "Endpoint: $protocol://$hostname:$port"
      echo "Status: $status"
      if [ -n "$description" ]; then
          echo "Description: $description"
      fi

      # Show calculated base URL
      base_url="$protocol://$hostname:$port"
      echo "Base URL: $base_url"
      exit 0
  fi

  # Check if server exists
  server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  # Set as current server
  temp_file=$(mktemp)
  jq --arg name "$name" '.current_server = $name' "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

  # Get server details for confirmation
  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"

  print_success "Switched to server: $name"
  print_info "Endpoint: $base_url"
  print_info "All monk commands will now use this server"
  print_info "Base URL: $base_url"
}

# :command.function
monk_server_delete_command() {

  # src/commands/server/delete.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Check if server exists
  if ! jq -e ".servers.\"$name\"" "$SERVER_CONFIG" >/dev/null 2>&1; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  print_info "Deleting server: $name"

  # Remove server from config
  temp_file=$(mktemp)
  jq --arg name "$name" 'del(.servers[$name])' "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

  # If this was the current server, clear current
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ "$current_server" = "$name" ]; then
      jq '.current_server = null' "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
      print_info "Cleared current server (was deleted server)"
  fi

  print_success "Server '$name' deleted successfully"
}

# :command.function
monk_server_ping_command() {

  # src/commands/server/ping.sh
  #!/bin/bash

  # server_ping_command.sh - Health check server with universal format support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # If no name provided, use current server
  if [ -z "$name" ]; then
      name=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      if [ -z "$name" ] || [ "$name" = "null" ]; then
          error_result='{"error": "No server specified and no current server selected"}'

          if [[ "$output_format" == "text" ]]; then
              print_error "No server specified and no current server selected"
              print_info "Use 'monk server ping <name>' or 'monk server use <name>' first"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
      fi

      if [[ "$output_format" == "text" ]]; then
          print_info "Using current server: $name"
      fi
  fi

  # Get server info
  server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      error_result=$(jq -n --arg server_name "$name" '{"server_name": $server_name, "error": "Server not found"}')

      if [[ "$output_format" == "text" ]]; then
          print_error "Server '$name' not found"
          print_info "Use 'monk server list' to see available servers"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  if [[ "$output_format" == "text" ]]; then
      print_info "Pinging server: $name ($base_url)"
  fi

  # Test connectivity to root endpoint
  # Use curl's built-in timing to avoid bash arithmetic overflow
  if response_time_raw=$(curl -s --max-time 10 --fail -w '%{time_total}' -o /dev/null "$base_url/" 2>/dev/null); then
      # Convert seconds to milliseconds using awk
      response_time=$(echo "$response_time_raw" | awk '{printf "%.0f", $1 * 1000}')

      # Update status in config
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg timestamp "$timestamp" \
         '.servers[$name].last_ping = $timestamp | .servers[$name].status = "up"' \
         "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

      # Build success response JSON
      ping_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          --arg status "up" \
          --arg timestamp "$timestamp" \
          --argjson response_time_ms "$response_time" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              status: $status,
              timestamp: $timestamp,
              response_time_ms: $response_time_ms,
              success: true
          }')

      if [[ "$output_format" == "text" ]]; then
          print_success "Server is up and responding"
          print_info "Response time: ${response_time}ms"
      else
          handle_output "$ping_result" "$output_format" "json"
      fi
  else
      # Update status in config
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg timestamp "$timestamp" \
         '.servers[$name].last_ping = $timestamp | .servers[$name].status = "down"' \
         "$SERVER_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVER_CONFIG"

      # Build failure response JSON
      ping_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          --arg status "down" \
          --arg timestamp "$timestamp" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              status: $status,
              timestamp: $timestamp,
              success: false,
              error: "Server is down or not responding"
          }')

      if [[ "$output_format" == "text" ]]; then
          print_error "Server is down or not responding"
      else
          handle_output "$ping_result" "$output_format" "json"
      fi
      exit 1
  fi
}

# :command.function
monk_server_ping_all_command() {

  # src/commands/server/ping-all.sh
  echo "# This file is located at 'src/commands/server/ping-all.sh'."
  echo "# It contains the implementation for the 'monk server ping-all' command."
  echo "# The code you write here will be wrapped by a function named 'monk_server_ping_all_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_server_info_command() {

  # src/commands/server/info.sh
  #!/bin/bash

  # server_info_command.sh - Show server information from API root endpoint

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # If no name provided, use current server
  if [ -z "$name" ]; then
      name=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      if [ -z "$name" ] || [ "$name" = "null" ]; then
          error_result='{"error": "No server specified and no current server selected"}'

          if [[ "$output_format" == "text" ]]; then
              print_error "No server specified and no current server selected"
              print_info "Use 'monk server info <name>' or 'monk server use <name>' first"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
      fi

      if [[ "$output_format" == "text" ]]; then
          print_info "Using current server: $name"
      fi
  fi

  # Get server info
  server_info=$(jq -r ".servers.\"$name\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      error_result=$(jq -n --arg server_name "$name" '{"server_name": $server_name, "error": "Server not found"}')

      if [[ "$output_format" == "text" ]]; then
          print_error "Server '$name' not found"
          print_info "Use 'monk server list' to see available servers"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"

  # Fetch server info from API root endpoint
  if api_response=$(curl -s --max-time 10 --fail "$base_url/" 2>/dev/null); then
      # Parse the API response
      api_data=$(echo "$api_response" | jq -r '.data // empty' 2>/dev/null)

      if [ -z "$api_data" ] || [ "$api_data" = "null" ]; then
          error_result=$(jq -n --arg server_name "$name" --arg endpoint "$base_url" '{"server_name": $server_name, "endpoint": $endpoint, "error": "Invalid API response format"}')

          if [[ "$output_format" == "text" ]]; then
              print_error "Invalid API response format from server"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
      fi

      # Extract API information
      api_name=$(echo "$api_data" | jq -r '.name // "Unknown"')
      api_version=$(echo "$api_data" | jq -r '.version // "Unknown"')
      api_description=$(echo "$api_data" | jq -r '.description // ""')

      # Build complete info response
      info_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          --arg api_name "$api_name" \
          --arg api_version "$api_version" \
          --arg api_description "$api_description" \
          --argjson endpoints "$(echo "$api_data" | jq '.endpoints // {}')" \
          --argjson documentation "$(echo "$api_data" | jq '.documentation // null')" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              api: {
                  name: $api_name,
                  version: $api_version,
                  description: $api_description,
                  endpoints: $endpoints,
                  documentation: $documentation
              },
              status: "up",
              success: true
          }')

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Server Information: $name"
          echo
          print_info "Connection:"
          echo "  Endpoint: $base_url"
          echo "  Hostname: $hostname"
          echo "  Port: $port"
          echo "  Protocol: $protocol"
          echo
          print_info "API Details:"
          echo "  Name: $api_name"
          echo "  Version: $api_version"
          if [ -n "$api_description" ] && [ "$api_description" != "" ]; then
              echo "  Description: $api_description"
          fi
          echo
          print_info "Available Endpoints:"
          echo "$api_data" | jq -r '.endpoints | to_entries[] | "  \(.key): \(.value)"'

          # Display documentation if available
          documentation=$(echo "$api_data" | jq -r '.documentation // empty')
          if [ -n "$documentation" ] && [ "$documentation" != "null" ] && [ "$documentation" != "" ]; then
              echo
              print_info "Documentation:"

              # Show overview if available
              overview=$(echo "$api_data" | jq -r '.documentation.overview // empty')
              if [ -n "$overview" ] && [ "$overview" != "null" ] && [ "$overview" != "" ]; then
                  echo "  Overview: $overview"
              fi

              # Show API documentation if available
              apis=$(echo "$api_data" | jq -r '.documentation.apis // empty')
              if [ -n "$apis" ] && [ "$apis" != "null" ] && [ "$apis" != "" ]; then
                  echo "$api_data" | jq -r '.documentation.apis | to_entries[] | "  \(.key): \(.value)"'
              fi

              # Show errors documentation if available
              errors=$(echo "$api_data" | jq -r '.documentation.errors // empty')
              if [ -n "$errors" ] && [ "$errors" != "null" ] && [ "$errors" != "" ]; then
                  echo "  Errors: $errors"
              fi
          fi
      else
          handle_output "$info_result" "$output_format" "json"
      fi
  else
      error_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              status: "down",
              success: false,
              error: "Failed to connect to server or retrieve information"
          }')

      if [[ "$output_format" == "text" ]]; then
          print_error "Failed to connect to server '$name' at $base_url"
          print_info "Use 'monk server ping $name' to check connectivity"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi
}

# :command.function
monk_server_health_command() {

  # src/commands/server/health.sh
  #!/bin/bash

  # server_health_command.sh - Check server health status from API /health endpoint

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # If no name provided, use current server
  if [ -z "$name" ]; then
      name=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      if [ -z "$name" ] || [ "$name" = "null" ]; then
          error_result='{"error": "No server specified and no current server selected"}'

          if [[ "$output_format" == "text" ]]; then
              print_error "No server specified and no current server selected"
              print_info "Use 'monk server health <name>' or 'monk server use <name>' first"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
      fi

      if [[ "$output_format" == "text" ]]; then
          print_info "Using current server: $name"
      fi
  fi

  # Get server info (as JSON, not raw text)
  server_info=$(jq ".servers.\"$name\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ] || [ -z "$server_info" ]; then
      error_result=$(jq -n --arg server_name "$name" '{"server_name": $server_name, "error": "Server not found"}')

      if [[ "$output_format" == "text" ]]; then
          print_error "Server '$name' not found"
          print_info "Use 'monk server list' to see available servers"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  hostname=$(echo "$server_info" | jq -r '.hostname' 2>/dev/null)
  port=$(echo "$server_info" | jq -r '.port' 2>/dev/null)

  protocol=$(echo "$server_info" | jq -r '.protocol' 2>/dev/null)
  base_url="$protocol://$hostname:$port"

  # Fetch server health from API /health endpoint
  if api_response=$(curl -s --max-time 10 --fail "$base_url/health" 2>/dev/null); then
      # Parse the API response - check if there's a .data wrapper
      has_data_wrapper=$(echo "$api_response" | jq 'has("data")' 2>/dev/null)

      if [ "$has_data_wrapper" = "true" ]; then
          # Extract data from wrapper
          api_data=$(echo "$api_response" | jq '.data' 2>/dev/null)
      else
          # Use response directly if no wrapper
          api_data="$api_response"
      fi

      # Extract health information
      health_status=$(echo "$api_data" | jq -r '.status // "unknown"')
      server_version=$(echo "$api_data" | jq -r '.version // "unknown"')
      server_name_from_api=$(echo "$api_data" | jq -r '.name // "unknown"')
      uptime=$(echo "$api_data" | jq -r '.uptime // null')
      timestamp=$(echo "$api_data" | jq -r '.timestamp // null')

      # Extract database health if available
      database_status=$(echo "$api_data" | jq -r '.database // null')
      database_connected="null"

      # Extract any additional checks
      checks=$(echo "$api_data" | jq -r '.checks // {}')

      # Build health response
      health_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          --arg status "$health_status" \
          --arg version "$server_version" \
          --arg api_name "$server_name_from_api" \
          --arg uptime "$uptime" \
          --arg timestamp "$timestamp" \
          --arg database_status "$database_status" \
          --arg database_connected "$database_connected" \
          --argjson checks "$checks" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              health: {
                  status: $status,
                  version: $version,
                  name: $api_name,
                  uptime: $uptime,
                  timestamp: $timestamp,
                  database: (if $database_status != "null" then {
                      status: $database_status,
                      connected: ($database_connected | if . == "null" then null else . == "true" end)
                  } else null end),
                  checks: (if $checks != {} then $checks else null end)
              },
              success: true
          }')

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Server Health: $name"
          echo
          print_info "Connection:"
          echo "  Endpoint: $base_url/health"
          echo "  Hostname: $hostname"
          echo "  Port: $port"
          echo "  Protocol: $protocol"
          echo
          print_info "Health Status:"
          echo "  Status: $health_status"
          if [ "$server_version" != "unknown" ] && [ "$server_version" != "null" ]; then
              echo "  Version: $server_version"
          fi
          if [ "$server_name_from_api" != "unknown" ] && [ "$server_name_from_api" != "null" ]; then
              echo "  API Name: $server_name_from_api"
          fi
          if [ "$uptime" != "null" ]; then
              echo "  Uptime: $uptime"
          fi
          if [ "$timestamp" != "null" ]; then
              echo "  Timestamp: $timestamp"
          fi

          # Display database health if available
          if [ "$database_status" != "null" ]; then
              echo
              print_info "Database Health:"
              echo "  Status: $database_status"
              if [ "$database_connected" != "null" ]; then
                  echo "  Connected: $database_connected"
              fi
          fi

          # Display additional checks if available
          if [ "$(echo "$checks" | jq -r '. | length')" -gt 0 ]; then
              echo
              print_info "Additional Checks:"
              echo "$checks" | jq -r 'to_entries[] | "  \(.key): \(.value)"'
          fi

          # Overall status message
          echo
          if [ "$health_status" = "healthy" ] || [ "$health_status" = "ok" ] || [ "$health_status" = "up" ]; then
              print_success "Server is healthy and operational"
          elif [ "$health_status" = "degraded" ] || [ "$health_status" = "warning" ]; then
              print_warning "Server is operational but degraded"
          else
              print_warning "Server health status: $health_status"
          fi
      else
          handle_output "$health_result" "$output_format" "json"
      fi
  else
      error_result=$(jq -n \
          --arg server_name "$name" \
          --arg hostname "$hostname" \
          --arg port "$port" \
          --arg protocol "$protocol" \
          --arg endpoint "$base_url" \
          '{
              server_name: $server_name,
              hostname: $hostname,
              port: ($port | tonumber),
              protocol: $protocol,
              endpoint: $endpoint,
              health: {
                  status: "down"
              },
              success: false,
              error: "Failed to connect to server health endpoint"
          }')

      if [[ "$output_format" == "text" ]]; then
          print_error "Failed to check health of server '$name' at $base_url/health"
          print_info "The server may be down or the /health endpoint may be unavailable"
          print_info "Use 'monk server ping $name' to check basic connectivity"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi
}

# :command.function
monk_tenant_add_command() {

  # src/commands/tenant/add.sh
  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  name="${args[name]}"
  display_name="${args[display_name]}"
  description="${args[--description]}"

  # Get current server
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      print_error "No current server selected"
      print_info "Use 'monk server use <name>' to select a server first"
      exit 1
  fi

  # Validate tenant name
  if [[ ! "$name" =~ ^[a-zA-Z0-9][a-zA-Z0-9_-]*$ ]]; then
      print_error "Invalid tenant name: '$name'"
      print_info "Tenant names must start with alphanumeric character and contain only letters, numbers, hyphens, and underscores"
      exit 1
  fi

  # Check if tenant already exists for this server
  existing_tenant=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG" 2>/dev/null)
  if [ "$existing_tenant" != "null" ]; then
      existing_server=$(echo "$existing_tenant" | jq -r '.server')
      if [ "$existing_server" = "$current_server" ]; then
          print_error "Tenant '$name' already exists for server '$current_server'"
          exit 1
      elif [ "$existing_server" != "null" ]; then
          print_error "Tenant '$name' already exists for server '$existing_server'"
          print_info "Use a different tenant name or remove the existing tenant first"
          exit 1
      fi
  fi

  # Create timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  # Add tenant to config with server association
  temp_file=$(mktemp)
  jq --arg name "$name" \
     --arg display_name "$display_name" \
     --arg description "${description:-}" \
     --arg server "$current_server" \
     --arg timestamp "$timestamp" \
     '.tenants[$name] = {
         "display_name": $display_name,
         "description": $description,
         "server": $server,
         "added_at": $timestamp
     }' "$TENANT_CONFIG" > "$temp_file" && mv "$temp_file" "$TENANT_CONFIG"

  print_success "Added tenant '$name' ($display_name) for server '$current_server'"
  if [ -n "$description" ]; then
      print_info "Description: $description"
  fi
}

# :command.function
monk_tenant_list_command() {

  # src/commands/tenant/list.sh
  #!/bin/bash

  # tenant_list_command.sh - List all registered tenants with universal format support

  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  server_flag="${args[--server]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)

  # Determine target server
  target_server="$server_flag"
  if [ -z "$target_server" ]; then
      target_server="$current_server"
  fi

  if [ -z "$target_server" ] || [ "$target_server" = "null" ]; then
      error_result='{"error": "No server specified and no current server selected"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "No server specified and no current server selected"
          print_info "Use 'monk server use <name>' to select a server or use --server flag"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  # Get tenant names for the target server
  tenant_names=$(jq -r --arg server "$target_server" '.tenants | to_entries[] | select(.value.server == $server) | .key' "$TENANT_CONFIG" 2>/dev/null)

  if [ -z "$tenant_names" ]; then
      empty_result=$(jq -n --arg server "$target_server" '{"tenants": [], "current_tenant": null, "server": $server}')

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Registered Tenants for Server: $target_server"
          echo
          print_info "No tenants configured for this server"
          print_info "Use 'monk tenant add <name> <display_name>' to add tenants"
      else
          handle_output "$empty_result" "$output_format" "json"
      fi
      exit 0
  fi

  # Build JSON data for all tenants
  tenants_json=$(echo "$tenant_names" | while read -r name; do
      if [ -n "$name" ]; then
          tenant_info=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG")

          display_name=$(echo "$tenant_info" | jq -r '.display_name')
          description=$(echo "$tenant_info" | jq -r '.description // ""')
          server=$(echo "$tenant_info" | jq -r '.server')
          added_at=$(echo "$tenant_info" | jq -r '.added_at // "unknown"')

          # Check authentication count for this tenant on this specific server
          session_key="${server}:${name}"
          auth_count=$(jq --arg session_key "$session_key" '.sessions | has($session_key) | if . then 1 else 0 end' "$AUTH_CONFIG" 2>/dev/null || echo "0")
          is_current=$([ "$name" = "$current_tenant" ] && [ "$server" = "$current_server" ] && echo "true" || echo "false")

          jq -n \
              --arg name "$name" \
              --arg display_name "$display_name" \
              --arg description "$description" \
              --arg server "$server" \
              --arg added_at "$added_at" \
              --argjson auth_count "$auth_count" \
              --argjson is_current "$is_current" \
              '{
                  name: $name,
                  display_name: $display_name,
                  description: $description,
                  server: $server,
                  added_at: $added_at,
                  authenticated: ($auth_count > 0),
                  is_current: $is_current
              }'
      fi
  done | jq -s --arg current_tenant "$current_tenant" \
      --arg server "$target_server" \
      '{tenants: ., current_tenant: ($current_tenant | if . == "" then null else . end), server: $server}')

  # Output in requested format
  if [[ "$output_format" == "text" ]]; then
      echo
      print_info "Registered Tenants for Server: $target_server"
      echo

      # Build markdown table
      markdown_output=""
      markdown_output+="| NAME | DISPLAY NAME | AUTH | ADDED | DESCRIPTION | CURRENT |\n"
      markdown_output+="|------|--------------|------|-------|-------------|---------|"

      # Add data rows using process substitution to avoid subshell issues
      while IFS= read -r row; do
          if [ -n "$row" ]; then
              # Decode the row and extract fields
              decoded=$(echo "$row" | base64 -d)
              name=$(echo "$decoded" | jq -r '.name')
              display_name=$(echo "$decoded" | jq -r '.display_name')
              auth=$(echo "$decoded" | jq -r 'if .authenticated then "yes" else "no" end')
              added=$(echo "$decoded" | jq -r '.added_at' | cut -d'T' -f1)
              description=$(echo "$decoded" | jq -r '.description')
              current=$(echo "$decoded" | jq -r 'if .is_current then "*" else "" end')

              markdown_output+="\n| ${name} | ${display_name} | ${auth} | ${added} | ${description} | ${current} |"
          fi
      done < <(echo "$tenants_json" | jq -r '.tenants[] | @base64')

      # Check if stdout is a TTY (interactive terminal) and glow is available
      if [ -t 1 ] && command -v glow >/dev/null 2>&1; then
          # Render with glow for interactive terminals (width=0 auto-detects terminal width)
          echo -e "$markdown_output" | glow --width=0 -
      else
          # Output raw markdown for pipes and non-interactive use
          echo -e "$markdown_output"
      fi

      echo
      if [ -n "$current_tenant" ] && [ "$target_server" = "$current_server" ]; then
          print_info "Current tenant: $current_tenant (marked with *)"
      else
          print_info "No current tenant selected for this server"
          print_info "Use 'monk tenant use <name>' to select a tenant"
      fi
  else
      handle_output "$tenants_json" "$output_format" "json"
  fi
}

# :command.function
monk_tenant_delete_command() {

  # src/commands/tenant/delete.sh
  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  name="${args[name]}"

  # Check if tenant exists
  tenant_info=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG" 2>/dev/null)
  if [ "$tenant_info" = "null" ]; then
      print_error "Tenant '$name' not found"
      exit 1
  fi

  display_name=$(echo "$tenant_info" | jq -r '.display_name')

  # Check if this is the current tenant
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ "$name" = "$current_tenant" ]; then
      print_warning "Cannot delete current tenant '$name'"
      print_info "Use 'monk tenant use <other_tenant>' to switch first"
      exit 1
  fi

  # Check for active sessions
  auth_count=$(jq --arg tenant "$name" '[.sessions | to_entries[] | select(.key | endswith(":" + $tenant))] | length' "$AUTH_CONFIG" 2>/dev/null || echo "0")
  if [ "$auth_count" -gt 0 ]; then
      print_warning "Tenant '$name' has $auth_count active sessions"
      print_info "Sessions will be removed along with tenant"
  fi

  # Confirmation
  print_warning "Are you sure you want to delete tenant '$name' ($display_name)? (y/N)"
  read -r confirmation
  if ! echo "$confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
      print_info "Operation cancelled"
      exit 0
  fi

  # Remove tenant from config
  temp_file=$(mktemp)
  jq --arg name "$name" \
     'del(.tenants[$name])' \
     "$TENANT_CONFIG" > "$temp_file" && mv "$temp_file" "$TENANT_CONFIG"

  # Remove any sessions for this tenant
  temp_file=$(mktemp)
  jq --arg tenant "$name" \
     'del(.sessions[] | select(.tenant == $tenant))' \
     "$AUTH_CONFIG" > "$temp_file" && mv "$temp_file" "$AUTH_CONFIG"

  print_success "Deleted tenant '$name' ($display_name)"
  if [ "$auth_count" -gt 0 ]; then
      print_info "Removed $auth_count authentication sessions"
  fi
}

# :command.function
monk_tenant_use_command() {

  # src/commands/tenant/use.sh
  # Check dependencies
  check_dependencies

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant management"
      exit 1
  fi

  # Get arguments from bashly
  name="${args[name]}"

  # Get current server
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      print_error "No current server selected"
      print_info "Use 'monk server use <name>' to select a server first"
      exit 1
  fi

  # Check if tenant exists and belongs to current server
  tenant_info=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG" 2>/dev/null)
  if [ "$tenant_info" = "null" ]; then
      print_error "Tenant '$name' not found"
      print_info "Use 'monk tenant list' to see available tenants for current server"
      exit 1
  fi

  tenant_server=$(echo "$tenant_info" | jq -r '.server')
  if [ "$tenant_server" != "$current_server" ]; then
      print_error "Tenant '$name' belongs to server '$tenant_server', but current server is '$current_server'"
      print_info "Use 'monk server use $tenant_server' to switch servers first"
      exit 1
  fi

  # Update current tenant in env config
  temp_file=$(mktemp)
  jq --arg tenant "$name" \
     '.current_tenant = $tenant' \
     "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

  display_name=$(echo "$tenant_info" | jq -r '.display_name')
  print_success "Switched to tenant: $name ($display_name)"

  # Show authentication status for this tenant on current server
  session_key="${current_server}:${name}"
  if jq -e ".sessions.\"$session_key\"" "$AUTH_CONFIG" >/dev/null 2>&1; then
      user=$(jq -r ".sessions.\"$session_key\".user" "$AUTH_CONFIG" 2>/dev/null)
      print_info "Authenticated as: $user on server '$current_server'"
  else
      print_warning "Not authenticated for this tenant on server '$current_server'"
      print_info "Use 'monk auth login $name <username>' to authenticate"
  fi
}

# :command.function
monk_auth_list_command() {

  # src/commands/auth/list.sh
  #!/bin/bash

  # auth_list_command.sh - List all stored JWT tokens and sessions

  # Check dependencies
  check_dependencies

  # Initialize CLI configs
  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for token listing"
      exit 1
  fi

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Get current context information
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  current_user=$(jq -r '.current_user // empty' "$ENV_CONFIG" 2>/dev/null)

  # Get all sessions from auth config
  sessions=$(jq -r '.sessions | to_entries[] | .key' "$AUTH_CONFIG" 2>/dev/null)

  if [ -z "$sessions" ]; then
      empty_result='{"sessions": [], "current_session": null}'

      if [[ "$output_format" == "text" ]]; then
          echo
          print_info "Stored JWT Tokens"
          echo
          print_info "No stored authentication sessions found"
          print_info "Use 'monk auth login TENANT USERNAME' or 'monk auth register TENANT USERNAME' to create sessions"
      else
          handle_output "$empty_result" "$output_format" "json"
      fi
      exit 0
  fi

  # Build JSON data for all sessions
  sessions_json=$(echo "$sessions" | while read -r session_key; do
      if [ -n "$session_key" ]; then
          session_info=$(jq -r ".sessions.\"$session_key\"" "$AUTH_CONFIG")

          server=$(echo "$session_info" | jq -r '.server')
          tenant=$(echo "$session_info" | jq -r '.tenant')
          user=$(echo "$session_info" | jq -r '.user')
          created_at=$(echo "$session_info" | jq -r '.created_at // "unknown"')

          # Extract token expiration info
          token=$(echo "$session_info" | jq -r '.jwt_token')
          exp="unknown"
          exp_date="unknown"
          is_expired="unknown"

          # Try to decode JWT payload for expiration
          payload=$(echo "$token" | cut -d'.' -f2)
          case $((${#payload} % 4)) in
              2) payload="${payload}==" ;;
              3) payload="${payload}=" ;;
          esac

          if command -v base64 &> /dev/null; then
              decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
              if [ -n "$decoded" ]; then
                  exp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null || echo "unknown")

                  if [ "$exp" != "unknown" ] && [ "$exp" != "null" ]; then
                      # Check if expired
                      current_time=$(date +%s)
                      if [ "$exp" -gt "$current_time" ]; then
                          is_expired="false"
                      else
                          is_expired="true"
                      fi

                      # Format expiration date
                      if command -v date &> /dev/null; then
                          exp_date=$(date -r "$exp" 2>/dev/null || date -d "@$exp" 2>/dev/null || echo "unknown")
                      fi
                  fi
              fi
          fi

          # Check if this is the current session
          is_current="false"
          if [ "$server" = "$current_server" ] && [ "$tenant" = "$current_tenant" ] && [ "$user" = "$current_user" ]; then
              is_current="true"
          fi

          jq -n \
              --arg session_key "$session_key" \
              --arg server "$server" \
              --arg tenant "$tenant" \
              --arg user "$user" \
              --arg created_at "$created_at" \
              --arg exp "$exp" \
              --arg exp_date "$exp_date" \
              --argjson is_expired "$is_expired" \
              --argjson is_current "$is_current" \
              '{
                  session_key: $session_key,
                  server: $server,
                  tenant: $tenant,
                  user: $user,
                  created_at: $created_at,
                  expires_at: ($exp | if . == "unknown" then null else (. | tonumber) end),
                  expires_date: ($exp_date | if . == "unknown" then null else . end),
                  is_expired: ($is_expired == "true"),
                  is_current: ($is_current == "true")
              }'
      fi
  done | jq -s '{sessions: .}')

  # Find current session key
  current_session_key=""
  if [ -n "$current_server" ] && [ -n "$current_tenant" ] && [ -n "$current_user" ]; then
      current_session_key="${current_server}:${current_tenant}"
  fi

  # Add current session info to JSON
  final_json=$(echo "$sessions_json" | jq --arg current_session_key "$current_session_key" '. + {current_session: ($current_session_key | if . == "" then null else . end)}')

  # Output in requested format
  if [[ "$output_format" == "text" ]]; then
      echo
      print_info "Stored JWT Tokens"
      echo

      # Build markdown table
      markdown_output=""
      markdown_output+="| SESSION | SERVER | TENANT | USER | CREATED | EXPIRED | CURRENT |\n"
      markdown_output+="|---------|--------|--------|------|---------|---------|---------|"

      # Add data rows using process substitution to avoid subshell issues
      while IFS= read -r row; do
          if [ -n "$row" ]; then
              # Decode the row and extract fields
              decoded=$(echo "$row" | base64 -d)
              session_key=$(echo "$decoded" | jq -r '.session_key')
              server=$(echo "$decoded" | jq -r '.server')
              tenant=$(echo "$decoded" | jq -r '.tenant')
              user=$(echo "$decoded" | jq -r '.user')
              created=$(echo "$decoded" | jq -r '.created_at' | cut -d'T' -f1)
              expired=$(echo "$decoded" | jq -r 'if .is_expired then "yes" else "no" end')
              current=$(echo "$decoded" | jq -r 'if .is_current then "*" else "" end')

              markdown_output+="\n| ${session_key} | ${server} | ${tenant} | ${user} | ${created} | ${expired} | ${current} |"
          fi
      done < <(echo "$final_json" | jq -r '.sessions[] | @base64')

      # Check if stdout is a TTY (interactive terminal) and glow is available
      if [ -t 1 ] && command -v glow >/dev/null 2>&1; then
          # Render with glow for interactive terminals (width=0 auto-detects terminal width)
          echo -e "$markdown_output" | glow --width=0 -
      else
          # Output raw markdown for pipes and non-interactive use
          echo -e "$markdown_output"
      fi

      echo
      if [ -n "$current_session_key" ]; then
          print_info "Current session: $current_session_key (marked with *)"
      else
          print_info "No current session selected"
          print_info "Use 'monk tenant use <name>' to select a tenant"
      fi

      # Show expiration details for current session if available
      if [ -n "$current_session_key" ]; then
          current_session_info=$(echo "$final_json" | jq -r ".sessions[] | select(.session_key == \"$current_session_key\")")
          if [ -n "$current_session_info" ]; then
              exp_date=$(echo "$current_session_info" | jq -r '.expires_date // "unknown"')
              if [ "$exp_date" != "null" ] && [ "$exp_date" != "unknown" ]; then
                  print_info "Current session expires: $exp_date"
              fi
          fi
      fi
  else
      handle_output "$final_json" "$output_format" "json"
  fi
}

# :command.function
monk_auth_register_command() {

  # src/commands/auth/register.sh
  # Check dependencies
  check_dependencies

  # Initialize CLI configs
  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for tenant registration"
      exit 1
  fi

  # Extract tenant and username from bashly args
  tenant="${args[tenant]}"
  username="${args[username]}"

  print_info "Registering new tenant: $tenant, username: $username"

  # Prepare registration request
  register_data="{\"tenant\": \"$tenant\", \"username\": \"$username\"}"
  base_url=$(get_base_url)

  print_info "Sending registration request to: ${base_url}/auth/register"

  # Make registration request
  if response=$(make_request_json "POST" "/auth/register" "$register_data"); then
      # Extract token and registration details from response
      token=""
      database=""
      created_tenant=""
      created_username=""
      expires_in=""

      if [ "$JSON_PARSER" = "jq" ]; then
          token=$(echo "$response" | jq -r '.data.token' 2>/dev/null)
          database=$(echo "$response" | jq -r '.data.database' 2>/dev/null)
          created_tenant=$(echo "$response" | jq -r '.data.tenant' 2>/dev/null)
          created_username=$(echo "$response" | jq -r '.data.username' 2>/dev/null)
          expires_in=$(echo "$response" | jq -r '.data.expires_in' 2>/dev/null)
      elif [ "$JSON_PARSER" = "jshon" ]; then
          token=$(echo "$response" | jshon -e data -e token -u 2>/dev/null)
          database=$(echo "$response" | jshon -e data -e database -u 2>/dev/null)
          created_tenant=$(echo "$response" | jshon -e data -e tenant -u 2>/dev/null)
          created_username=$(echo "$response" | jshon -e data -e username -u 2>/dev/null)
          expires_in=$(echo "$response" | jshon -e data -e expires_in -u 2>/dev/null)
      else
          # Fallback: extract fields manually
          token=$(echo "$response" | grep -o '"token":"[^"]*"' | cut -d'"' -f4)
          database=$(echo "$response" | grep -o '"database":"[^"]*"' | cut -d'"' -f4)
          created_tenant=$(echo "$response" | grep -o '"tenant":"[^"]*"' | cut -d'"' -f4)
          created_username=$(echo "$response" | grep -o '"username":"[^"]*"' | cut -d'"' -f4)
          expires_in=$(echo "$response" | grep -o '"expires_in":[^,]*' | cut -d':' -f2)
      fi

      if [ -n "$token" ] && [ "$token" != "null" ]; then
          # Get current server for tenant registration
          current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
          if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
              print_error "No current server selected"
              print_info "Use 'monk server use <name>' to select a server first"
              exit 1
          fi

          # Add tenant to tenant registry (similar to tenant add command)
          timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          temp_file=$(mktemp)
          jq --arg name "$created_tenant" \
             --arg display_name "$created_tenant" \
             --arg description "Auto-created via auth register" \
             --arg server "$current_server" \
             --arg timestamp "$timestamp" \
             '.tenants[$name] = {
                 "display_name": $display_name,
                 "description": $description,
                 "server": $server,
                 "added_at": $timestamp
             }' "$TENANT_CONFIG" > "$temp_file" && mv "$temp_file" "$TENANT_CONFIG"

          # Store token with tenant and username
          store_token "$token" "$created_tenant" "$created_username"

          print_success "Registration successful"
          print_info_always "Tenant: $created_tenant"
          print_info_always "Database: $database"
          print_info_always "Username: $created_username"
          print_info_always "Token expires in: ${expires_in} seconds"
          print_info_always "JWT token stored for server+tenant context"
          print_info_always "Tenant added to local registry for server: $current_server"
      else
          print_error "Failed to extract registration data from response"
          print_info "Response: $response"
          exit 1
      fi
  else
      print_error "Registration failed"
      exit 1
  fi
}

# :command.function
monk_auth_login_command() {

  # src/commands/auth/login.sh
  # Check dependencies
  check_dependencies

  # Extract tenant and username from bashly args
  tenant="${args[tenant]}"
  username="${args[username]}"

  print_info "Authenticating with tenant: $tenant, username: $username"

  # Prepare authentication request
  auth_data="{\"tenant\": \"$tenant\", \"username\": \"$username\"}"
  base_url=$(get_base_url)

  print_info "Sending authentication request to: ${base_url}/auth/login"

  # Make authentication request
  if response=$(make_request_json "POST" "/auth/login" "$auth_data"); then
      # Extract token from response
      token=""
      if [ "$JSON_PARSER" = "jq" ]; then
          token=$(echo "$response" | jq -r '.data.token' 2>/dev/null)
      elif [ "$JSON_PARSER" = "jshon" ]; then
          token=$(echo "$response" | jshon -e data -e token -u 2>/dev/null)
      else
          # Fallback: extract token manually
          token=$(echo "$response" | grep -o '"token":"[^"]*"' | cut -d'"' -f4)
      fi

      if [ -n "$token" ] && [ "$token" != "null" ]; then
          # Store token with tenant and username
          store_token "$token" "$tenant" "$username"

          print_success "Authentication successful"
          print_info "JWT token stored for server+tenant context"
      else
          print_error "Failed to extract JWT token from response"
          print_info "Response: $response"
          exit 1
      fi
  else
      print_error "Authentication failed"
      exit 1
  fi
}

# :command.function
monk_auth_logout_command() {

  # src/commands/auth/logout.sh
  # Check dependencies
  check_dependencies

  # Check if we have any stored authentication
  if get_jwt_token >/dev/null 2>&1; then
      remove_stored_token
      print_success "Logged out successfully"
      print_info_always "Cleared authentication for current server+tenant context"
  else
      print_info_always "Already logged out (no active authentication found)"
  fi
}

# :command.function
monk_auth_status_command() {

  # src/commands/auth/status.sh
  #!/bin/bash

  # auth_status_command.sh - Show authentication status with universal format support

  # Check dependencies
  check_dependencies

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  token=$(get_jwt_token)

  # Get current context information
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  current_user=$(jq -r '.current_user // empty' "$ENV_CONFIG" 2>/dev/null)

  if [ -n "$token" ]; then
      # Extract token info
      tenant="unknown"
      database="unknown"
      exp="unknown"
      exp_date="unknown"

      # Try to extract domain from token (basic JWT decode)
      if [ "$JSON_PARSER" = "jq" ] || [ "$JSON_PARSER" = "jshon" ]; then
          # Decode JWT payload (basic base64 decode of middle part)
          payload=$(echo "$token" | cut -d'.' -f2)
          # Add padding if needed
          case $((${#payload} % 4)) in
              2) payload="${payload}==" ;;
              3) payload="${payload}=" ;;
          esac

          if command -v base64 &> /dev/null; then
              decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
              if [ -n "$decoded" ]; then
                  if [ "$JSON_PARSER" = "jq" ]; then
                      tenant=$(echo "$decoded" | jq -r '.tenant' 2>/dev/null || echo "unknown")
                      database=$(echo "$decoded" | jq -r '.database' 2>/dev/null || echo "unknown")
                      exp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null || echo "unknown")
                  elif [ "$JSON_PARSER" = "jshon" ]; then
                      tenant=$(echo "$decoded" | jshon -e tenant -u 2>/dev/null || echo "unknown")
                      database=$(echo "$decoded" | jshon -e database -u 2>/dev/null || echo "unknown")
                      exp=$(echo "$decoded" | jshon -e exp -u 2>/dev/null || echo "unknown")
                  fi

                  if [ "$exp" != "unknown" ] && [ "$exp" != "null" ]; then
                      if command -v date &> /dev/null; then
                          exp_date=$(date -r "$exp" 2>/dev/null || echo "unknown")
                      fi
                  fi
              fi
          fi
      fi

      # Build authenticated status JSON
      auth_status=$(jq -n \
          --arg authenticated "true" \
          --arg tenant "$tenant" \
          --arg database "$database" \
          --arg exp "$exp" \
          --arg exp_date "$exp_date" \
          --arg current_server "$current_server" \
          --arg current_tenant "$current_tenant" \
          --arg current_user "$current_user" \
          --arg has_token "true" \
          '{
              authenticated: ($authenticated == "true"),
              has_token: ($has_token == "true"),
              token_info: {
                  tenant: $tenant,
                  database: $database,
                  exp: ($exp | if . == "unknown" then null else (. | tonumber) end),
                  exp_date: ($exp_date | if . == "unknown" then null else . end)
              },
              current_context: {
                  server: ($current_server | if . == "" or . == "null" then null else . end),
                  tenant: ($current_tenant | if . == "" or . == "null" then null else . end),
                  user: ($current_user | if . == "" or . == "null" then null else . end)
              }
          }')

      if [[ "$output_format" == "text" ]]; then
          echo "Tenant: $tenant"
          echo "Database: $database"
          if [ "$exp_date" != "unknown" ]; then
              echo "Expires: $exp_date"
          fi
          echo "Server: $current_server"
          echo "Tenant: $current_tenant"
          echo "User: $current_user"
          print_success "Authenticated"
      else
          handle_output "$auth_status" "$output_format" "json"
      fi
  else
      # Build unauthenticated status JSON
      unauth_status=$(jq -n \
          --arg current_server "$current_server" \
          --arg current_tenant "$current_tenant" \
          --arg current_user "$current_user" \
          '{
              authenticated: false,
              has_token: false,
              token_info: null,
              current_context: {
                  server: ($current_server | if . == "" or . == "null" then null else . end),
                  tenant: ($current_tenant | if . == "" or . == "null" then null else . end),
                  user: ($current_user | if . == "" or . == "null" then null else . end)
              },
              message: "Not authenticated. Use monk auth login TENANT USERNAME to authenticate."
          }')

      if [[ "$output_format" == "text" ]]; then
          print_error "Not authenticated"
          print_info "Use 'monk auth login TENANT USERNAME' to authenticate"
      else
          handle_output "$unauth_status" "$output_format" "json"
      fi
  fi
}

# :command.function
monk_auth_token_command() {

  # src/commands/auth/token.sh
  token=$(get_jwt_token)

  if [ -n "$token" ]; then
      echo "$token"
  else
      print_error "No token found. Use 'monk auth login TENANT USERNAME' first"
      exit 1
  fi
}

# :command.function
monk_auth_info_command() {

  # src/commands/auth/info.sh
  #!/bin/bash

  # auth_info_command.sh - Decode and display JWT token contents with universal format support

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  token=$(get_jwt_token)

  if [ -z "$token" ]; then
      error_result='{"error": "No authentication token found", "message": "Use monk auth login TENANT USERNAME to authenticate"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "No authentication token found"
          print_info "Use 'monk auth login TENANT USERNAME' to authenticate"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  # Extract payload (second part) from JWT
  payload=$(echo "$token" | cut -d'.' -f2)

  # Add padding if needed for base64 decoding
  padding=$((4 - ${#payload} % 4))
  if [ $padding -ne 4 ]; then
      payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
  fi

  # Decode base64 payload
  if command -v base64 >/dev/null 2>&1; then
      decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
  else
      error_result='{"error": "base64 command not found"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "base64 command not found"
      else
          handle_output "$error_result" "$output_format" "json"
      fi
      exit 1
  fi

  if [ -n "$decoded" ]; then
      if command -v jq >/dev/null 2>&1; then
          # Add computed fields to the token payload for JSON output
          exp_timestamp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null)
          exp_date=""
          if [ "$exp_timestamp" != "null" ] && [ -n "$exp_timestamp" ]; then
              exp_date=$(date -r "$exp_timestamp" 2>/dev/null || echo 'unknown')
          fi

          # Build enhanced token info JSON
          token_info=$(echo "$decoded" | jq --arg exp_date "$exp_date" \
              '. + {
                  exp_date: (if $exp_date == "" or $exp_date == "unknown" then null else $exp_date end),
                  token_valid: true
              }')

          if [[ "$output_format" == "text" ]]; then
              # Human-readable output
              print_success "JWT Token Information:"
              echo

              # Extract key fields for display
              sub=$(echo "$decoded" | jq -r '.sub // "unknown"' 2>/dev/null)
              name=$(echo "$decoded" | jq -r '.name // "unknown"' 2>/dev/null)
              tenant=$(echo "$decoded" | jq -r '.tenant // "unknown"' 2>/dev/null)
              database=$(echo "$decoded" | jq -r '.database // "unknown"' 2>/dev/null)
              access=$(echo "$decoded" | jq -r '.access // "unknown"' 2>/dev/null)
              iat=$(echo "$decoded" | jq -r '.iat // "unknown"' 2>/dev/null)
              exp=$(echo "$decoded" | jq -r '.exp // "unknown"' 2>/dev/null)

              echo "Subject: $sub"
              echo "Name: $name"

              echo "Tenant: $tenant"
              echo "Database: $database"
              echo "Access Level: $access"

              if [ "$iat" != "unknown" ] && [ "$iat" != "null" ]; then
                  iat_date=$(date -r "$iat" 2>/dev/null || echo 'unknown')
                  echo "Issued At: $iat_date"
              fi

              if [ "$exp" != "unknown" ] && [ "$exp" != "null" ]; then
                  echo "Expires At: $exp_date"
              fi

              echo
          else
              handle_output "$token_info" "$output_format" "json"
          fi
      else
          # Fallback without jq
          fallback_result='{"error": "jq required for token parsing", "raw_payload": "'"$decoded"'"}'

          if [[ "$output_format" == "text" ]]; then
              print_error "jq required for token parsing"
              echo "Raw payload: $decoded"
          else
              handle_output "$fallback_result" "$output_format" "json"
          fi
      fi
  else
      decode_error='{"error": "Failed to decode JWT token", "message": "Token may be malformed"}'

      if [[ "$output_format" == "text" ]]; then
          print_error "Failed to decode JWT token"
          print_info "Token may be malformed"
      else
          handle_output "$decode_error" "$output_format" "json"
      fi
      exit 1
  fi
}

# :command.function
monk_auth_ping_command() {

  # src/commands/auth/ping.sh
  #!/bin/bash

  # auth_ping_command.sh - Authenticated API health check with universal format support

  # Check dependencies
  check_dependencies

  # Get flags from bashly args
  verbose_flag="${args[--verbose]}"
  jwt_token_arg="${args[--jwt-token]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Set CLI_VERBOSE if flag is present

  if [ "$verbose_flag" = "1" ] || [ "$verbose_flag" = "true" ]; then
      CLI_VERBOSE=true
  fi

  # Make ping request
  base_url=$(get_base_url)

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Pinging server at: $base_url"
  fi

  # Prepare curl arguments
  curl_args=(-s -X GET -H "Content-Type: application/json")

  # Add JWT token (provided via -j flag or stored token)
  token_to_use="$jwt_token_arg"
  if [ -z "$token_to_use" ]; then
      token_to_use=$(get_jwt_token)
  fi

  if [ -n "$token_to_use" ]; then
      curl_args+=(-H "Authorization: Bearer $token_to_use")
      if [ "$CLI_VERBOSE" = "true" ]; then
          if [ -n "$jwt_token_arg" ]; then
              print_info "Using provided JWT token"
          else
              print_info "Using stored JWT token"
          fi
      fi
  fi

  # Make request
  full_url="${base_url}/ping"
  response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
  http_code=$(echo "$response" | tail -n1)
  response=$(echo "$response" | sed '$d')
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  # Handle response based on HTTP code
  case "$http_code" in
      200)
          # Success - build response JSON
          if [ "$JSON_PARSER" = "jq" ]; then
              ping_result=$(echo "$response" | jq --arg http_code "$http_code" \
                  --arg timestamp "$timestamp" \
                  --arg success "true" \
                  '. + {
                      http_code: ($http_code | tonumber),
                      timestamp: $timestamp,
                      success: ($success == "true"),
                      reachable: true
                  }')
          else
              # Fallback JSON
              ping_result='{"success": true, "reachable": true, "http_code": '"$http_code"', "timestamp": "'"$timestamp"'", "raw_response": "'"$response"'"}'
          fi

          if [[ "$output_format" == "text" ]]; then
              if [ "$CLI_VERBOSE" = "true" ]; then
                  print_success "Server is reachable (HTTP $http_code)"
                  echo "Response: $response"
              else
                  # Parse response for clean output
                  if [ "$JSON_PARSER" = "jq" ]; then
                      pong=$(echo "$response" | jq -r '.pong' 2>/dev/null || echo "unknown")
                      domain=$(echo "$response" | jq -r '.domain' 2>/dev/null || echo "null")
                      database=$(echo "$response" | jq -r '.database' 2>/dev/null || echo "null")

                      echo "pong: $pong"
                      if [ "$domain" != "null" ] && [ "$domain" != "" ]; then
                          echo "domain: $domain"
                      fi
                      if [ "$database" != "null" ] && [ "$database" != "" ]; then
                          if [ "$database" = "ok" ]; then
                              echo "database: $database"
                          else
                              echo "database: ERROR - $database"
                          fi
                      fi
                  else
                      echo "Response: $response"
                  fi
              fi
          else
              handle_output "$ping_result" "$output_format" "json"
          fi
          ;;
      401)
          # Unauthorized
          error_result=$(jq -n \
              --arg http_code "$http_code" \
              --arg timestamp "$timestamp" \
              --arg error "Authentication failed" \
              '{
                  success: false,
                  reachable: true,
                  http_code: ($http_code | tonumber),
                  timestamp: $timestamp,
                  error: $error,
                  message: "JWT token is invalid or expired"
              }')

          if [[ "$output_format" == "text" ]]; then
              print_error "Authentication failed (HTTP $http_code)"
              print_info "JWT token is invalid or expired"
              print_info "Use 'monk auth login TENANT USERNAME' to re-authenticate"
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
          ;;
      *)
          # Other HTTP error
          error_result=$(jq -n \
              --arg http_code "$http_code" \
              --arg timestamp "$timestamp" \
              --arg response "$response" \
              '{
                  success: false,
                  reachable: (if ($http_code | tonumber) == 0 then false else true end),
                  http_code: ($http_code | tonumber),
                  timestamp: $timestamp,
                  error: "HTTP error",
                  response: $response
              }')

          if [[ "$output_format" == "text" ]]; then
              print_error "HTTP error ($http_code)"
              if [ "$CLI_VERBOSE" = "true" ]; then
                  echo "Response: $response"
              fi
          else
              handle_output "$error_result" "$output_format" "json"
          fi
          exit 1
          ;;
  esac
}

# :command.function
monk_auth_import_command() {

  # src/commands/auth/import.sh
  #!/bin/bash

  # auth_import_command.sh - Import JWT token from external auth flow
  #
  # This command allows users to manually store JWT tokens obtained from external
  # authentication systems (OAuth, SSO, external tools, web UI, etc.) without
  # going through the standard login flow.
  #
  # Usage Examples:
  #   monk auth import tenant-a admin --token "eyJhbGciOiJIUzI1NiIs..."
  #   echo "eyJhbGciOiJIUzI1NiIs..." | monk auth import tenant-a admin
  #   cat jwt-token.txt | monk auth import my-tenant developer
  #
  # Input Methods:
  #   1. Via --token/-t flag: Direct token parameter
  #   2. Via stdin: Pipe token content (useful for scripting)
  #
  # Token Storage:
  #   - Stores in current server+tenant context in auth.json
  #   - Updates env.json with current tenant and user
  #   - Validates token format (basic JWT structure check)
  #   - Sets secure permissions on auth config file
  #
  # Use Cases:
  #   - OAuth/SSO authentication flows
  #   - External authentication tools
  #   - Token sharing between environments

  #   - Manual token management for automation
  #   - Development/testing with pre-generated tokens
  #
  # Requirements:
  #   - Current server must be selected (monk server use <name>)
  #   - Valid JWT token format (basic validation only)
  #   - Tenant and username must be specified

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  tenant="${args[tenant]}"
  username="${args[username]}"
  token_flag="${args[--token]}"

  print_info "Importing JWT token for tenant: $tenant, username: $username"

  # Get token from flag or stdin
  if [ -n "$token_flag" ]; then
      token="$token_flag"
      print_info "Using token from --token parameter"
  else
      # Read token from stdin
      token=$(cat)
      if [ -z "$token" ]; then
          print_error "No JWT token provided"
          print_info "Usage: monk auth import <tenant> <username> --token <jwt>"
          print_info "   or: echo '<jwt>' | monk auth import <tenant> <username>"
          exit 1
      fi
      print_info "Using token from stdin"
  fi

  # Basic JWT format validation (should have 3 parts separated by dots)
  if ! echo "$token" | grep -q '^[^.]*\.[^.]*\.[^.]*$'; then
      print_error "Invalid JWT token format"
      print_info "JWT tokens should have format: header.payload.signature"
      exit 1
  fi

  # Store the token using the same mechanism as login
  store_token "$token" "$tenant" "$username"

  print_success "JWT token imported successfully"
  print_info_always "Token stored for server+tenant context"

  # Show current context
  if [ "$CLI_VERBOSE" = "true" ]; then
      current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
      print_info "Context: server=$current_server, tenant=$tenant, user=$username"
  fi
}

# :command.function
monk_auth_expires_command() {

  # src/commands/auth/expires.sh
  #!/bin/bash

  # auth_expires_command.sh - Show JWT token expiration time
  #
  # This command extracts and displays the expiration time from the current JWT token
  # in a human-readable format.
  #
  # Usage Examples:
  #   monk auth expires                    # Show expiration time
  #   monk auth expires > expiry.txt       # Save expiration to file
  #
  # Output Format:
  #   Displays the expiration date/time in local timezone
  #   Example: "Wed Aug 28 15:30:45 PDT 2025"
  #
  # Requirements:
  #   - Active authentication (JWT token available)
  #   - base64 command for JWT decoding
  #   - date command for timestamp formatting

  # Check dependencies
  check_dependencies

  token=$(get_jwt_token)

  if [ -z "$token" ]; then
      print_error "No authentication token found"
      print_info_always "Use 'monk auth login' or 'monk auth import' to authenticate"
      exit 1
  fi

  # Extract payload (second part) from JWT
  payload=$(echo "$token" | cut -d'.' -f2)

  # Add padding if needed for base64 decoding
  padding=$((4 - ${#payload} % 4))
  if [ $padding -ne 4 ]; then
      payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
  fi

  # Decode base64 payload
  if command -v base64 >/dev/null 2>&1; then
      decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
  else
      print_error "base64 command not found"
      exit 1
  fi

  if [ -n "$decoded" ]; then
      if command -v jq >/dev/null 2>&1; then
          exp_timestamp=$(echo "$decoded" | jq -r '.exp // empty' 2>/dev/null)
          if [ -n "$exp_timestamp" ] && [ "$exp_timestamp" != "null" ] && [ "$exp_timestamp" != "empty" ]; then
              exp_date=$(date -r "$exp_timestamp" 2>/dev/null || echo 'Invalid timestamp')
              echo "$exp_date"
          else
              print_error "No expiration timestamp found in JWT token"
              exit 1
          fi
      else
          print_error "jq required for JWT token parsing"
          exit 1
      fi
  else
      print_error "Failed to decode JWT token"
      exit 1
  fi
}

# :command.function
monk_auth_expired_command() {

  # src/commands/auth/expired.sh
  #!/bin/bash

  # auth_expired_command.sh - Check if JWT token is expired (exit code based)
  #
  # This command checks if the current JWT token has expired and returns
  # appropriate exit codes for scripting and automation.
  #
  # Usage Examples:
  #   monk auth expired && echo "Token valid"
  #   if monk auth expired; then echo "Need to re-authenticate"; fi
  #   monk auth expired || monk auth login tenant user
  #
  # Exit Codes:
  #   0: Token is valid (not expired)
  #   1: Token is expired or no token found
  #   1: Error in token processing
  #
  # Output:
  #   Minimal output by design - primarily for scripting
  #   Use 'monk auth expires' for human-readable expiration time
  #
  # Requirements:
  #   - Active authentication (JWT token available)
  #   - base64 command for JWT decoding
  #   - date command for timestamp comparison

  # Check dependencies
  check_dependencies

  token=$(get_jwt_token)

  if [ -z "$token" ]; then
      # No token found
      exit 1
  fi

  # Extract payload (second part) from JWT
  payload=$(echo "$token" | cut -d'.' -f2)

  # Add padding if needed for base64 decoding
  padding=$((4 - ${#payload} % 4))
  if [ $padding -ne 4 ]; then
      payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
  fi

  # Decode base64 payload
  if command -v base64 >/dev/null 2>&1; then
      decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
  else
      # Can't decode - assume expired for safety
      exit 1
  fi

  if [ -n "$decoded" ]; then
      if command -v jq >/dev/null 2>&1; then
          exp_timestamp=$(echo "$decoded" | jq -r '.exp // empty' 2>/dev/null)
          if [ -n "$exp_timestamp" ] && [ "$exp_timestamp" != "null" ] && [ "$exp_timestamp" != "empty" ]; then
              current_timestamp=$(date +%s)

              if [ "$exp_timestamp" -gt "$current_timestamp" ]; then
                  # Token is still valid
                  exit 0
              else
                  # Token is expired
                  exit 1
              fi
          else
              # No expiration found - assume expired for safety
              exit 1
          fi
      else
          # No jq - can't parse - assume expired for safety
          exit 1
      fi
  else
      # Failed to decode - assume expired for safety
      exit 1
  fi
}

# :command.function
monk_data_select_command() {

  # src/commands/data/select.sh
  #!/bin/bash

  # data_select_command.sh - Unified data selection with intelligent query routing
  #
  # This command handles all data selection scenarios:
  # 1. Direct ID selection for single records
  # 2. Default listing when no parameters provided

  # 3. Simple query parameters via --filter flag (limit, order, offset)
  # 4. Complex queries should use 'monk find' command directly
  #
  # Usage Examples:
  #   monk data select users 123                           # Get specific user by ID
  #   monk data select users                               # List all users (default)
  #   monk data select users --filter '{"limit": 10}'     # Limit results
  #   monk data select users --filter '{"order": "name asc"}'  # Sort by name
  #   monk data select users --filter '{"limit": 5, "offset": 10}'  # Pagination
  #
  # For complex queries with 'where' clauses, use:
  #   echo '{"where": {"status": "active"}}' | monk find users
  #
  # API Endpoints:
  #   GET /api/data/:schema/:id     (direct ID)
  #   GET /api/data/:schema         (default listing)
  #   GET /api/data/:schema?params  (with query string)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"
  filter_json="${args[--filter]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  if [ -n "$id" ]; then
      # Case 1: ID provided - direct record selection
      print_info "Selecting specific record: $id"
      response=$(make_request_json "GET" "/api/data/$schema/$id" "")
      handle_response_json "$response" "select"

  elif [ -n "$filter_json" ]; then
      # Case 2: Filter provided - parse and build query string
      print_info "Processing query filter for schema: $schema"

      # Check if this is a complex query that should use find command
      if has_complex_query "$filter_json"; then
          print_error "Complex queries with 'where' clauses should use 'monk find' command"
          print_info "Example: echo '$filter_json' | monk find $schema"
          exit 1
      fi

      # Build query string from filter parameters
      query_string=$(build_query_string "$filter_json")

      if [ -n "$query_string" ]; then
          print_info "Using query parameters: $query_string"
      else
          print_info "No valid query parameters found, using default selection"
      fi

      response=$(make_request_json "GET" "/api/data/$schema$query_string" "")
      handle_response_json "$response" "select"

  else
      # Case 3: No ID, no filter - default listing
      print_info "Selecting all records for schema: $schema"
      response=$(make_request_json "GET" "/api/data/$schema" "")
      handle_response_json "$response" "select"
  fi
}

# :command.function
monk_data_create_command() {

  # src/commands/data/create.sh
  #!/bin/bash

  # data_create_command.sh - Create records with flexible input handling
  #
  # This command creates new records in a schema with intelligent array/object handling:
  # - Single object input  wraps in array for API  unwraps response to match input
  # - Array input  sends directly to API  returns array response

  #
  # Usage Examples:
  #   echo '{"name": "John", "email": "john@example.com"}' | monk data create users
  #   cat user.json | monk data create users
  #   echo '[{"name": "Alice"}, {"name": "Bob"}]' | monk data create users  # Bulk create
  #
  # Input/Output Behavior:
  #   Object in  Object out (single record creation)
  #   Array in  Array out (bulk record creation)

  #
  # API Endpoint:
  #   POST /api/data/:schema (always expects array, handles wrapping/unwrapping)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  # Read and validate JSON input
  json_data=$(read_and_validate_json_input "creating" "$schema")

  # Process the create operation (uses handle_response_json which now outputs compact JSON)
  process_data_operation "create" "POST" "$schema" "" "$json_data"
}

# :command.function
monk_data_update_command() {

  # src/commands/data/update.sh
  #!/bin/bash

  # data_update_command.sh - Update records with flexible ID handling
  #
  # This command updates existing records with multiple input patterns:
  # - ID as parameter: uses object endpoint, removes ID from JSON payload
  # - ID extracted from JSON: uses object endpoint for single updates
  # - Array input: uses array endpoint for bulk updates
  #
  # Usage Examples:
  #   echo '{"name": "Updated Name"}' | monk data update users 123  # ID as param
  #   echo '{"id": 123, "name": "Updated Name"}' | monk data update users  # ID in JSON

  #   echo '[{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]' | monk data update users  # Bulk
  #
  # API Endpoints:
  #   PUT /api/data/:schema/:id  (single record - ID from parameter or extracted)
  #   PUT /api/data/:schema      (bulk update - array input)
  #
  # ID Handling:
  #   - Parameter ID takes precedence over JSON ID
  #   - JSON ID automatically extracted when parameter omitted
  #   - ID removed from payload for object endpoints (API requirement)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  # Read and validate JSON input
  json_data=$(read_and_validate_json_input "updating" "$schema")

  # Process the update operation
  process_data_operation "update" "PUT" "$schema" "$id" "$json_data"
}

# :command.function
monk_data_delete_command() {

  # src/commands/data/delete.sh
  #!/bin/bash

  # data_delete_command.sh - Delete records with confirmation and flexible input
  #
  # This command deletes records with multiple input patterns and safety confirmations:
  # - Direct ID deletion with optional confirmation prompts

  # - ID extracted from JSON objects for scripted deletions
  # - Bulk deletion from array input
  #
  # Usage Examples:
  #   monk data delete users 123                           # Direct ID deletion
  #   echo '{"id": 123}' | monk data delete users         # ID from JSON
  #   echo '[{"id": 1}, {"id": 2}]' | monk data delete users  # Bulk deletion
  #
  # Safety Features:
  #   - Confirmation prompts in CLI_VERBOSE mode for destructive operations
  #   - Clear error messages when ID missing from both parameter and JSON
  #
  # API Endpoints:
  #   DELETE /api/data/:schema/:id  (single record deletion)

  #   DELETE /api/data/:schema      (bulk deletion from array)
  #
  # Input Requirements:
  #   - Either ID parameter OR JSON with 'id' field(s) required
  #   - No payload sent for single deletions (just endpoint)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"

  # Data commands only support JSON format
  if [[ "${args[--text]}" == "1" ]]; then
      print_error "The --text option is not supported for data operations"
      print_info "Data operations require JSON format for structured data handling"
      exit 1
  fi

  validate_schema "$schema"

  if [ -n "$id" ]; then
      # ID provided - direct delete, no stdin needed
      process_data_operation "delete" "DELETE" "$schema" "$id" "" "true"
  elif [ -t 0 ]; then
      # No ID and no stdin (terminal input) - error
      print_error "No ID provided and no JSON data on stdin"
      print_info "Usage: monk data delete $schema <id> OR provide JSON with 'id' field(s) via stdin"
      exit 1
  else
      # No ID but have stdin - read and process JSON data
      json_data=$(read_and_validate_json_input "deleting" "$schema")
      process_data_operation "delete" "DELETE" "$schema" "" "$json_data" "true"
  fi
}

# :command.function
monk_data_export_command() {

  # src/commands/data/export.sh
  #!/bin/bash

  # data_export_command.sh - Export schema records to individual JSON files
  #
  # This command exports all records from a schema to separate JSON files in a directory.
  # Each record is saved as {record_id}.json with pretty-formatted JSON content.
  #
  # Usage Examples:
  #   monk data export users ./backup/users/              # Export to directory
  #   monk data export products /tmp/export-$(date +%Y%m%d)/  # Timestamped export
  #
  # Output Structure:
  #   - Creates target directory if it doesn't exist
  #   - One file per record: {directory}/{record_id}.json
  #   - Pretty-formatted JSON with 4-space indentation
  #   - Verbose progress reporting when CLI_VERBOSE=true
  #
  # Requirements:
  #   - Python3 required for JSON parsing and file operations
  #   - Records must have 'id' field for filename generation
  #   - Write permissions needed for target directory
  #
  # API Endpoint:
  #   GET /api/data/:schema (retrieves all records)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  directory="${args[dir]}"

  validate_schema "$schema"

  # Create directory if it doesn't exist
  if [ ! -d "$directory" ]; then
      print_info "Creating directory: $directory"
      mkdir -p "$directory"
  fi

  print_info "Exporting $schema records to: $directory"

  # Get all records using the API
  response=$(make_request_json "GET" "/api/data/$schema" "")

  # Check if jq is available (should be, since it's a hard dependency)
  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for export functionality"
      exit 1
  fi

  # Validate API response format
  if ! echo "$response" | jq -e '.success == true and .data' >/dev/null 2>&1; then
      print_error "Invalid API response format"
      echo "$response"
      exit 1
  fi

  # Export each record to individual JSON file
  count=0
  while IFS= read -r record; do
      # Extract ID from record
      id=$(echo "$record" | jq -r '.id // empty')

      if [ -z "$id" ] || [ "$id" = "null" ]; then
          print_warning "Skipping record without id field"
          continue
      fi

      # Write pretty-formatted JSON to file
      filename="$directory/$id.json"
      echo "$record" | jq '.' > "$filename"

      if [ $? -eq 0 ]; then
          print_info "Exported: $filename"
          count=$((count + 1))
      else
          print_error "Failed to write: $filename"
          exit 1
      fi

  done < <(echo "$response" | jq -c '.data[]')

  print_success "Successfully exported $count records to $directory"
}

# :command.function
monk_data_import_command() {

  # src/commands/data/import.sh
  #!/bin/bash

  # data_import_command.sh - Bulk import JSON files as records
  #
  # This command imports multiple JSON files from a directory as records in a schema.
  # All .json files are collected into an array and sent in a single bulk API request.
  #
  # Usage Examples:
  #   monk data import users ./backup/users/              # Import from directory
  #   monk data import products /tmp/migration/           # Migration import
  #
  # Input Structure:
  #   - Scans directory for all *.json files
  #   - Each file should contain a valid JSON object (one record)
  #   - Files processed in sorted order by filename
  #   - All records combined into array for bulk import
  #
  # Requirements:
  #   - Python3 required for JSON parsing and file operations
  #   - Directory must exist and contain .json files
  #   - Each JSON file must be valid and represent one record
  #
  # API Endpoint:

  #   PUT /api/data/:schema (bulk import with array payload)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  directory="${args[dir]}"

  validate_schema "$schema"

  if [ ! -d "$directory" ]; then
      print_error "Directory does not exist: $directory"
      exit 1
  fi

  print_info "Importing $schema records from: $directory"

  # Check if jq is available (should be, since it's a hard dependency)
  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for import functionality"
      exit 1
  fi

  # Check for JSON files in directory
  json_files=("$directory"/*.json)

  # Check if glob found any files (if not, array contains the literal pattern)
  if [ ! -f "${json_files[0]}" ]; then
      print_error "No .json files found in directory: $directory"
      exit 1
  fi

  print_info "Found ${#json_files[@]} JSON files to import"

  # Collect all JSON files into an array using jq
  records_json=$(jq -n --slurpfile records <(cat "${json_files[@]}") '$records')

  if [ -z "$records_json" ] || [ "$records_json" = "null" ]; then
      print_error "Failed to process JSON files"
      exit 1
  fi

  # Validate each file was valid JSON (jq would have failed above if not)
  count=0
  for file in "${json_files[@]}"; do
      filename=$(basename "$file")
      print_info "Loaded: $filename"
      count=$((count + 1))
  done

  print_info "Prepared $count records for import"

  # Make bulk import request
  response=$(make_request_json "PUT" "/api/data/$schema" "$records_json")

  print_success "Import completed successfully"
  handle_response_json "$response" "import"
}

# :command.function
monk_describe_list_command() {

  # src/commands/describe/list.sh
  #!/bin/bash

  # describe_list_command.sh - List all available schema names
  #
  # This command retrieves all schema names available in the current tenant.
  # Returns an array of schema names that can be queried with describe select.
  #
  # Usage Examples:
  #   monk describe list                    # List all schemas
  #   monk describe list --json             # JSON output format
  #   monk --text describe list             # Raw text output
  #
  # Output Format:
  #   - Text format: One schema name per line
  #   - JSON format: Returns full API response with schema array
  #
  # API Endpoint:
  #   GET /api/describe (returns array of schema names)

  # Check dependencies
  check_dependencies

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  print_info "Listing all available schemas"

  response=$(make_request_json "GET" "/api/describe" "")

  # Handle response based on output format
  if [[ "$output_format" == "json" ]]; then
      # JSON format - use standard handler (full response)
      handle_response_json "$response" "list"
  else
      # Text format - extract and display schema names one per line
      if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
          schema_count=$(echo "$response" | jq -r '.data | length')

          if [ "$schema_count" -eq 0 ]; then
              print_info "No schemas found"
          else
              echo "$response" | jq -r '.data[]'
          fi
      else
          handle_response_json "$response" "list"
      fi
  fi

}

# :command.function
monk_describe_select_command() {

  # src/commands/describe/select.sh
  #!/bin/bash

  # describe_select_command.sh - Retrieve specific schema definition

  #
  # This command retrieves the complete YAML schema definition for a named schema.
  # Returns the full schema specification including validation rules, properties, and metadata.
  #
  # Usage Examples:
  #   monk describe select schema users           # Get users schema definition
  #   monk describe select schema products > products.yaml  # Save schema to file
  #
  # Output Format:
  #   - Returns complete YAML schema definition
  #   - Includes JSON Schema validation rules, properties, required fields
  #   - Contains metadata like title, description, and custom attributes
  #
  # API Endpoint:
  #   GET /api/describe/:name (returns JSON schema content)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Validate schema name
  if [ -z "$schema" ]; then
      print_error "Schema name is required"
      exit 1
  fi

  print_info "Selecting schema: $schema"

  response=$(make_request_json "GET" "/api/describe/$schema" "")

  # Handle response based on output format
  if [[ "$output_format" == "json" ]]; then
      # JSON format - use standard handler (compact output)
      handle_response_json "$response" "select"
  else
      # Text format - pretty-print the schema for readability
      if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
          echo "$response" | jq -r '.data' | jq .
      else
          handle_response_json "$response" "select"
      fi
  fi

}

# :command.function
monk_describe_create_command() {

  # src/commands/describe/create.sh
  #!/bin/bash

  # describe_create_command.sh - Create new schema from JSON definition
  #
  # This command creates a new schema in the database from a JSON schema definition.
  # The schema definition includes JSON Schema validation rules and automatically
  # generates database DDL.
  #
  # Usage Examples:
  #   cat schema.json | monk describe create products    # Create from file
  #   echo '{...}' | monk describe create users          # Create from inline JSON
  #
  # Input Format:
  #   - JSON schema definition via stdin
  #   - Must include 'title' field for schema identification
  #   - Supports full JSON Schema specification (type, properties, required, etc.)
  #   - Optional metadata (description, examples)
  #
  # Schema Processing:
  #   - Validates JSON syntax and schema structure
  #   - Generates PostgreSQL table DDL automatically
  #   - Creates schema cache entry for performance
  #   - Prevents modification of system schemas
  #
  # API Endpoint:
  #   POST /api/describe/:name (Content-Type: application/json)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Validate schema name
  if [ -z "$schema" ]; then
      print_error "Schema name is required"
      exit 1
  fi

  # Read input data from stdin
  data=$(cat)

  if [ -z "$data" ]; then
      print_error "No schema data provided on stdin"
      print_info "Usage: cat schema.json | monk describe create <schema-name>"
      print_info "       echo '{...}' | monk describe create <schema-name>"
      exit 1
  fi

  # Validate JSON input
  if ! echo "$data" | jq . >/dev/null 2>&1; then
      print_error "Invalid JSON input"
      print_info "Describe create requires valid JSON schema definitions"
      exit 1
  fi

  # Validate that JSON has required title field
  if ! echo "$data" | jq -e '.title' >/dev/null 2>&1; then
      print_error "JSON schema must have a 'title' field"
      print_info "Example: {\"title\": \"$schema\", \"properties\": {...}}"
      exit 1
  fi

  print_info "Creating schema '$schema' with JSON data:"
  if [ "$CLI_VERBOSE" = "true" ]; then
      echo "$data" | jq . | sed 's/^/  /'
  fi

  response=$(make_request_json "POST" "/api/describe/$schema" "$data")
  handle_response_json "$response" "create"
}

# :command.function
monk_describe_update_command() {

  # src/commands/describe/update.sh
  #!/bin/bash

  # describe_update_command.sh - Update existing schema definition
  #
  # This command updates an existing schema with a new JSON definition.
  # Changes are applied to both the schema definition and underlying database table structure.
  # Supports additive changes safely, but breaking changes may affect existing data.
  #
  # Usage Examples:
  #   cat updated-schema.json | monk describe update users     # Update from file
  #   echo '{...}' | monk describe update products             # Update with inline JSON
  #
  # Input Format:
  #   - JSON schema definition via stdin
  #   - Must include 'title' field matching the schema name
  #   - Supports full JSON Schema specification
  #   - Additive changes (new fields) are generally safe
  #   - Breaking changes (removing required fields) may affect existing data
  #
  # Update Behavior:
  #   - Validates new schema definition
  #   - Compares with existing schema for compatibility
  #   - Updates PostgreSQL table structure (ADD/DROP columns as needed)
  #   - Preserves existing data where possible
  #   - System schemas cannot be modified
  #
  # API Endpoint:
  #   PUT /api/describe/:name (Content-Type: application/json)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Validate schema name
  if [ -z "$schema" ]; then
      print_error "Schema name is required"
      exit 1
  fi

  # Read input data from stdin
  data=$(cat)

  if [ -z "$data" ]; then
      print_error "No schema data provided on stdin"
      print_info "Usage: cat schema.json | monk describe update <schema-name>"
      print_info "       echo '{...}' | monk describe update <schema-name>"
      exit 1
  fi

  # Validate JSON input
  if ! echo "$data" | jq . >/dev/null 2>&1; then
      print_error "Invalid JSON input"
      print_info "Describe update requires valid JSON schema definitions"
      exit 1
  fi

  # Validate that JSON has required title field and it matches the schema name
  json_title=$(echo "$data" | jq -r '.title // empty')
  if [ -z "$json_title" ]; then
      print_error "JSON schema must have a 'title' field"
      print_info "Example: {\"title\": \"$schema\", \"properties\": {...}}"
      exit 1
  fi

  if [ "$json_title" != "$schema" ]; then
      print_warning "JSON title '$json_title' does not match schema name '$schema'"
      print_info "For safety, the JSON title should match the schema name being updated"
  fi

  print_info "Updating schema '$schema' with JSON data:"
  if [ "$CLI_VERBOSE" = "true" ]; then
      echo "$data" | jq . | sed 's/^/  /'
  fi

  response=$(make_request_json "PUT" "/api/describe/$schema" "$data")
  handle_response_json "$response" "update"
}

# :command.function
monk_describe_delete_command() {

  # src/commands/describe/delete.sh
  #!/bin/bash

  # describe_delete_command.sh - Delete schema definition
  #
  # This command soft deletes a schema definition. The schema is marked as deleted
  # but can be restored later. System schemas cannot be deleted.
  #
  # Usage Examples:
  #   monk describe delete test-schema          # Delete a test schema
  #   monk describe delete products             # Delete products schema
  #   monk describe delete old-users            # Delete old user schema
  #
  # Deletion Behavior:
  #   - Soft delete: Schema is marked as deleted but data remains
  #   - System schemas: Cannot be deleted (protected)
  #   - Restoration: Schemas can be restored via API (not yet in CLI)
  #
  # API Endpoint:
  #   DELETE /api/describe/:name (soft delete)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Validate schema name
  if [ -z "$schema" ]; then
      print_error "Schema name is required"
      exit 1
  fi

  print_info "Deleting schema: $schema"

  response=$(make_request_json "DELETE" "/api/describe/$schema" "")
  handle_response_json "$response" "delete"
}

# :command.function
monk_bulk_raw_command() {

  # src/commands/bulk/raw.sh
  #!/bin/bash

  # bulk_raw_command.sh - Execute bulk operations immediately (synchronous)
  #
  # This command executes an array of bulk operations in a single API transaction.
  # All operations are processed sequentially and results returned immediately.
  #
  # Usage Examples:
  #   cat operations.json | monk bulk raw
  #   echo '[{"operation": "create", "schema": "users", "data": {...}}]' | monk bulk raw
  #
  # Input Format - Array of operation objects:
  #   [
  #     {
  #       "operation": "create",        // Required: operation type
  #       "schema": "users",            // Required: schema name
  #       "data": {"name": "Alice"},    // Optional: record data
  #       "id": "123",                  // Optional: record ID
  #       "filter": {"status": "active"}, // Optional: filter criteria
  #       "message": "Custom error"     // Optional: custom error message
  #     }
  #   ]
  #
  # Supported Operations:
  #   Read: select, select-all, select-one, select-404, count
  #   Write: create, create-one, create-all, update, update-one, update-all, update-any, update-404
  #   Write: delete, delete-one, delete-all, delete-any, delete-404
  #   Access: access, access-one, access-all, access-any, access-404
  #   (upsert operations not yet implemented in API)
  #
  # Output Format:
  #   Returns same array with 'result' field added to each operation containing the operation outcome
  #
  # API Endpoint:
  #   POST /api/bulk (with operations array)
  #
  # Future Extensions:
  #   This 'raw' command provides immediate execution. Future async commands:
  #   - monk bulk submit (get operation ID)
  #   - monk bulk status <id> (check progress)

  #   - monk bulk result <id> (download results)

  # Check dependencies
  check_dependencies

  # Read and validate JSON input
  json_data=$(read_and_validate_json_input "executing bulk operations" "multiple schemas")

  # Validate that input is an array
  input_type=$(detect_input_type "$json_data")

  if [ "$input_type" != "array" ]; then
      print_error "Bulk operations require an array of operation objects"
      print_info "Usage: cat operations.json | monk bulk raw"
      print_info "Expected format: [{\"operation\": \"create\", \"schema\": \"users\", \"data\": {...}}]"
      exit 1
  fi

  # Validate basic structure of operations (best effort)
  if [ "$JSON_PARSER" = "jq" ]; then
      # Check that all items have required operation and schema fields
      missing_fields=$(echo "$json_data" | jq -r '.[] | select(.operation == null or .schema == null) | "missing operation or schema"' 2>/dev/null)

      if [ -n "$missing_fields" ]; then
          print_error "One or more operations missing required 'operation' and 'schema' fields"
          exit 1
      fi

      # Count operations for user feedback
      op_count=$(echo "$json_data" | jq 'length' 2>/dev/null || echo "unknown")
      print_info "Executing $op_count bulk operations"
  fi

  # Execute bulk operations via API
  response=$(make_request_json "POST" "/api/bulk" "$json_data")

  # Handle response - return full operations array with results
  handle_response_json "$response" "bulk"
}

# :command.function
monk_bulk_submit_command() {

  # src/commands/bulk/submit.sh
  #!/bin/bash

  # bulk_submit_command.sh - Submit bulk operations for async processing (FUTURE FEATURE)
  #
  # This command will submit bulk operations to a background processing queue
  # and return an operation ID for tracking progress and retrieving results.
  #
  # Planned Usage:
  #   cat large-operations.json | monk bulk submit
  #   # Returns: {"operation_id": "bulk-12345", "status": "submitted", "count": 1000}
  #
  # Input Format:
  #   Same as 'bulk raw' - array of operation objects with operation, schema, data, etc.
  #   Designed for large operation sets that would timeout in synchronous mode
  #
  # Planned API Endpoints:
  #   POST /api/bulk/async/submit  Returns operation ID
  #   Implementation requires:
  #   - Background job queue (Redis/database)
  #   - Operation progress tracking
  #   - Result storage and retrieval system
  #   - Timeout and retry handling
  #
  # Related Commands:
  #   monk bulk status <id>   # Check processing progress
  #   monk bulk result <id>   # Download completed results

  #   monk bulk cancel <id>   # Cancel pending operations
  #
  # Current Status: NOT IMPLEMENTED
  # API backend does not yet support async bulk operations

  # Check dependencies
  check_dependencies

  print_error "Async bulk operations not yet implemented"
  print_info "Use 'monk bulk raw' for immediate synchronous execution"
  print_info "Async bulk processing (submit/status/result) is planned for future release"
  exit 1
}

# :command.function
monk_bulk_status_command() {

  # src/commands/bulk/status.sh
  #!/bin/bash

  # bulk_status_command.sh - Check status of async bulk operation (FUTURE FEATURE)
  #
  # This command will check the processing status of a submitted bulk operation
  # and return progress information, estimated completion time, and current state.
  #
  # Planned Usage:
  #   monk bulk status bulk-12345
  #   # Returns: {"operation_id": "bulk-12345", "status": "processing", "progress": "450/1000", "eta": "2min"}
  #
  # Status States:
  #   - submitted: Operation queued, waiting to start
  #   - processing: Currently executing operations

  #   - completed: All operations finished successfully
  #   - failed: Operation failed with errors
  #   - cancelled: Operation was cancelled by user
  #
  # Progress Information:
  #   - Total operation count and completed count
  #   - Estimated time remaining based on current throughput
  #   - Success/error breakdown for completed operations
  #   - Current operation being processed
  #
  # Planned API Endpoint:
  #   GET /api/bulk/async/status/:operation_id
  #   Implementation requires:
  #   - Operation progress tracking in database/cache
  #   - Real-time status updates from background workers
  #   - Performance metrics for ETA calculations
  #
  # Error Handling:
  #   - Invalid operation ID returns appropriate error
  #   - Expired/cleaned up operations handled gracefully
  #
  # Current Status: NOT IMPLEMENTED
  # API backend does not yet support async bulk operations

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  operation_id="${args[operation_id]}"

  print_error "Async bulk status checking not yet implemented"
  print_info "Operation ID would be: $operation_id"
  print_info "Use 'monk bulk raw' for immediate synchronous execution"
  print_info "Async bulk processing (submit/status/result) is planned for future release"
  exit 1
}

# :command.function
monk_bulk_result_command() {

  # src/commands/bulk/result.sh
  #!/bin/bash

  # bulk_result_command.sh - Download results of completed bulk operation (FUTURE FEATURE)
  #
  # This command will download the complete results of a finished bulk operation,
  # including all operation outcomes, errors, and generated data.
  #
  # Planned Usage:
  #   monk bulk result bulk-12345
  #   monk bulk result bulk-12345 > results.json    # Save to file
  #   monk bulk result bulk-12345 --errors-only     # Only failed operations
  #
  # Result Format:
  #   Returns the original operations array with 'result' field populated for each operation:
  #   [
  #     {
  #       "operation": "create",
  #       "schema": "users",

  #       "data": {"name": "Alice"},
  #       "result": {"id": "user-789", "status": "success"}
  #     },
  #     {
  #       "operation": "update",
  #       "schema": "users",
  #       "id": "123",

  #       "data": {"name": "Updated"},
  #       "result": {"error": "Record not found", "status": "failed"}
  #     }
  #   ]
  #
  # Result Processing:
  #   - Full operation audit trail with success/failure status
  #   - Generated IDs for successful create operations
  #   - Detailed error messages for failed operations
  #   - Performance metrics (execution time, throughput)
  #   - Data integrity validation results
  #
  # Planned API Endpoint:
  #   GET /api/bulk/async/result/:operation_id
  #   Implementation requires:
  #   - Result storage system (database/file storage)
  #   - Result cleanup policies (TTL, size limits)
  #   - Streaming download for large result sets
  #
  # Error Handling:
  #   - Invalid operation ID returns appropriate error
  #   - Results not yet ready returns status information
  #   - Expired results handled with cleanup notification
  #
  # Current Status: NOT IMPLEMENTED
  # API backend does not yet support async bulk operations

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  operation_id="${args[operation_id]}"

  print_error "Async bulk result download not yet implemented"
  print_info "Operation ID would be: $operation_id"
  print_info "Use 'monk bulk raw' for immediate synchronous execution with results"
  print_info "Async bulk processing (submit/status/result) is planned for future release"
  exit 1
}

# :command.function
monk_bulk_cancel_command() {

  # src/commands/bulk/cancel.sh
  #!/bin/bash

  # bulk_cancel_command.sh - Cancel pending bulk operation (FUTURE FEATURE)
  #
  # This command will cancel a pending or in-progress bulk operation before completion,
  # allowing users to abort long-running batch processes when needed.
  #
  # Planned Usage:
  #   monk bulk cancel bulk-12345
  #   monk bulk cancel bulk-12345 --force    # Force cancel even if partially completed
  #
  # Cancellation Behavior:
  #   - submitted/queued operations: Immediately cancelled, no operations executed
  #   - processing operations: Graceful shutdown after current operation completes
  #   - completed operations: Cannot be cancelled, returns appropriate error
  #   - failed operations: Marks as cancelled instead of failed for clarity
  #
  # Cancellation Results:
  #   Returns summary of cancellation:
  #   {
  #     "operation_id": "bulk-12345",
  #     "status": "cancelled",
  #     "operations_completed": 150,
  #     "operations_cancelled": 850,
  #     "partial_results_available": true
  #   }
  #
  # Safety Features:
  #   - Confirmation prompt for operations with completed results
  #   - Partial results preserved and downloadable
  #   - Graceful shutdown prevents data corruption
  #   - Audit trail maintained for cancelled operations
  #
  # Planned API Endpoint:
  #   DELETE /api/bulk/async/:operation_id
  #   Implementation requires:
  #   - Background worker cancellation support
  #   - Partial result preservation
  #   - Operation state management
  #   - Cleanup of cancelled operation resources
  #
  # Edge Cases:
  #   - Operations that cannot be safely cancelled (mid-transaction)
  #   - Already completed operations (no-op with status info)
  #   - Invalid operation IDs handled gracefully
  #
  # Current Status: NOT IMPLEMENTED
  # API backend does not yet support async bulk operations

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  operation_id="${args[operation_id]}"

  print_error "Async bulk cancellation not yet implemented"
  print_info "Operation ID would be: $operation_id"
  print_info "Currently, only synchronous 'monk bulk raw' operations are supported"
  print_info "Async bulk processing (submit/status/result/cancel) is planned for future release"
  exit 1
}

# :command.function
monk_fs_ls_command() {

  # src/commands/fs/ls.sh
  #!/bin/bash

  # fs_ls_command.sh - List directory contents with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  long_flag="${args[--long]}"
  tenant_flag="${args[--tenant]}"

  print_info "Listing directory: $path"

  # Build file options
  long_format="false"
  if [ "$long_flag" = "1" ]; then
      long_format="true"
  fi

  file_options=$(jq -n \
      --argjson long_format "$long_format" \
      '{
          "show_hidden": false,
          "recursive": false,
          "long_format": $long_format
      }')

  # Make request with tenant routing - UPDATED to use /api/file/list
  response=$(make_file_request_with_routing "list" "$path" "$file_options" "$tenant_flag")

  # Extract and format entries
  entries=$(process_file_response "$response" "entries")
  format_ls_output "$entries" "$long_format"
}

# :command.function
monk_fs_cat_command() {

  # src/commands/fs/cat.sh
  #!/bin/bash

  # fs_cat_command.sh - Display file content with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  tenant_flag="${args[--tenant]}"

  print_info "Reading file content: $path"

  # Make request with tenant routing - UPDATED to use /api/file/retrieve
  response=$(make_file_request_with_routing "retrieve" "$path" "" "$tenant_flag")

  # Extract and display content
  content=$(process_file_response "$response" "content")

  if [ -n "$content" ] && [ "$content" != "null" ]; then
      # Pretty print JSON objects, show raw for simple values
      echo "$content" | jq . 2>/dev/null || echo "$content" | jq -r .
  else
      print_error "No content found for path: $path"
      exit 1
  fi
}

# :command.function
monk_fs_rm_command() {

  # src/commands/fs/rm.sh
  #!/bin/bash

  # fs_rm_command.sh - Remove files with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  path="${args[path]}"
  force_flag="${args[--force]}"
  tenant_flag="${args[--tenant]}"

  print_info "Removing: $path"

  # Build file options based on flags - UPDATED for /api/file/store endpoint
  permanent="false"
  if [ "$force_flag" = "true" ]; then
      permanent="true"
      print_warning "Permanent deletion requested (not recoverable)"
  else
      print_info "Using soft delete (recoverable)"
  fi

  # For deletion, we use the store endpoint with empty content and overwrite=true
  # The path determines what gets deleted (record or field)
  file_options=$(jq -n \
      --argjson permanent "$permanent" \
      '{
          "overwrite": true,
          "atomic": true
      }')

  # Confirmation prompt for destructive operations
  if [ "$force_flag" = "true" ] && [ "$CLI_VERBOSE" = "true" ]; then
      print_warning "Are you sure you want to permanently delete: $path? (y/N)"
      read -r confirmation

      if ! echo "$confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
          print_info_always "Operation cancelled"
          exit 0
      fi
  fi

  # Make request with tenant routing - UPDATED to use /api/file/store for deletion
  # For deletion operations, we send empty content to effectively "delete" the record/field
  deletion_payload=$(jq -n \
      --arg path "$path" \
      --argjson options "$file_options" \
      '{"path": $path, "content": null, "file_options": $options}')

  response=$(make_request_json "POST" "/api/file/store" "$deletion_payload")

  # Process deletion result
  if [ "$permanent" = "true" ]; then
      print_success "Permanently deleted: $path"
  else
      print_success "Soft deleted: $path (recoverable)"
  fi
}

# :command.function
monk_fs_stat_command() {

  # src/commands/fs/stat.sh
  #!/bin/bash

  # fs_stat_command.sh - Display detailed status with multi-tenant support

  # Check dependencies
  check_dependencies

  # Get arguments from bashly

  path="${args[path]}"
  tenant_flag="${args[--tenant]}"

  print_info "Getting status for: $path"

  # Make request with tenant routing - UPDATED to use /api/file/stat
  response=$(make_file_request_with_routing "stat" "$path" "" "$tenant_flag")

  # Extract basic information
  file_type=$(process_file_response "$response" "type")
  permissions=$(process_file_response "$response" "permissions")
  size=$(process_file_response "$response" "size")
  modified_time=$(process_file_response "$response" "modified_time")

  # Display basic stat information
  echo "  File: '$path'"
  echo "  Type: $file_type"
  echo "  Permissions: $permissions"

  echo "  Size: $size bytes"

  # Format and display timestamps
  if [ -n "$modified_time" ] && [ "$modified_time" != "null" ] && [ ${#modified_time} -eq 14 ]; then
      formatted_time=$(date -j -f "%Y%m%d%H%M%S" "$modified_time" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$modified_time")
      echo "Modified: $formatted_time"
  fi

  # Show record information if available
  record_info=$(process_file_response "$response" "record_info")
  if [ -n "$record_info" ] && [ "$record_info" != "null" ]; then
      echo
      echo "Record Information:"

      schema=$(echo "$record_info" | jq -r '.schema // "unknown"' 2>/dev/null)
      soft_deleted=$(echo "$record_info" | jq -r '.soft_deleted // false' 2>/dev/null)

      echo "  Schema: $schema"
      echo "  Soft Deleted: $soft_deleted"

      # Show access permissions if available
      access_perms=$(echo "$record_info" | jq -r '.access_permissions[]?' 2>/dev/null | tr '\n' ',' | sed 's/,$//')
      if [ -n "$access_perms" ]; then
          echo "  Access: $access_perms"
      fi
  fi

  # Show children count for directories
  children_count=$(process_file_response "$response" "children_count")
  if [ -n "$children_count" ] && [ "$children_count" != "null" ]; then
      echo
      echo "Directory contains: $children_count entries"
  fi
}

# :command.function
monk_fs_cp_command() {

  # src/commands/fs/cp.sh
  #!/usr/bin/env bash

  # fs_cp_command.sh
  # Copy records between schemas or duplicate records within the same schema

  # Check dependencies
  check_dependencies

  # Source and destination parsing
  source_path="${args[source]}"
  dest_path="${args[destination]}"
  force_flag="${args[--force]}"
  tenant_flag="${args[--tenant]}"

  print_info "Copying from: $source_path"
  print_info "Copying to: $dest_path"

  # Validate paths
  if [[ "$source_path" == "$dest_path" ]]; then
      print_error "Source and destination cannot be the same"
      exit 1
  fi

  # For now, implement single record copy only
  if [[ "$source_path" != *.json ]]; then
      print_error "Currently only single record copy is supported (must end in .json)"
      print_info "Use: monk fs cp /data/users/123.json /data/users/456.json"
      exit 1
  fi

  if [[ "$dest_path" != *.json ]]; then
      print_error "Destination must be a record file (must end in .json)"
      print_info "Use: monk fs cp /data/users/123.json /data/users/456.json"
      exit 1
  fi

  # First, get the source record
  print_info "Reading source record..."
  source_response=$(make_file_request_with_routing "retrieve" "$source_path" "" "$tenant_flag")
  source_content=$(process_file_response "$source_response" "content")

  if [ -z "$source_content" ] || [ "$source_content" = "null" ]; then
      print_error "Source record not found: $source_path"
      exit 1
  fi

  print_info "Source record loaded successfully"

  # For copy operations, we need to handle ID generation and remove system fields
  # Extract the record data without system fields
  clean_content=$(echo "$source_content" | jq 'del(.id, .created_at, .updated_at, .trashed_at, .deleted_at, .access_read, .access_edit, .access_full, .access_deny)')

  # Copy the record to destination
  print_info "Creating copy at destination..."
  copy_payload=$(jq -n \
      --arg path "$dest_path" \
      --argjson content "$clean_content" \
      '{"path": $path, "content": $content, "file_options": {"overwrite": true, "atomic": true}}')

  copy_response=$(make_request_json "POST" "/api/file/store" "$copy_payload")

  if echo "$copy_response" | jq -e '.success' > /dev/null; then
      print_success "Record copied successfully!"
      print_info "From: $source_path"
      print_info "To: $dest_path"

      # Show the new record
      dest_response=$(make_file_request_with_routing "retrieve" "$dest_path" "" "$tenant_flag")
      dest_content=$(process_file_response "$dest_response" "content")

      if [ -n "$dest_content" ] && [ "$dest_content" != "null" ]; then
          print_info "Copied record:"
          echo "$dest_content" | jq '.'
      fi
  else
      print_error "Copy failed: $(echo "$copy_response" | jq -r '.error // "Unknown error"')"
      exit 1
  fi
}

# :command.function
monk_find_command() {

  # src/commands/find.sh
  #!/bin/bash

  # find_command.sh - Advanced search with enterprise Filter DSL
  #
  # This command performs complex searches using the enterprise Filter DSL with support
  # for advanced filtering, nested queries, and result limiting options.
  #
  # Usage Examples:
  #   echo '{"where": {"name": {"$like": "john*"}}}' | monk find users
  #   echo '{"where": {"age": {"$gt": 25}}, "limit": 10}' | monk find users
  #   echo '{"where": {"$and": [{"status": "active"}, {"role": "admin"}]}}' | monk find users --head
  #   cat complex-query.json | monk find documents --tail
  #
  # Filter DSL Support:
  #   - Comparison operators: $eq, $ne, $gt, $gte, $lt, $lte
  #   - Array operators: $in, $nin, $any, $nany

  #   - Pattern matching: $like, $ilike (case-insensitive)
  #   - Logical operators: $and, $or, $not
  #   - Range operators: $between
  #   - Nested object queries and complex expressions
  #
  # Output Options:
  #   --head/-H: Return only the first record from results
  #   --tail/-T: Return only the last record from results
  #   (default): Return all matching records
  #
  # API Endpoint:
  #   POST /api/find/:schema (with Filter DSL JSON payload)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  head_flag="${args[--head]}"
  tail_flag="${args[--tail]}"

  validate_schema "$schema"

  # Read and validate JSON input (Filter DSL)
  json_data=$(read_and_validate_json_input "searching" "$schema")

  # Make the find request
  response=$(make_request_json "POST" "/api/find/$schema" "$json_data")

  # Process response with head/tail support
  if [ "$head_flag" = "true" ]; then
      # Extract first record from array
      print_info "Returning first record only"
      if [ "$JSON_PARSER" = "jq" ]; then
          if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
              first_record=$(echo "$response" | jq '.data[0] // null')
              echo "$response" | jq --argjson first "$first_record" '{"success": .success, "data": $first}'
          else
              echo "$response"
          fi
      else
          # Fallback for jshon or no parser
          if echo "$response" | grep -q '"success":true'; then
              first_record=$(echo "$response" | jshon -e data -e 0 2>/dev/null || echo "null")
              if [ "$first_record" != "null" ]; then
                  echo "{\"success\":true,\"data\":$first_record}"
              else
                  echo '{"success":true,"data":null}'
              fi
          else
              echo "$response"
          fi
      fi
  elif [ "$tail_flag" = "true" ]; then
      # Extract last record from array
      print_info "Returning last record only"
      if [ "$JSON_PARSER" = "jq" ]; then
          if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
              last_record=$(echo "$response" | jq '.data[-1] // null')
              echo "$response" | jq --argjson last "$last_record" '{"success": .success, "data": $last}'
          else
              echo "$response"
          fi
      else
          # Fallback for jshon or no parser
          if echo "$response" | grep -q '"success":true'; then
              array_length=$(echo "$response" | jshon -e data -l 2>/dev/null || echo "0")
              if [ "$array_length" -gt 0 ]; then
                  last_index=$((array_length - 1))
                  last_record=$(echo "$response" | jshon -e data -e "$last_index" 2>/dev/null || echo "null")
                  echo "{\"success\":true,\"data\":$last_record}"
              else
                  echo '{"success":true,"data":null}'
              fi
          else
              echo "$response"
          fi
      fi
  else
      # Use standard response handler
      handle_response_json "$response" "find"
  fi
}

# :command.function
monk_project_init_command() {

  # src/commands/project/init.sh
  #!/bin/bash

  # project_init_command.sh - Initialize new project with automatic tenant creation

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"
  description="${args[--description]}"
  tags="${args[--tags]}"
  create_user="${args[--create-user]}"
  auto_login="${args[--auto-login]}"
  host="${args[--host]:-localhost}"

  # Validate project name
  if [[ -z "$name" ]]; then
      print_error "Project name is required"
      exit 1
  fi

  # Sanitize tags if provided
  if [[ -n "$tags" ]]; then
      # Convert comma-separated to array and clean spaces
      IFS=',' read -ra TAG_ARRAY <<< "$tags"
      tags_json=$(printf '%s\n' "${TAG_ARRAY[@]}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | jq -R . | jq -s .)
  else
      tags_json="[]"
  fi

  print_info "Initializing project '$name'..."

  # Step 1: Create tenant using root API
  print_info "Creating tenant for project..."
  payload=$(jq -n \
      --arg name "$name" \
      --arg host "$host" \
      '{name: $name, host: $host}')

  response=$(make_root_request "POST" "tenant" "$payload")

  if ! echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Failed to create project tenant: $error_msg"
      exit 1
  fi

  tenant_info=$(echo "$response" | jq -r '.tenant')
  tenant_name=$(echo "$tenant_info" | jq -r '.name')
  database=$(echo "$tenant_info" | jq -r '.database')

  print_success "Project '$tenant_name' created successfully"
  print_info "Database: $database"

  # Step 2: Add tenant to local registry
  print_info "Adding tenant to local registry..."
  init_cli_configs

  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [[ -z "$current_server" || "$current_server" == "null" ]]; then
      print_error "No server selected. Use 'monk server use <name>' first."
      exit 1
  fi

  # Add to tenant registry
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  temp_file=$(mktemp)
  jq --arg name "$tenant_name" \
     --arg display_name "$tenant_name" \
     --arg description "${description:-}" \
     --arg server "$current_server" \
     --arg timestamp "$timestamp" \
     '.tenants[$name] = {
         "display_name": $display_name,
         "description": $description,
         "server": $server,
         "added_at": $timestamp
     }' "$TENANT_CONFIG" > "$temp_file" && mv "$temp_file" "$TENANT_CONFIG"

  # Step 3: Switch to new tenant context
  print_info "Switching to project context..."
  temp_file=$(mktemp)
  jq --arg tenant "$tenant_name" \
     '.current_tenant = $tenant' \
     "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

  # Step 4: Create initial user if requested
  if [[ -n "$create_user" ]]; then
      print_info "Creating initial user '$create_user'..."

      # Create user payload
      user_payload=$(jq -n \
          --arg username "$create_user" \
          --arg email "${create_user}@example.com" \
          --arg role "admin" \
          '{username: $username, email: $email, role: $role, password: "admin123"}')

      # Create user via API
      user_response=$(make_authenticated_request "POST" "data/users" "$user_payload")

      if echo "$user_response" | jq -e '.success or .id' >/dev/null 2>&1; then
          print_success "User '$create_user' created successfully"
          print_info "Default password: admin123 (change after first login)"

          # Auto-login if requested
          if [[ "$auto_login" == "1" ]]; then
              print_info "Logging in as '$create_user'..."
              login_payload=$(jq -n --arg username "$create_user" --arg password "admin123" '{username: $username, password: $password}')

              auth_response=$(curl -s -X POST \
                  -H "Content-Type: application/json" \
                  -d "$login_payload" \
                  "$(get_base_url)/api/auth/login")

              if echo "$auth_response" | jq -e '.token' >/dev/null 2>&1; then
                  token=$(echo "$auth_response" | jq -r '.token')
                  store_auth_token "$server_name" "$tenant_name" "$create_user" "$token"
                  print_success "Logged in as '$create_user'"
              else
                  print_error "Auto-login failed. Manual login required."
              fi
          fi
      else
          error_msg=$(echo "$user_response" | jq -r '.error // "Unknown error"')
          print_error "Failed to create user: $error_msg"
          print_info "You can create users manually after setup"
      fi
  fi

  # Step 5: Store project metadata
  project_metadata=$(jq -n \
      --arg name "$name" \
      --arg description "${description:-""}" \
      --argjson tags "$tags_json" \
      --arg created_at "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)" \
      --arg database "$database" \
      '{name: $name, description: $description, tags: $tags, created_at: $created_at, database: $database}')

  # Store in project registry
  project_file="${CLI_CONFIG_DIR}/projects.json"
  if [[ ! -f "$project_file" ]]; then
      echo '{"projects": []}' > "$project_file"
  fi

  # Add project to registry
  temp_file=$(mktemp)
  jq --argjson new_project "$project_metadata" '.projects += [$new_project]' "$project_file" > "$temp_file"
  mv "$temp_file" "$project_file"

  # Success message
  print_success "Project '$name' is ready!"
  echo
  print_info "Next steps:"
  echo "  monk status                    # Show current context"
  echo "  monk data select users         # Start working with data"
  echo "  monk describe create schema    # Create your first schema"

  if [[ -n "$create_user" ]]; then
      echo "  monk auth login $create_user  # Login as your user"
  fi

  echo
  print_info "Project management:"
  echo "  monk project list              # List all projects"
  echo "  monk project use <name>        # Switch projects"
  echo "  monk project show $name       # Project details"
}

# :command.function
monk_project_list_command() {

  # src/commands/project/list.sh
  #!/bin/bash

  # project_list_command.sh - List all projects (tenants)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  include_trashed="${args[--include-trashed]}"
  include_deleted="${args[--include-deleted]}"

  # Build query parameters
  params=""
  if [[ "$include_trashed" == "1" ]]; then
      params="${params}&include_trashed=true"
  fi
  if [[ "$include_deleted" == "1" ]]; then
      params="${params}&include_deleted=true"
  fi

  # Remove leading & if present
  params=${params#&}

  # Make request to root API
  if [[ -n "$params" ]]; then
      response=$(make_root_request "GET" "tenant?$params")
  else
      response=$(make_root_request "GET" "tenant")
  fi

  # Handle response
  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      tenants=$(echo "$response" | jq -r '.tenants[]?')

      if [[ -z "$tenants" ]]; then
          if [[ "$format_json" == "1" ]]; then
              echo '{"success":true,"tenants":[],"count":0}'
          else
              echo "No projects found."
          fi
          exit 0
      fi

  # Get current tenant for highlighting
  init_cli_configs
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      if [[ "$format_json" == "1" ]]; then
          # JSON output - return as-is with count
          count=$(echo "$response" | jq -r '.tenants | length')
          echo "$response" | jq --argjson count "$count" '. + {count: $count}'
      else
          # Text output - format as table
          echo
          printf "%-25s %-12s %-15s %-20s %s\n" "PROJECT" "STATUS" "DATABASE" "HOST" "CREATED"
          printf "%-25s %-12s %-15s %-20s %s\n" "-----------------------" "------------" "---------------" "--------------------" "-------------------"

          echo "$tenants" | while read -r tenant; do
              if [[ -n "$tenant" ]]; then
                  name=$(echo "$tenant" | jq -r '.name')
                  status=$(echo "$tenant" | jq -r '.status // "active"')
                  database=$(echo "$tenant" | jq -r '.database // "unknown"')
                  host=$(echo "$tenant" | jq -r '.host // "localhost"')
                  created=$(echo "$tenant" | jq -r '.created_at // "unknown"')

                  # Format created date
                  if [[ "$created" != "null" && "$created" != "unknown" ]]; then
                      created=$(date -d "$created" +%Y-%m-%d 2>/dev/null || echo "$created" | cut -d'T' -f1)
                  fi

                  # Highlight current tenant
                  if [[ "$name" == "$current_tenant" ]]; then
                      name="${name} *"
                  fi

                  printf "%-25s %-12s %-15s %-20s %s\n" "$name" "$status" "$database" "$host" "$created"
              fi
          done

          echo
          if [[ -n "$current_tenant" ]]; then
              echo "Current project: $current_tenant (server: $current_server)"
          else
              echo "No project selected. Use 'monk project use <name>' to select a project."
          fi

          # Show project count
          count=$(echo "$response" | jq -r '.tenants | length')
          echo "Total projects: $count"

          if [[ "$include_trashed" != "1" && "$include_deleted" != "1" ]]; then
              echo "Use --include-trashed or --include-deleted to show inactive projects."
          fi
      fi
  else
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Failed to list projects: $error_msg"
      exit 1
  fi
}

# :command.function
monk_project_show_command() {

  # src/commands/project/show.sh
  #!/bin/bash

  # project_show_command.sh - Show project details

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  if [[ -z "$name" ]]; then
      print_error "Project name is required"
      exit 1
  fi

  # Get tenant details from root API
  encoded_name=$(url_encode "$name")
  response=$(make_root_request "GET" "tenant/$encoded_name")

  if ! echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Failed to get project details: $error_msg"
      exit 1
  fi

  tenant=$(echo "$response" | jq -r '.tenant')

  if [[ "$format_json" == "1" ]]; then
      # JSON output - return tenant details
      echo "$response" | jq '{success: true, project: .tenant}'
  else
      # Text output - format nicely
      name=$(echo "$tenant" | jq -r '.name')
      status=$(echo "$tenant" | jq -r '.status // "active"')
      database=$(echo "$tenant" | jq -r '.database // "unknown"')
      host=$(echo "$tenant" | jq -r '.host // "localhost"')
      created=$(echo "$tenant" | jq -r '.created_at // "unknown"')
      updated=$(echo "$tenant" | jq -r '.updated_at // "unknown"')
      trashed=$(echo "$tenant" | jq -r '.trashed_at // null')
      deleted=$(echo "$tenant" | jq -r '.deleted_at // null')

      echo
      echo "Project: $name"
      echo "Status: $status"
      echo "Database: $database"
      echo "Host: $host"

      if [[ "$created" != "null" && "$created" != "unknown" ]]; then
          created_date=$(date -d "$created" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "$created")
          echo "Created: $created_date"
      fi

      if [[ "$updated" != "null" && "$updated" != "unknown" && "$updated" != "$created" ]]; then
          updated_date=$(date -d "$updated" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "$updated")
          echo "Updated: $updated_date"
      fi

      if [[ "$trashed" != "null" ]]; then
          trashed_date=$(date -d "$trashed" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "$trashed")
          echo "Trashed: $trashed_date"
      fi

      if [[ "$deleted" != "null" ]]; then
          deleted_date=$(date -d "$deleted" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "$deleted")
          echo "Deleted: $deleted_date"
      fi

  # Check if this is the current project
  init_cli_configs
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

      echo
      if [[ "$name" == "$current_tenant" ]]; then
          echo " This is your current project (server: $current_server)"
          echo
          echo "Quick actions:"
          echo "  monk data select          # List available schemas"
          echo "  monk describe select      # Show schema definitions"
          echo "  monk fs ls /data/         # Browse data"
      else
          echo " Switch to this project: monk project use $name"
      fi

      # Show project metadata if available
      project_file="${CLI_CONFIG_DIR}/projects.json"
      if [[ -f "$project_file" ]]; then
          project_meta=$(jq -r --arg name "$name" '.projects[] | select(.name == $name)' "$project_file")
          if [[ -n "$project_meta" && "$project_meta" != "null" ]]; then
              description=$(echo "$project_meta" | jq -r '.description // empty')
              tags=$(echo "$project_meta" | jq -r '.tags // [] | join(", ") // empty')

              if [[ -n "$description" ]]; then
                  echo "Description: $description"
              fi

              if [[ -n "$tags" ]]; then
                  echo "Tags: $tags"
              fi
          fi
      fi
  fi
}

# :command.function
monk_project_use_command() {

  # src/commands/project/use.sh
  #!/bin/bash

  # project_use_command.sh - Switch to project context

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  if [[ -z "$name" ]]; then
      print_error "Project name is required"
      exit 1
  fi

  # Check if project exists
  encoded_name=$(url_encode "$name")
  response=$(make_root_request "GET" "tenant/$encoded_name")

  if ! echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Project '$name' not found: $error_msg"
      exit 1
  fi

  tenant=$(echo "$response" | jq -r '.tenant')
  status=$(echo "$tenant" | jq -r '.status // "active"')

  # Check if tenant is active
  if [[ "$status" != "active" ]]; then
      print_error "Project '$name' is not active (status: $status)"
      print_info "Use 'monk project show $name' for details"
      exit 1
  fi

  # Get current server
  init_cli_configs
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [[ -z "$current_server" || "$current_server" == "null" ]]; then
      print_error "No server selected. Use 'monk server use <name>' first."
      exit 1
  fi

  # Check if tenant is registered locally
  tenant_info=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG" 2>/dev/null)
  if [[ "$tenant_info" == "null" ]]; then
      print_info "Project '$name' exists but is not in local registry."
      print_info "Adding to local registry..."

      # Add to tenant registry
      description=$(echo "$tenant" | jq -r '.description // ""')
      timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg display_name "$name" \
         --arg description "$description" \
         --arg server "$current_server" \
         --arg timestamp "$timestamp" \
         '.tenants[$name] = {
             "display_name": $display_name,
             "description": $description,
             "server": $server,
             "added_at": $timestamp
         }' "$TENANT_CONFIG" > "$temp_file" && mv "$temp_file" "$TENANT_CONFIG"
  fi

  # Switch to tenant context
  print_info "Switching to project '$name'..."
  temp_file=$(mktemp)
  jq --arg tenant "$name" \
     '.current_tenant = $tenant' \
     "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"

  # Verify the switch worked
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  if [[ "$current_tenant" == "$name" ]]; then
      print_success "Switched to project '$name'"

      # Show project info
      database=$(echo "$tenant" | jq -r '.database // "unknown"')
      host=$(echo "$tenant" | jq -r '.host // "localhost"')

      echo
      echo "Project: $name"
      echo "Database: $database"
      echo "Server: $current_server ($host)"
      echo
      echo "Next steps:"
      echo "  monk status              # Show current context"
      echo "  monk auth login <user>   # Authenticate to the project"
      echo "  monk data select         # List available schemas"
      echo "  monk fs ls /data/        # Browse project data"
  else
      print_error "Failed to switch to project '$name'"
      exit 1
  fi
}

# :command.function
monk_project_delete_command() {

  # src/commands/project/delete.sh
  #!/bin/bash

  # project_delete_command.sh - Delete project (soft delete by default)

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"
  force="${args[--force]}"
  permanent="${args[--permanent]}"

  if [[ -z "$name" ]]; then
      print_error "Project name is required"
      exit 1
  fi

  # Check if project exists
  encoded_name=$(url_encode "$name")
  response=$(make_root_request "GET" "tenant/$encoded_name")

  if ! echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Project '$name' not found: $error_msg"
      exit 1
  fi

  tenant=$(echo "$response" | jq -r '.tenant')
  status=$(echo "$tenant" | jq -r '.status // "active"')

  # Check if already deleted
  if [[ "$status" == "deleted" ]]; then
      print_error "Project '$name' is already permanently deleted"
      exit 1
  fi

  # Determine deletion type
  if [[ "$permanent" == "1" ]]; then
      delete_type="permanent"
      action="delete"
      warning="DANGER: This will PERMANENTLY delete project '$name' and all its data!"
  else
      delete_type="soft"
      action="trash"
      warning="This will move project '$name' to trash (can be restored)"
  fi

  # Confirmation prompt
  if [[ "$force" != "1" ]]; then
      echo "$warning"
      echo "Type 'DELETE' to confirm:"
      read -r confirmation
      if [[ "$confirmation" != "DELETE" ]]; then
          echo "Operation cancelled."
          exit 0
      fi
  fi

  # Perform deletion
  print_info "Deleting project '$name' ($delete_type deletion)..."

  if [[ "$permanent" == "1" ]]; then
      # Hard delete
      delete_response=$(make_root_request "DELETE" "tenant/$encoded_name?force=true")
  else
      # Soft delete (trash)
      delete_response=$(make_root_request "DELETE" "tenant/$encoded_name")
  fi

  if echo "$delete_response" | jq -e '.success' >/dev/null 2>&1; then
      if [[ "$permanent" == "1" ]]; then
          print_success "Project '$name' permanently deleted"

  # Remove from local registry
  init_cli_configs
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)
  if [[ -n "$current_server" && "$current_server" != "null" ]]; then
      tenant_info=$(jq -r ".tenants.\"$name\"" "$TENANT_CONFIG" 2>/dev/null)
      if [[ "$tenant_info" != "null" ]]; then
          temp_file=$(mktemp)
          jq --arg name "$name" 'del(.tenants[$name])' "$TENANT_CONFIG" > "$temp_file" && mv "$temp_file" "$TENANT_CONFIG"
          print_info "Removed from local registry"
      fi
  fi

          # Remove from project metadata
          project_file="${CLI_CONFIG_DIR}/projects.json"
          if [[ -f "$project_file" ]]; then
              temp_file=$(mktemp)
              jq --arg name "$name" '.projects |= map(select(.name != $name))' "$project_file" > "$temp_file"
              mv "$temp_file" "$project_file"
          fi

  # Clear context if this was the current project
  current_tenant=$(jq -r '.current_tenant // empty' "$ENV_CONFIG" 2>/dev/null)
  if [[ "$current_tenant" == "$name" ]]; then
      temp_file=$(mktemp)
      jq 'del(.current_tenant)' "$ENV_CONFIG" > "$temp_file" && mv "$temp_file" "$ENV_CONFIG"
      print_info "Cleared current project context"
  fi
      else
          print_success "Project '$name' moved to trash"
          print_info "Restore with: monk root tenant restore $name"
          print_info "Permanent delete with: monk project delete $name --permanent"
      fi
  else
      error_msg=$(echo "$delete_response" | jq -r '.error // "Unknown error"')
      print_error "Failed to delete project: $error_msg"
      exit 1
  fi
}

# :command.function
monk_docs_command() {

  # src/commands/docs.sh
  #!/bin/bash

  # docs_command.sh - Display API documentation from remote server
  #
  # This command dynamically discovers available documentation areas by querying
  # the API root endpoint, then fetches documentation for the requested area.
  #
  # Usage Examples:
  #   monk docs auth              # Display authentication API documentation
  #   monk docs data              # Display data API documentation

  #   monk docs meta              # Display metadata API documentation
  #   monk docs badarea           # Show available areas if no exact match
  #
  # Output Format:
  #   - Uses glow for enhanced markdown formatting when available
  #   - Falls back to raw markdown if glow not installed
  #   - Supports --text flag for raw markdown output
  #
  # Dynamic Discovery:
  #   - Queries GET / to get available documentation areas
  #   - Matches exact area name against documentation keys
  #   - Shows available areas if no exact match found

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  area="${args[area]}"

  # Determine output format from global flags
  output_format=$(get_output_format "glow")

  init_cli_configs

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for documentation commands"
      exit 1
  fi

  # Get current server
  current_server=$(jq -r '.current_server // empty' "$ENV_CONFIG" 2>/dev/null)

  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      print_error "No current server selected"
      print_info "Use 'monk server use <name>' to select a server first"
      exit 1
  fi

  # Get server info
  server_info=$(jq -r ".servers.\"$current_server\"" "$SERVER_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      print_error "Current server '$current_server' not found in registry"
      print_info "Use 'monk server list' to see available servers"
      exit 1
  fi

  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"

  print_info "Discovering available documentation areas from: $current_server"

  # Query API root to get available documentation areas
  if api_response=$(curl -s --max-time 30 --fail "$base_url/" 2>/dev/null); then
      # Extract documentation section
      if ! documentation_section=$(echo "$api_response" | jq -r '.data.documentation // empty' 2>/dev/null); then
          print_error "Failed to parse API response for documentation areas"
          exit 1
      fi

      if [ -z "$documentation_section" ] || [ "$documentation_section" = "null" ]; then
          print_error "No documentation section found in API response"
          print_info "The API may not support dynamic documentation discovery"
          exit 1
      fi

      # Get available areas (keys from documentation object)
      available_areas=$(echo "$documentation_section" | jq -r 'keys[]' 2>/dev/null)

      if [ -z "$available_areas" ]; then
          print_error "No documentation areas found"
          exit 1
      fi

      # Check if requested area exists (exact match)
      area_found=false
      area_routes=""

      for available_area in $available_areas; do
          if [ "$available_area" = "$area" ]; then
              area_found=true
              # Get the routes for this area (should be an array)
              area_routes=$(echo "$documentation_section" | jq -r ".$area[]" 2>/dev/null)
              break
          fi
      done

      if [ "$area_found" = false ]; then
          print_error "Documentation area '$area' not found"
          echo "Available documentation areas:" >&2
          for available_area in $available_areas; do
              echo "  - $available_area" >&2
          done
          exit 1
      fi

      # Use the first route for the area
      if [ -z "$area_routes" ]; then
          print_error "No documentation routes found for area '$area'"
          exit 1
      fi

      # Get the first route from the array
      first_route=$(echo "$area_routes" | head -n 1)

      if [ -z "$first_route" ]; then
          print_error "Empty documentation route for area '$area'"
          exit 1
      fi

      print_info "Fetching documentation for area '$area' from: $first_route"

      # Fetch documentation from the discovered route
      if docs_content=$(curl -s --max-time 30 --fail "$base_url$first_route" 2>/dev/null); then
          # Display content based on output format
          if [[ "$output_format" == "text" ]]; then
              # Raw markdown output when --text flag is used
              echo "$docs_content"
          elif command -v glow >/dev/null 2>&1; then
              # Use glow for enhanced formatting when available
              echo "$docs_content" | glow --width=0 --pager -
          else
              # Fallback to raw markdown if glow not installed
              echo "$docs_content"
          fi
      else
          print_error "Failed to fetch documentation from route '$first_route'"
          print_info "Ensure server is running and documentation endpoint is available"
          exit 1
      fi

  else
      print_error "Failed to query API root endpoint for documentation discovery"
      print_info "Ensure server '$current_server' is running and accessible"
      exit 1
  fi

}

# :command.function
monk_root_tenant_list_command() {

  # src/commands/root/tenant/list.sh
  #!/bin/bash

  # root_tenant_list_command.sh - List all tenants via /api/root/tenant

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  include_trashed="${args[--include-trashed]}"
  include_deleted="${args[--include-deleted]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Build query parameters
  params=""
  [[ "$include_trashed" == "1" ]] && params="?include_trashed=true"
  [[ "$include_deleted" == "1" ]] && params="${params:+${params}&}include_deleted=true"

  # Make request to root API
  endpoint="tenant${params}"
  response=$(make_root_request "GET" "$endpoint" "")

  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      if [[ "$output_format" == "text" ]]; then
          # Human-readable table output using existing function
          tenants=$(echo "$response" | jq -r '.tenants')
          format_tenant_table "$tenants" "$include_trashed" "$include_deleted"
      else
          # JSON output - pass through as compact JSON
          handle_output "$response" "$output_format" "json"
      fi
  else
      print_error "Failed to retrieve tenants"
      echo "$response" >&2
      exit 1
  fi
}

# :command.function
monk_root_tenant_create_command() {

  # src/commands/root/tenant/create.sh
  #!/bin/bash

  # root_tenant_create_command.sh - Create new tenant via /api/root/tenant

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"
  host="${args[--host]:-localhost}"
  force="${args[--force]}"

  # Create JSON payload
  payload=$(jq -n --arg name "$name" --arg host "$host" '{name: $name, host: $host}')

  # Check if tenant exists (unless force flag used)
  if [[ "$force" != "1" ]]; then
      # Use curl directly for existence check to avoid set -e issues
      base_url=$(get_base_url)
      local encoded_name=$(url_encode "$name")
      existing=$(curl -s "${base_url}/api/root/tenant/${encoded_name}" 2>/dev/null)

      if echo "$existing" | jq -e '.success and .tenant' >/dev/null 2>&1; then
          print_error "Tenant '$name' already exists. Use --force to override."
          exit 1
      fi
  fi

  print_info "Creating tenant with payload: $payload"

  # Make create request
  response=$(make_root_request "POST" "tenant" "$payload")

  # Handle response
  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      # API now returns tenant as object
      tenant=$(echo "$response" | jq -r '.tenant')
      tenant_name=$(echo "$tenant" | jq -r '.name')
      database=$(echo "$tenant" | jq -r '.database')
      tenant_host=$(echo "$tenant" | jq -r '.host')

      print_success "Tenant '$tenant_name' created successfully"
      print_info "Database: $database"
      print_info "Host: $tenant_host"
  else
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Failed to create tenant: $error_msg"
      exit 1
  fi
}

# :command.function
monk_root_tenant_show_command() {

  # src/commands/root/tenant/show.sh
  #!/bin/bash

  # root_tenant_show_command.sh - Show tenant details via /api/root/tenant/:name

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Make request to get tenant details
  response=$(make_root_request "GET" "tenant/${name}" "")

  if echo "$response" | jq -e '.success and .tenant' >/dev/null 2>&1; then
      if [[ "$output_format" == "text" ]]; then
          # Human-readable output
          tenant=$(echo "$response" | jq -r '.tenant')

          echo
          print_info "Tenant Details: $name"
          echo

          # Extract and display fields
          tenant_name=$(echo "$tenant" | jq -r '.name')
          database=$(echo "$tenant" | jq -r '.database')
          host=$(echo "$tenant" | jq -r '.host')
          status=$(echo "$tenant" | jq -r '.status')
          created_at=$(echo "$tenant" | jq -r '.created_at')
          updated_at=$(echo "$tenant" | jq -r '.updated_at')
          trashed_at=$(echo "$tenant" | jq -r '.trashed_at // "null"')

          printf "%-15s %s\n" "Name:" "$tenant_name"
          printf "%-15s %s\n" "Database:" "$database"
          printf "%-15s %s\n" "Host:" "$host"
          printf "%-15s %s\n" "Status:" "$status"
          printf "%-15s %s\n" "Created:" "$(echo "$created_at" | cut -d'T' -f1)"
          printf "%-15s %s\n" "Updated:" "$(echo "$updated_at" | cut -d'T' -f1)"

          if [[ "$trashed_at" != "null" ]]; then
              printf "%-15s %s\n" "Trashed:" "$(echo "$trashed_at" | cut -d'T' -f1)"
          fi

          echo
      else
          # JSON output - compact format
          handle_output "$response" "$output_format" "json"
      fi
  else
      error_msg=$(echo "$response" | jq -r '.error // "Tenant not found"')
      print_error "$error_msg"
      exit 1
  fi
}

# :command.function
monk_root_tenant_trash_command() {

  # src/commands/root/tenant/trash.sh
  #!/bin/bash

  # root_tenant_trash_command.sh - Soft delete tenant via /api/root/tenant/:name

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Confirmation prompt
  confirm_destructive_operation "soft delete tenant" "$name" "0"

  # Make soft delete request (DELETE without force parameter)
  response=$(make_root_request "DELETE" "tenant/${name}" "")

  # Handle response
  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      print_success "Tenant '$name' moved to trash"
      print_info "Use 'monk root tenant restore $name' to restore"
  else
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Failed to trash tenant: $error_msg"
      exit 1
  fi
}

# :command.function
monk_root_tenant_restore_command() {

  # src/commands/root/tenant/restore.sh
  #!/bin/bash

  # root_tenant_restore_command.sh - Restore soft deleted tenant via /api/root/tenant/:name

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Make restore request (PUT to clear trashed_at)
  response=$(make_root_request "PUT" "tenant/${name}" "")

  # Handle response
  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      print_success "Tenant '$name' restored from trash"
  else
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Failed to restore tenant: $error_msg"
      exit 1
  fi
}

# :command.function
monk_root_tenant_delete_command() {

  # src/commands/root/tenant/delete.sh
  #!/bin/bash

  # root_tenant_delete_command.sh - Hard delete tenant via /api/root/tenant/:name?force=true

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"
  force_flag="${args[--force]}"

  # Confirmation prompt (unless --force used)
  confirm_destructive_operation "PERMANENTLY delete tenant and database" "$name" "$force_flag" "DELETE"

  # Make hard delete request (DELETE with force=true parameter)
  # Handle query parameter separately from URL encoding
  base_url=$(get_base_url)
  encoded_name=$(url_encode "$name")
  response=$(curl -s -X DELETE "${base_url}/api/root/tenant/${encoded_name}?force=true")

  # Handle response
  if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
      print_success "Tenant '$name' permanently deleted"
      print_warning "Database and all data have been removed"
  else
      error_msg=$(echo "$response" | jq -r '.error // "Unknown error"')
      print_error "Failed to delete tenant: $error_msg"
      exit 1
  fi
}

# :command.function
monk_root_tenant_health_command() {

  # src/commands/root/tenant/health.sh
  #!/bin/bash

  # root_tenant_health_command.sh - Check tenant database health via /api/root/tenant/:name/health

  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  # Determine output format from global flags
  output_format=$(get_output_format "text")

  # Make health check request
  response=$(make_root_request "GET" "tenant/${name}/health" "")

  if echo "$response" | jq -e '.success and .health' >/dev/null 2>&1; then
      if [[ "$output_format" == "text" ]]; then
          # Human-readable output
          health=$(echo "$response" | jq -r '.health')

          tenant_name=$(echo "$health" | jq -r '.tenant')
          timestamp=$(echo "$health" | jq -r '.timestamp')
          status=$(echo "$health" | jq -r '.status')

          echo
          print_info "Health Check for Tenant: $tenant_name"
          echo
          printf "%-20s %s\n" "Status:" "$status"
          printf "%-20s %s\n" "Checked:" "$(echo "$timestamp" | cut -d'T' -f1,2 | tr 'T' ' ')"
          echo

          # Display individual checks
          echo "Database Checks:"
          checks=$(echo "$health" | jq -r '.checks')

          echo "$checks" | jq -r 'to_entries[] | "\(.key): \(.value)"' | while read -r check; do
              key=$(echo "$check" | cut -d':' -f1)
              value=$(echo "$check" | cut -d':' -f2 | tr -d ' ')

              if [[ "$value" == "true" ]]; then
                  printf "  %-25s %s\n" "$key" ""
              else
                  printf "  %-25s %s\n" "$key" ""
              fi
          done

          # Show errors if any
          errors=$(echo "$health" | jq -r '.errors[]?' 2>/dev/null)
          if [[ -n "$errors" ]]; then
              echo
              echo "Errors:"
              echo "$errors" | while read -r error; do
                  echo "   $error"
              done
          fi

          echo
      else
          # JSON output - compact format
          handle_output "$response" "$output_format" "json"
      fi
  else
      error_msg=$(echo "$response" | jq -r '.error // "Health check failed"')
      print_error "$error_msg"
      exit 1
  fi
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        monk_usage
        exit
        ;;

      # :flag.case
      --text)

        # :flag.case_no_arg
        args['--text']=1
        shift
        ;;

      # :flag.case
      --json)

        # :flag.case_no_arg
        args['--json']=1
        shift
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("CLI_VERBOSE")
  env_var_names+=("MONK_CLI_CONFIG_DIR")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init)
      action="init"
      shift
      monk_init_parse_requirements "$@"
      shift $#
      ;;

    examples)
      action="examples"
      shift
      monk_examples_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      monk_status_parse_requirements "$@"
      shift $#
      ;;

    server)
      action="server"
      shift
      monk_server_parse_requirements "$@"
      shift $#
      ;;

    tenant)
      action="tenant"
      shift
      monk_tenant_parse_requirements "$@"
      shift $#
      ;;

    auth)
      action="auth"
      shift
      monk_auth_parse_requirements "$@"
      shift $#
      ;;

    data)
      action="data"
      shift
      monk_data_parse_requirements "$@"
      shift $#
      ;;

    describe)
      action="describe"
      shift
      monk_describe_parse_requirements "$@"
      shift $#
      ;;

    bulk)
      action="bulk"
      shift
      monk_bulk_parse_requirements "$@"
      shift $#
      ;;

    fs)
      action="fs"
      shift
      monk_fs_parse_requirements "$@"
      shift $#
      ;;

    find)
      action="find"
      shift
      monk_find_parse_requirements "$@"
      shift $#
      ;;

    project)
      action="project"
      shift
      monk_project_parse_requirements "$@"
      shift $#
      ;;

    docs)
      action="docs"
      shift
      monk_docs_parse_requirements "$@"
      shift $#
      ;;

    root)
      action="root"
      shift
      monk_root_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_examples_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_examples_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="examples"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      monk_server_add_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_server_list_parse_requirements "$@"
      shift $#
      ;;

    current)
      action="current"
      shift
      monk_server_current_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      monk_server_use_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_server_delete_parse_requirements "$@"
      shift $#
      ;;

    ping)
      action="ping"
      shift
      monk_server_ping_parse_requirements "$@"
      shift $#
      ;;

    ping-all)
      action="ping-all"
      shift
      monk_server_ping_all_parse_requirements "$@"
      shift $#
      ;;

    info)
      action="info"
      shift
      monk_server_info_parse_requirements "$@"
      shift $#
      ;;

    health)
      action="health"
      shift
      monk_server_health_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_server_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --description)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description DESCRIPTION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        # :argument.case
        elif [[ -z ${args['endpoint']+x} ]]; then
          args['endpoint']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk server add NAME ENDPOINT [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['endpoint']+x} ]]; then
    printf "missing required argument: ENDPOINT\nusage: monk server add NAME ENDPOINT [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_server_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_current_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_current_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server current"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk server delete NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_server_ping_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_ping_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server ping"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_ping_all_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_ping_all_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server ping-all"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_info_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_info_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server info"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_server_health_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_server_health_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="server health"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      monk_tenant_add_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_tenant_list_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_tenant_delete_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      monk_tenant_use_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_tenant_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --description)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description DESCRIPTION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        # :argument.case
        elif [[ -z ${args['display_name']+x} ]]; then
          args['display_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant add NAME DISPLAY_NAME [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['display_name']+x} ]]; then
    printf "missing required argument: DISPLAY_NAME\nusage: monk tenant add NAME DISPLAY_NAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_tenant_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --server)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--server']="$2"
          shift
          shift
        else
          printf "%s\n" "--server requires an argument: --server SERVER" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant delete NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_tenant_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant use NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list)
      action="list"
      shift
      monk_auth_list_parse_requirements "$@"
      shift $#
      ;;

    register)
      action="register"
      shift
      monk_auth_register_parse_requirements "$@"
      shift $#
      ;;

    login)
      action="login"
      shift
      monk_auth_login_parse_requirements "$@"
      shift $#
      ;;

    logout)
      action="logout"
      shift
      monk_auth_logout_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      monk_auth_status_parse_requirements "$@"
      shift $#
      ;;

    token)
      action="token"
      shift
      monk_auth_token_parse_requirements "$@"
      shift $#
      ;;

    info)
      action="info"
      shift
      monk_auth_info_parse_requirements "$@"
      shift $#
      ;;

    ping)
      action="ping"
      shift
      monk_auth_ping_parse_requirements "$@"
      shift $#
      ;;

    import)
      action="import"
      shift
      monk_auth_import_parse_requirements "$@"
      shift $#
      ;;

    expires)
      action="expires"
      shift
      monk_auth_expires_parse_requirements "$@"
      shift $#
      ;;

    expired)
      action="expired"
      shift
      monk_auth_expired_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_auth_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_register_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_register_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth register"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['tenant']+x} ]]; then
          args['tenant']=$1
          shift
        # :argument.case
        elif [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tenant']+x} ]]; then
    printf "missing required argument: TENANT\nusage: monk auth register TENANT USERNAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: monk auth register TENANT USERNAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_login_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_login_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth login"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['tenant']+x} ]]; then
          args['tenant']=$1
          shift
        # :argument.case
        elif [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tenant']+x} ]]; then
    printf "missing required argument: TENANT\nusage: monk auth login TENANT USERNAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: monk auth login TENANT USERNAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_logout_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_logout_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth logout"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_token_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_token_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth token"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_info_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_info_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth info"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_ping_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_ping_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth ping"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      # :flag.case
      --jwt-token | -j)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--jwt-token']="$2"
          shift
          shift
        else
          printf "%s\n" "--jwt-token requires an argument: --jwt-token, -j TOKEN" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_import_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_import_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth import"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --token | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--token']="$2"
          shift
          shift
        else
          printf "%s\n" "--token requires an argument: --token, -t TOKEN" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['tenant']+x} ]]; then
          args['tenant']=$1
          shift
        # :argument.case
        elif [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tenant']+x} ]]; then
    printf "missing required argument: TENANT\nusage: monk auth import TENANT USERNAME [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: monk auth import TENANT USERNAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_expires_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_expires_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth expires"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_expired_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_expired_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth expired"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_data_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    select)
      action="select"
      shift
      monk_data_select_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      monk_data_create_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_data_update_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_data_delete_parse_requirements "$@"
      shift $#
      ;;

    export)
      action="export"
      shift
      monk_data_export_parse_requirements "$@"
      shift $#
      ;;

    import)
      action="import"
      shift
      monk_data_import_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_data_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_data_select_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_select_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data select"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --filter)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--filter']="$2"
          shift
          shift
        else
          printf "%s\n" "--filter requires an argument: --filter JSON" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data select SCHEMA [ID] [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data create SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data update SCHEMA [ID]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data delete SCHEMA [ID]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_export_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_export_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data export"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['dir']+x} ]]; then
          args['dir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data export SCHEMA DIR\n" >&2

    exit 1
  fi

  if [[ -z ${args['dir']+x} ]]; then
    printf "missing required argument: DIR\nusage: monk data export SCHEMA DIR\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_import_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_import_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data import"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['dir']+x} ]]; then
          args['dir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data import SCHEMA DIR\n" >&2

    exit 1
  fi

  if [[ -z ${args['dir']+x} ]]; then
    printf "missing required argument: DIR\nusage: monk data import SCHEMA DIR\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_describe_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list)
      action="list"
      shift
      monk_describe_list_parse_requirements "$@"
      shift $#
      ;;

    select)
      action="select"
      shift
      monk_describe_select_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      monk_describe_create_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_describe_update_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_describe_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_describe_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_describe_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="describe list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_describe_select_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_select_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="describe select"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk describe select SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_describe_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="describe create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk describe create SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_describe_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="describe update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk describe update SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_describe_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_describe_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="describe delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk describe delete SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_bulk_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    raw)
      action="raw"
      shift
      monk_bulk_raw_parse_requirements "$@"
      shift $#
      ;;

    submit)
      action="submit"
      shift
      monk_bulk_submit_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      monk_bulk_status_parse_requirements "$@"
      shift $#
      ;;

    result)
      action="result"
      shift
      monk_bulk_result_parse_requirements "$@"
      shift $#
      ;;

    cancel)
      action="cancel"
      shift
      monk_bulk_cancel_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_bulk_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_bulk_raw_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_raw_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bulk raw"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_bulk_submit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_submit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bulk submit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_bulk_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bulk status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['operation_id']+x} ]]; then
          args['operation_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['operation_id']+x} ]]; then
    printf "missing required argument: OPERATION_ID\nusage: monk bulk status OPERATION_ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_bulk_result_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_result_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bulk result"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['operation_id']+x} ]]; then
          args['operation_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['operation_id']+x} ]]; then
    printf "missing required argument: OPERATION_ID\nusage: monk bulk result OPERATION_ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_bulk_cancel_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_bulk_cancel_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="bulk cancel"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['operation_id']+x} ]]; then
          args['operation_id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['operation_id']+x} ]]; then
    printf "missing required argument: OPERATION_ID\nusage: monk bulk cancel OPERATION_ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    ls)
      action="ls"
      shift
      monk_fs_ls_parse_requirements "$@"
      shift $#
      ;;

    cat)
      action="cat"
      shift
      monk_fs_cat_parse_requirements "$@"
      shift $#
      ;;

    rm)
      action="rm"
      shift
      monk_fs_rm_parse_requirements "$@"
      shift $#
      ;;

    stat)
      action="stat"
      shift
      monk_fs_stat_parse_requirements "$@"
      shift $#
      ;;

    cp)
      action="cp"
      shift
      monk_fs_cp_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_fs_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_fs_ls_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_ls_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs ls"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --long | -l)

        # :flag.case_no_arg
        args['--long']=1
        shift
        ;;

      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs ls PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_cat_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_cat_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs cat"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs cat PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_rm_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_rm_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs rm"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs rm PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_stat_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_stat_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs stat"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['path']+x} ]]; then
          args['path']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['path']+x} ]]; then
    printf "missing required argument: PATH\nusage: monk fs stat PATH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_fs_cp_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_fs_cp_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="fs cp"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --recursive | -r)

        # :flag.case_no_arg
        args['--recursive']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --tenant | -t)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tenant']="$2"
          shift
          shift
        else
          printf "%s\n" "--tenant requires an argument: --tenant, -t TENANT" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['source']+x} ]]; then
          args['source']=$1
          shift
        # :argument.case
        elif [[ -z ${args['destination']+x} ]]; then
          args['destination']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['source']+x} ]]; then
    printf "missing required argument: SOURCE\nusage: monk fs cp SOURCE DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['destination']+x} ]]; then
    printf "missing required argument: DESTINATION\nusage: monk fs cp SOURCE DESTINATION [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_find_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_find_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="find"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --head | -H)

        # :flag.case_no_arg
        args['--head']=1
        shift
        ;;

      # :flag.case
      --tail | -T)

        # :flag.case_no_arg
        args['--tail']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk find SCHEMA [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_project_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_project_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    init)
      action="init"
      shift
      monk_project_init_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_project_list_parse_requirements "$@"
      shift $#
      ;;

    show | info)
      action="show"
      shift
      monk_project_show_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      monk_project_use_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_project_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_project_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_project_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_project_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="project init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --description)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description DESCRIPTION" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --tags)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--tags']="$2"
          shift
          shift
        else
          printf "%s\n" "--tags requires an argument: --tags TAGS" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --create-user)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--create-user']="$2"
          shift
          shift
        else
          printf "%s\n" "--create-user requires an argument: --create-user USERNAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --auto-login)

        # :flag.case_no_arg
        args['--auto-login']=1
        shift
        ;;

      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOSTNAME" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk project init NAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_project_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_project_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="project list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --include-trashed)

        # :flag.case_no_arg
        args['--include-trashed']=1
        shift
        ;;

      # :flag.case
      --include-deleted)

        # :flag.case_no_arg
        args['--include-deleted']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_project_show_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_project_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="project show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk project show NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_project_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_project_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="project use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk project use NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_project_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_project_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="project delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --permanent)

        # :flag.case_no_arg
        args['--permanent']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk project delete NAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_docs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_docs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="docs"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['area']+x} ]]; then
          args['area']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['area']+x} ]]; then
    printf "missing required argument: AREA\nusage: monk docs AREA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    tenant)
      action="tenant"
      shift
      monk_root_tenant_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_root_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_root_tenant_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list | ls)
      action="list"
      shift
      monk_root_tenant_list_parse_requirements "$@"
      shift $#
      ;;

    create | add)
      action="create"
      shift
      monk_root_tenant_create_parse_requirements "$@"
      shift $#
      ;;

    show | info)
      action="show"
      shift
      monk_root_tenant_show_parse_requirements "$@"
      shift $#
      ;;

    trash)
      action="trash"
      shift
      monk_root_tenant_trash_parse_requirements "$@"
      shift $#
      ;;

    restore)
      action="restore"
      shift
      monk_root_tenant_restore_parse_requirements "$@"
      shift $#
      ;;

    delete | purge)
      action="delete"
      shift
      monk_root_tenant_delete_parse_requirements "$@"
      shift $#
      ;;

    health)
      action="health"
      shift
      monk_root_tenant_health_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_root_tenant_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_root_tenant_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --include-trashed)

        # :flag.case_no_arg
        args['--include-trashed']=1
        shift
        ;;

      # :flag.case
      --include-deleted)

        # :flag.case_no_arg
        args['--include-deleted']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_root_tenant_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOSTNAME" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant create NAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_tenant_show_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_show_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant show"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant show NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_tenant_trash_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_trash_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant trash"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant trash NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_tenant_restore_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_restore_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant restore"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant restore NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_tenant_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --force)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant delete NAME [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_tenant_health_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_tenant_health_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root tenant health"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk root tenant health NAME\n" >&2

    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="2.15.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "init") monk_init_command ;;
    "examples") monk_examples_command ;;
    "status") monk_status_command ;;
    "server") monk_server_command ;;
    "server add") monk_server_add_command ;;
    "server list") monk_server_list_command ;;
    "server current") monk_server_current_command ;;
    "server use") monk_server_use_command ;;
    "server delete") monk_server_delete_command ;;
    "server ping") monk_server_ping_command ;;
    "server ping-all") monk_server_ping_all_command ;;
    "server info") monk_server_info_command ;;
    "server health") monk_server_health_command ;;
    "tenant") monk_tenant_command ;;
    "tenant add") monk_tenant_add_command ;;
    "tenant list") monk_tenant_list_command ;;
    "tenant delete") monk_tenant_delete_command ;;
    "tenant use") monk_tenant_use_command ;;
    "auth") monk_auth_command ;;
    "auth list") monk_auth_list_command ;;
    "auth register") monk_auth_register_command ;;
    "auth login") monk_auth_login_command ;;
    "auth logout") monk_auth_logout_command ;;
    "auth status") monk_auth_status_command ;;
    "auth token") monk_auth_token_command ;;
    "auth info") monk_auth_info_command ;;
    "auth ping") monk_auth_ping_command ;;
    "auth import") monk_auth_import_command ;;
    "auth expires") monk_auth_expires_command ;;
    "auth expired") monk_auth_expired_command ;;
    "data") monk_data_command ;;
    "data select") monk_data_select_command ;;
    "data create") monk_data_create_command ;;
    "data update") monk_data_update_command ;;
    "data delete") monk_data_delete_command ;;
    "data export") monk_data_export_command ;;
    "data import") monk_data_import_command ;;
    "describe") monk_describe_command ;;
    "describe list") monk_describe_list_command ;;
    "describe select") monk_describe_select_command ;;
    "describe create") monk_describe_create_command ;;
    "describe update") monk_describe_update_command ;;
    "describe delete") monk_describe_delete_command ;;
    "bulk") monk_bulk_command ;;
    "bulk raw") monk_bulk_raw_command ;;
    "bulk submit") monk_bulk_submit_command ;;
    "bulk status") monk_bulk_status_command ;;
    "bulk result") monk_bulk_result_command ;;
    "bulk cancel") monk_bulk_cancel_command ;;
    "fs") monk_fs_command ;;
    "fs ls") monk_fs_ls_command ;;
    "fs cat") monk_fs_cat_command ;;
    "fs rm") monk_fs_rm_command ;;
    "fs stat") monk_fs_stat_command ;;
    "fs cp") monk_fs_cp_command ;;
    "find") monk_find_command ;;
    "project") monk_project_command ;;
    "project init") monk_project_init_command ;;
    "project list") monk_project_list_command ;;
    "project show") monk_project_show_command ;;
    "project use") monk_project_use_command ;;
    "project delete") monk_project_delete_command ;;
    "docs") monk_docs_command ;;
    "root") monk_root_command ;;
    "root tenant") monk_root_tenant_command ;;
    "root tenant list") monk_root_tenant_list_command ;;
    "root tenant create") monk_root_tenant_create_command ;;
    "root tenant show") monk_root_tenant_show_command ;;
    "root tenant trash") monk_root_tenant_trash_command ;;
    "root tenant restore") monk_root_tenant_restore_command ;;
    "root tenant delete") monk_root_tenant_delete_command ;;
    "root tenant health") monk_root_tenant_health_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
